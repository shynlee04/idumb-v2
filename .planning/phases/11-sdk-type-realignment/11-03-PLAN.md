---
phase: 11-sdk-type-realignment
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - app/server/sdk-validators.ts
  - app/server/sessions.ts
autonomous: true

must_haves:
  truths:
    - "Zod schemas exist in sdk-validators.ts mirroring SDK Part discriminated union, Message union, Session, and SessionStatus shapes"
    - "Server function sessions.ts validates SDK data through Zod schemas before returning to clients"
    - "tsc --noEmit passes with zero errors after changes"
  artifacts:
    - path: "app/server/sdk-validators.ts"
      provides: "Zod boundary validation schemas for SDK types"
      exports: ["PartSchema", "MessageSchema", "SessionSchema", "validateSessionList", "validateMessages"]
      min_lines: 80
    - path: "app/server/sessions.ts"
      provides: "Server functions with Zod-validated SDK data at return boundaries"
  key_links:
    - from: "app/server/sdk-validators.ts"
      to: "app/server/sessions.ts"
      via: "import { validateSessionList, validateMessages }"
      pattern: "validate.*\\("
    - from: "app/server/sessions.ts"
      to: "app/hooks/useStreaming.ts"
      via: "server function returns flow to hooks via React Query / loader"
      pattern: "createServerFn"
---

<objective>
Create Zod boundary validation schemas for SDK types and wire them into server functions so SDK data is validated at runtime before reaching hooks/components.

Purpose: TypeScript types are compile-time only — they can't catch runtime SDK shape changes (e.g., after SDK upgrade or API evolution). Zod schemas at server function boundaries provide runtime validation, catching shape mismatches before they cause cryptic UI errors.

Output: New `app/server/sdk-validators.ts` + updated `app/server/sessions.ts`
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-sdk-type-realignment/11-RESEARCH.md
@.planning/phases/11-sdk-type-realignment/11-01-SUMMARY.md
@app/server/validators.ts
@app/server/sessions.ts
@app/server/sdk-client.server.ts
@app/shared/engine-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod boundary schemas for SDK types</name>
  <files>app/server/sdk-validators.ts</files>
  <action>
Create `app/server/sdk-validators.ts` with Zod schemas that mirror the SDK type shapes. Follow the existing pattern from `app/server/validators.ts` (uses `import { z } from 'zod'` — this is Zod 4.3.6).

**CRITICAL:** Read `11-CONTRACTS.md` (from Plan 11-01) for exact SDK field shapes. If 11-01 SUMMARY doesn't exist yet, read `node_modules/@opencode-ai/sdk/dist/gen/types.gen.d.ts` directly.

**CRITICAL:** These are VALIDATION schemas for runtime checking, NOT type definitions. The TypeScript types come from the SDK. Zod schemas validate that runtime data matches expected shapes.

Create these schemas:

1. **PartSchema** — `z.discriminatedUnion('type', [...])` covering all 11 Part subtypes:
   - `text`: `{ type: 'text', id, content: string, ... }`
   - `tool`: `{ type: 'tool', id, name, state, input, output, ... }`
   - `file`: `{ type: 'file', id, mediaType, filename, url, ... }`
   - `reasoning`: `{ type: 'reasoning', id, content, ... }`
   - `step-start`: `{ type: 'step-start', id, ... }`
   - `step-finish`: `{ type: 'step-finish', id, ... }`
   - `snapshot`: `{ type: 'snapshot', id, ... }`
   - `patch`: `{ type: 'patch', id, ... }`
   - `agent`: `{ type: 'agent', id, agentID, ... }`
   - `retry`: `{ type: 'retry', id, ... }`
   - `compaction`: `{ type: 'compaction', id, ... }`
   
   Use `.passthrough()` on each member to allow extra fields the SDK may add without breaking validation. This is critical for forward compatibility.

2. **MessageSchema** — `z.discriminatedUnion('role', [...])`:
   - `user`: `{ role: 'user', id, sessionID, ... }`
   - `assistant`: `{ role: 'assistant', id, sessionID, ... }`
   Both have `parts: z.array(PartSchema).optional()` and `time: z.object({ created: z.number(), completed: z.number().optional() })`

3. **SessionStatusSchema** — `z.discriminatedUnion('type', [...])`:
   - `completed`: `{ type: 'completed' }`
   - `running`: `{ type: 'running' }`
   - `error`: `{ type: 'error', error: z.string() }`
   - `interrupted`: `{ type: 'interrupted' }`

4. **SessionSchema** — `z.object()`:
   - `id: z.string()`, `parentID: z.string().optional()`, `title: z.string()`
   - `status: SessionStatusSchema`
   - `time: z.object({ created: z.number(), updated: z.number() })`
   Use `.passthrough()`.

5. **Helper functions** (exported):
   - `validateSessionList(data: unknown): Session[]` — parses array of sessions, returns typed array. On error, logs warning and returns data as-is (graceful degradation, don't crash the app).
   - `validateMessages(data: unknown): Array<{ info: Message; parts: Part[] }>` — parses message array with nested parts.
   - `validateSession(data: unknown): Session` — parses single session.
   - `parseSSEEvent(raw: string): { type: string; [key: string]: unknown }` — JSON.parse with basic shape check, returns typed result instead of `any`.

**Key design decisions:**
- Use `.passthrough()` everywhere — SDK may add new fields between minor versions. Strict schemas would break on new fields.
- Graceful degradation — validation failures log warnings but don't throw. The data still flows through. This prevents a validation schema bug from breaking the entire app.
- Server-only file — this file runs only on the server (imported by `sessions.ts`). No `.server.ts` suffix needed because it doesn't import native modules.
- Import types from `engine-types.ts` for return type annotations on helper functions.

**WARNING:** Do NOT use Zod 4's `z.coerce.*()` (with parentheses) — use `z.string()`, `z.number()` etc. directly. Zod 4 changed coercion syntax from Zod 3.
  </action>
  <verify>
```bash
# File exists with expected exports
grep -c "export" app/server/sdk-validators.ts
# Has discriminated union for Part
grep "discriminatedUnion" app/server/sdk-validators.ts
# Has passthrough for forward compat
grep "passthrough" app/server/sdk-validators.ts
# Typecheck passes
npm run typecheck
```
  </verify>
  <done>sdk-validators.ts exports Zod schemas for Part (11-member discriminated union), Message, Session, SessionStatus with graceful degradation and forward-compatible .passthrough().</done>
</task>

<task type="auto">
  <name>Task 2: Wire Zod validation into sessions.ts server functions</name>
  <files>app/server/sessions.ts</files>
  <action>
Update `app/server/sessions.ts` to validate SDK data through Zod schemas at return boundaries.

**Read `app/server/sessions.ts` first** — understand the current structure. Key points:
- Uses `createServerFn` from `@tanstack/react-start`
- Calls SDK client via `getClient()` and `unwrapSdkResult()`
- Has `JSON.parse(JSON.stringify(data))` workaround for TanStack Start's JsonValue constraint
- Exports functions: `listSessionsFn`, `createSessionFn`, `getSessionMessagesFn`, `getSessionStatusFn`, `deleteSessionFn`, `abortSessionFn`, `getSessionChildrenFn`

**Changes to make:**

1. Add import at top:
   ```ts
   import { validateSessionList, validateSession, validateMessages } from './sdk-validators'
   ```

2. In `listSessionsFn`: After `unwrapSdkResult()` and before `JSON.parse(JSON.stringify(...))`, insert Zod validation:
   ```ts
   const sessions = unwrapSdkResult(result)
   const validated = validateSessionList(sessions)
   return JSON.parse(JSON.stringify(validated))
   ```

3. In `createSessionFn`: Validate the returned session:
   ```ts
   const session = unwrapSdkResult(result)
   const validated = validateSession(session)
   return JSON.parse(JSON.stringify(validated))
   ```

4. In `getSessionMessagesFn`: Validate the messages array:
   ```ts
   const messages = unwrapSdkResult(result)
   const validated = validateMessages(messages)
   return JSON.parse(JSON.stringify(validated))
   ```

5. **DO NOT** change the `JSON.parse(JSON.stringify())` workaround — it's required for TanStack Start serialization. Zod validation goes BEFORE it (validate SDK data, then serialize for transport).

6. **DO NOT** change function signatures or return types — the validation is transparent. Same types in, same types out. If Zod validation fails, graceful degradation returns the data as-is.

7. For `getSessionStatusFn`, `deleteSessionFn`, `abortSessionFn`, `getSessionChildrenFn` — add validation where the return shape benefits from it (status and children responses). Skip validation on void-returning functions (delete, abort).

**Key constraint:** The `JSON.parse(JSON.stringify())` pattern MUST remain. This is the TanStack Start `unknown` → `JsonValue` serialization bridge documented in the false alarm registry (Plan 11-02).
  </action>
  <verify>
```bash
# Verify import exists
grep "sdk-validators" app/server/sessions.ts
# Verify validation calls exist
grep "validate" app/server/sessions.ts
# Typecheck passes
npm run typecheck
# Tests still pass
npm test 2>&1 | tail -5
```
  </verify>
  <done>Server functions validate SDK data at return boundaries via Zod schemas. Validation is graceful (warnings, no crashes). JSON.parse serialization bridge preserved. tsc --noEmit passes.</done>
</task>

</tasks>

<verification>
- `app/server/sdk-validators.ts` exists with Zod schemas for Part, Message, Session, SessionStatus
- `app/server/sessions.ts` imports and uses validation functions
- `npm run typecheck` passes with zero errors
- `npm test` passes (512 assertions baseline)
- Part schema uses `z.discriminatedUnion('type', [...])` with 11 members
- All schemas use `.passthrough()` for forward compatibility
</verification>

<success_criteria>
- SDK data flowing from server functions to hooks/components passes through Zod validation
- Validation is transparent — same types in, same types out
- A runtime shape mismatch logs a warning but doesn't crash the app
- tsc --noEmit and npm test both pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-sdk-type-realignment/11-03-SUMMARY.md`
</output>
