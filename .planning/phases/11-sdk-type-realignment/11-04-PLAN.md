---
phase: 11-sdk-type-realignment
plan: 04
type: execute
wave: 3
depends_on: ["11-03"]
files_modified:
  - app/hooks/useStreaming.ts
  - app/components/chat/ChatMessage.tsx
  - app/routes/chat.$sessionId.tsx
autonomous: true

must_haves:
  truths:
    - "useStreaming.ts SSE event parsing uses parseSSEEvent() from sdk-validators instead of raw JSON.parse with 'any' result"
    - "ChatMessage.tsx renders Part content using discriminated union narrowing on part.type — zero 'as any' casts on SDK types"
    - "chat.$sessionId.tsx passes SDK-typed messages to components with proper type annotations"
    - "tsc --noEmit passes with zero errors"
    - "npm test passes (512 assertion baseline maintained)"
  artifacts:
    - path: "app/hooks/useStreaming.ts"
      provides: "SSE streaming hook with SDK-typed state and validated event parsing"
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Chat message renderer with Part discriminated union narrowing"
    - path: "app/routes/chat.$sessionId.tsx"
      provides: "Chat route with SDK-typed message handling"
  key_links:
    - from: "app/hooks/useStreaming.ts"
      to: "app/server/sdk-validators.ts"
      via: "import { parseSSEEvent }"
      pattern: "parseSSEEvent"
    - from: "app/components/chat/ChatMessage.tsx"
      to: "app/shared/engine-types.ts"
      via: "import type { Part, TextPart, ToolPart }"
      pattern: "part\\.type === "
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/hooks/useStreaming.ts"
      via: "useStreaming() returns SDK-typed messages"
      pattern: "useStreaming"
---

<objective>
Migrate all SDK type consumers (useStreaming, ChatMessage, chat route) to use proper SDK discriminated union narrowing and validated event parsing, eliminating `as any` casts and untyped JSON.parse calls.

Purpose: After Plans 11-01 through 11-03 established contracts, governance, and Zod boundaries, this plan completes the chain by making consumers type-safe. SSE events get validated parsing, Part rendering uses discriminated union narrowing, and the entire data flow from SDK → server → SSE → hook → component is type-safe end-to-end.

Output: Updated `useStreaming.ts`, `ChatMessage.tsx`, `chat.$sessionId.tsx`
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-sdk-type-realignment/11-03-SUMMARY.md
@app/shared/engine-types.ts
@app/server/sdk-validators.ts
@app/hooks/useStreaming.ts
@app/components/chat/ChatMessage.tsx
@app/routes/chat.$sessionId.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useStreaming.ts and chat.$sessionId.tsx to SDK-typed patterns</name>
  <files>app/hooks/useStreaming.ts, app/routes/chat.$sessionId.tsx</files>
  <action>
**Read both files first** to understand current state before making changes.

### useStreaming.ts changes:

1. **Import parseSSEEvent from sdk-validators:**
   ```ts
   import { parseSSEEvent } from '../server/sdk-validators'
   ```
   Note: This import works because sdk-validators.ts doesn't import native modules — it's pure Zod logic, safe for client bundles. If Vite tree-shaking has issues, use dynamic import or inline the JSON.parse + basic shape check.

   **FALLBACK:** If importing from server/ causes Vite bundling issues (server modules leaking to client), create a minimal `app/shared/sse-parser.ts` with just the `parseSSEEvent` function (no Zod dependency — just typed JSON.parse wrapper). The key is replacing `any` with a typed return.

2. **Replace raw JSON.parse in SSE event loop:**
   Current pattern:
   ```ts
   const data = JSON.parse(line.slice(6))  // data is 'any'
   ```
   Replace with:
   ```ts
   const data = parseSSEEvent(line.slice(6))  // data is typed
   ```

3. **Type-narrow SSE event handling:**
   Current pattern accesses `data.message` and `data.part` without type guards. After parseSSEEvent returns a typed result, narrow on `data.type`:
   ```ts
   if (data.type === 'message.updated' && data.message) {
     const msg = data.message as Message  // SDK Message type from engine-types
     // ... existing state update logic using msg.id, etc.
   }
   ```

   The `as Message` cast here is acceptable because:
   - The SDK SSE relay sends actual SDK Message objects
   - The Zod validation in the server (Plan 11-03) already validated the shape
   - The SSE just serializes and deserializes the same validated data
   
   If you want to avoid even this cast, use the MessageSchema.safeParse() from sdk-validators. But the cast is pragmatic since validation already happened server-side.

4. **Update StreamingState type annotation:**
   The `messages: Message[]` type is already correct (Message is the SDK union type from engine-types.ts). Verify no local type definitions shadow the SDK type.

5. **Do NOT change the SSE ReadableStream logic** — the event loop, TextDecoder, line splitting are all correct. Only the JSON.parse and type narrowing need updating.

### chat.$sessionId.tsx changes:

1. **Read the file and identify SDK type usage:**
   - Loader data types (messages from `getSessionMessagesFn`)
   - How messages are passed to `<ChatMessage>` component
   - Any `as any` or `as unknown` casts

2. **Ensure loader return types use SDK types:**
   The loader should return `{ messages: Array<{ info: Message; parts: Part[] }> }` using SDK types from engine-types.ts (already imported).

3. **Ensure message props passed to ChatMessage are SDK-typed:**
   When mapping over messages to render `<ChatMessage>`, the `message` prop should be typed as `Message` (SDK type), not `any` or a local interface.

4. **Remove any `as any` casts on message/part data.** If casts exist because of type mismatches, fix the underlying type instead.

**Test after changes:**
```bash
npm run typecheck  # Must pass
```
  </action>
  <verify>
```bash
# No 'as any' on SDK types in useStreaming
grep -n "as any" app/hooks/useStreaming.ts | grep -v "// SDK" || echo "CLEAN"
# parseSSEEvent or typed parse in use
grep -c "parseSSEEvent\|parsedEvent" app/hooks/useStreaming.ts
# Typecheck passes
npm run typecheck
```
  </verify>
  <done>useStreaming.ts uses typed SSE event parsing (no raw JSON.parse to 'any'). chat.$sessionId.tsx passes SDK-typed messages to components. tsc --noEmit passes.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate ChatMessage.tsx to Part discriminated union narrowing + final verification</name>
  <files>app/components/chat/ChatMessage.tsx</files>
  <action>
**Read `app/components/chat/ChatMessage.tsx` first.** Understand current Part rendering pattern.

### ChatMessage.tsx changes:

1. **Update imports to include specific Part subtypes:**
   ```ts
   import type { Message, Part, TextPart, ToolPart, FilePart, ReasoningPart } from '../../shared/engine-types'
   ```
   Import only the Part subtypes actually used in rendering. Don't import all 11 — only those that have specific rendering.

2. **Replace any `as any` casts with discriminated union narrowing:**
   For each Part subtype rendered:
   ```tsx
   // ❌ Current (if using as any)
   const content = (part as any).content
   
   // ✅ Correct — narrowing on discriminant
   if (part.type === 'text') {
     // TypeScript now knows: part is TextPart
     return <p>{part.content}</p>
   }
   if (part.type === 'tool') {
     // TypeScript now knows: part is ToolPart
     return <ToolCallCard name={part.name} state={part.state} />
   }
   ```

3. **Handle Part rendering with a switch or if-chain:**
   Group Part types by rendering priority:
   - **Text parts** (`type === 'text'`): Render content as markdown (or plain text for now)
   - **Tool parts** (`type === 'tool'`): Render tool name, state, expandable input/output
   - **Reasoning parts** (`type === 'reasoning'`): Render in collapsible thinking section
   - **File parts** (`type === 'file'`): Render filename with link
   - **Step parts** (`type === 'step-start'`, `type === 'step-finish'`): Render as step markers
   - **Meta parts** (snapshot, patch, agent, retry, compaction): Render minimally or skip (these are internal SDK events, not user-facing content)
   - **Default/unknown**: Render nothing or a subtle "[unsupported part type]" indicator. Do NOT crash on unknown types — the SDK may add new Part types.

4. **Update message-level type handling:**
   `Message` is `UserMessage | AssistantMessage`. Both have `role` and `parts`. If the component needs to differentiate:
   ```tsx
   if (message.role === 'user') {
     // TypeScript narrows to UserMessage
   } else if (message.role === 'assistant') {
     // TypeScript narrows to AssistantMessage
   }
   ```

5. **Verify message property access matches SDK shapes:**
   - `message.id` ✓ (exists on both UserMessage and AssistantMessage)
   - `message.role` ✓ (the discriminant)
   - `message.parts` — check if this is `Part[]` or `Part[] | undefined` on the SDK type. If optional, guard with `(message.parts ?? []).map(...)`.
   - `message.time.created` — number (epoch ms), NOT Date. If displaying time, convert: `new Date(message.time.created)`

6. **Remove any `content` property access that bypasses parts:**
   Old Phase 1 code may have `message.content` (a flattened string). SDK Messages have `parts: Part[]` instead. Content is in `TextPart.content`. If ChatMessage.tsx has a `getMessageContent()` helper that reads `message.content`, update it to extract content from text parts:
   ```ts
   function getTextContent(message: Message): string {
     return (message.parts ?? [])
       .filter((p): p is TextPart => p.type === 'text')
       .map(p => p.content)
       .join('\n')
   }
   ```

### Final verification (do this LAST):

```bash
# Full typecheck — must pass with zero errors
npm run typecheck

# Full test suite — must maintain 512 assertion baseline
npm test

# Grep for any remaining 'as any' on SDK types across all app/ files
grep -rn "as any" app/ --include="*.ts" --include="*.tsx" | grep -v node_modules | grep -v ".gen." || echo "ALL CLEAN"
```

If typecheck fails, fix the errors. Common issues:
- Missing Part subtype in discriminated union check → add the case
- `message.parts` being optional → add `?? []` guard
- `time.created` being number not Date → don't wrap in Date constructor at the type level, convert at render time
  </action>
  <verify>
```bash
# No 'as any' casts on SDK types
grep -c "as any" app/components/chat/ChatMessage.tsx && echo "HAS CASTS" || echo "CLEAN"
# Part narrowing exists
grep -c "part.type ===" app/components/chat/ChatMessage.tsx
# Full typecheck
npm run typecheck
# Full test suite
npm test 2>&1 | tail -5
```
  </verify>
  <done>ChatMessage.tsx renders Parts using discriminated union narrowing. Zero 'as any' casts on SDK types. tsc --noEmit passes. npm test maintains 512 assertion baseline. End-to-end type chain complete: SDK → server (Zod validated) → SSE (typed parsing) → hook (SDK-typed state) → component (Part narrowing).</done>
</task>

</tasks>

<verification>
- `app/hooks/useStreaming.ts` uses typed SSE event parsing (not raw `JSON.parse → any`)
- `app/components/chat/ChatMessage.tsx` has Part discriminated union narrowing (switch/if-chain on `part.type`)
- `app/routes/chat.$sessionId.tsx` passes SDK-typed data to components
- Zero `as any` casts on SDK types across all 3 files
- `npm run typecheck` passes with zero errors
- `npm test` passes with 512 assertion baseline
</verification>

<success_criteria>
- Complete end-to-end type chain: SDK → Zod validation → server function → SSE → hook state → component rendering
- All discriminated unions properly narrowed (Part by type, Message by role, SessionStatus by type)
- No unsafe casts, no hand-rolled types, no untyped JSON.parse on SDK data
- Phase 11 success criteria fully met: all 5 items from ROADMAP.md
</success_criteria>

<output>
After completion, create `.planning/phases/11-sdk-type-realignment/11-04-SUMMARY.md`
</output>
