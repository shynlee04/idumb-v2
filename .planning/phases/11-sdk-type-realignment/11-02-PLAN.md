---
phase: 11-sdk-type-realignment
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - app/hooks/useStreaming.ts
  - app/components/chat/ChatMessage.tsx
  - app/routes/chat.$sessionId.tsx
autonomous: true

must_haves:
  truths:
    - "ChatMessage renders SDK-shaped messages (UserMessage | AssistantMessage) with correct field access"
    - "useStreaming constructs SDK-shaped Message objects from SSE events"
    - "Chat page handles SDK Message union type correctly"
    - "Part type narrowing uses SDK discriminated union (TextPart, ToolPart, etc.)"
    - "tsc --noEmit passes with zero errors"
    - "npm test passes all 512 assertions"
  artifacts:
    - path: "app/hooks/useStreaming.ts"
      provides: "SSE streaming hook producing SDK-shaped Message objects"
      contains: "time:"
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Message renderer handling UserMessage | AssistantMessage"
      contains: "time.created"
    - path: "app/routes/chat.$sessionId.tsx"
      provides: "Chat page using SDK Message type"
      contains: "Message"
  key_links:
    - from: "app/hooks/useStreaming.ts"
      to: "app/shared/engine-types.ts"
      via: "import type"
      pattern: "import type.*Message"
    - from: "app/components/chat/ChatMessage.tsx"
      to: "app/shared/engine-types.ts"
      via: "import type"
      pattern: "import type.*Message.*Part"
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/hooks/useStreaming.ts"
      via: "hook call"
      pattern: "useStreaming"
---

<objective>
Update all frontend consumers (hooks, components, routes) to handle SDK type shapes correctly — specifically the SessionStatus object union, Message discriminated union, Part discriminated union, and number timestamps.

Purpose: After Plan 01 establishes the type foundation (re-exports from SDK), this plan ensures all consumers actually work with the correct SDK shapes. The data was ALWAYS SDK-shaped at runtime (sessions.ts passes it through), but the TypeScript annotations and field access patterns assumed the old hand-rolled shapes.

Output: All consumer files updated to access SDK fields correctly (`time.created` not `createdAt`, `status.type` not string comparison, etc.)
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-sdk-type-realignment/11-RESEARCH.md
@.planning/phases/11-sdk-type-realignment/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update useStreaming.ts — construct SDK-shaped Message objects from SSE</name>
  <files>app/hooks/useStreaming.ts</files>
  <action>
  `useStreaming.ts` is the MOST impacted consumer. It constructs Message objects locally from SSE stream data and accumulates parts. Currently it builds objects matching the old hand-rolled shape. Update to construct SDK-compatible shapes.

  **Import changes:**
  Replace any imports of `Message`, `Part` from engine-types with SDK types:
  ```ts
  import type { Message, UserMessage, AssistantMessage, Part, TextPart } from '../shared/engine-types'
  ```

  **Key shape changes to apply:**

  1. **Message construction:** When building a user message from SSE input:
     - OLD: `{ id: '...', role: 'user', parts: [...], createdAt: new Date().toISOString() }`
     - NEW: `{ id: '...', sessionID: sessionId, role: 'user' as const, parts: [...], time: { created: Date.now() / 1000, completed: Date.now() / 1000 }, system: false }`

  2. **Message construction:** When building an assistant message from SSE response:
     - OLD: `{ id: '...', role: 'assistant', parts: [...], createdAt: new Date().toISOString() }`
     - NEW: `{ id: '...', sessionID: sessionId, role: 'assistant' as const, parts: [...], time: { created: Date.now() / 1000, completed: 0 }, cost: { input: 0, output: 0, total: 0 }, tokens: { input: 0, output: 0 }, modelID: '', providerID: '' }`

  3. **Part construction:** When building TextPart from SSE text:
     - OLD: `{ type: 'text', text: content }` or `{ type: 'text', content: content }`
     - NEW: `{ id: crypto.randomUUID(), sessionID: sessionId, messageID: msgId, type: 'text' as const, content: text }` — must include id, sessionID, messageID fields
     - If `crypto.randomUUID` is not available, use a simple `Date.now().toString(36)` fallback

  4. **Part accumulation:** When updating parts from SSE events, match the SDK Part union shape. The part `type` field is the discriminant — use type narrowing: `if (part.type === 'text')` still works since SDK TextPart has `type: "text"`.

  **IMPORTANT:** The SSE stream may not provide all SDK fields (cost, tokens, modelID). Use sensible defaults (0 for numbers, '' for strings). These are display-time values — the real values come from `getSessionMessagesFn()` which returns actual SDK data.

  **Preserve existing SSE connection logic** — only change the Message/Part object shapes that are constructed and returned to consumers.
  </action>
  <verify>
  Run `npm run typecheck` — must pass with zero errors.
  Verify SDK field access: `grep "time:" app/hooks/useStreaming.ts` returns matches.
  Verify no `createdAt` string construction: `grep -c "createdAt" app/hooks/useStreaming.ts` — should be 0 or only in comments.
  </verify>
  <done>
  useStreaming.ts constructs Message objects matching SDK shape (UserMessage | AssistantMessage).
  Parts are constructed with SDK TextPart shape (id, sessionID, messageID, type, content).
  tsc --noEmit passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ChatMessage.tsx and chat.$sessionId.tsx — handle SDK Message/Part types</name>
  <files>app/components/chat/ChatMessage.tsx, app/routes/chat.$sessionId.tsx</files>
  <action>
  **Part A — Update ChatMessage.tsx:**

  This component renders individual messages. Update it to handle SDK `Message` type (which is `UserMessage | AssistantMessage`).

  **Import changes:**
  ```ts
  import type { Message, Part, TextPart } from '../../shared/engine-types'
  ```

  **Field access changes:**
  1. **Role access:** `msg.role` still works — both UserMessage and AssistantMessage have `role` field. No change needed.

  2. **Timestamp access:** If the component displays timestamps:
     - OLD: `msg.createdAt` (string, ISO format)
     - NEW: `msg.time.created` (number, Unix seconds) — format with `new Date(msg.time.created * 1000).toLocaleString()`
     - Note: check if timestamp is displayed anywhere in the component. If not, no change needed.

  3. **Part rendering:** The component already checks `part.type === 'text'` which works with SDK TextPart. But field access needs updating:
     - OLD: `(part as any).text` or `part.text` or `part.content`
     - NEW: After type narrowing `if (part.type === 'text')`, access `(part as TextPart).content`
     - For other part types, add type guards as needed

  4. **Content fallback:** The component has a fallback for `msg.content` (string) vs `msg.parts` (array). SDK messages ALWAYS have `parts` array. Keep the fallback but prioritize `parts`.

  **Part B — Update chat.$sessionId.tsx:**

  This route component receives messages and passes them to ChatMessage. Update type annotations:

  1. **Message array type:** If the component casts or annotates messages, ensure it uses `Message[]` (which is now `(UserMessage | AssistantMessage)[]` via SDK re-export).

  2. **Message from SSE vs API:** The component receives messages from two sources:
     - `getSessionMessagesFn()` — returns SDK data (now typed as `Message[]` from Plan 01)
     - `useStreaming()` — returns locally constructed messages (now SDK-shaped from Task 1)
     Both should be `Message[]` compatible after Plan 01 + Task 1.

  3. **Any `as Session` or `as Message` casts** — verify they still work with SDK types. Remove unnecessary casts if the types now flow correctly.

  **DO NOT change the component's visual rendering or layout** — only update type annotations and field access patterns.
  </action>
  <verify>
  Run `npm run typecheck` — must pass with zero errors.
  Run `npm test` — must pass all 512 assertions.
  Verify no hand-rolled type references: `grep -c "createdAt" app/components/chat/ChatMessage.tsx` — 0 or only in comments.
  Verify SDK types imported: `grep "import type" app/components/chat/ChatMessage.tsx`
  </verify>
  <done>
  ChatMessage.tsx handles SDK Message union type correctly.
  Part type narrowing uses SDK discriminated union.
  chat.$sessionId.tsx uses SDK Message[] type.
  tsc --noEmit passes. npm test passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` — zero errors
2. `npm test` — 512 assertions, 10 suites pass
3. No hand-rolled type shapes constructed anywhere in consumer files
4. All Message field access uses SDK field names (time.created, not createdAt)
5. All Part type narrowing uses SDK discriminant (TextPart.content, not Part.text)
</verification>

<success_criteria>
- useStreaming.ts constructs SDK-shaped Message and Part objects
- ChatMessage.tsx renders SDK Message union type correctly
- chat.$sessionId.tsx handles SDK types at route level
- No references to old field names (createdAt as string, status as string)
- TypeScript compilation passes
- Test suite passes unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/11-sdk-type-realignment/11-02-SUMMARY.md`
</output>
