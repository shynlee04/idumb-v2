---
phase: 11-sdk-type-realignment
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - app/components/chat/ChatMessage.tsx
  - app/hooks/useStreaming.ts
  - app/routes/chat.$sessionId.tsx
autonomous: true

must_haves:
  truths:
    - "ChatMessage.tsx uses SDK Part discriminated union — no custom MessagePart interface"
    - "useStreaming.ts uses SDK Event discriminated union — no custom StreamEvent interface"
    - "extractTextFromEvent in chat.$sessionId.tsx uses SDK event type narrowing"
    - "tsc --noEmit passes with ZERO errors across the entire app"
  artifacts:
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Chat message renderer using SDK Part types"
      contains: "Part"
    - path: "app/hooks/useStreaming.ts"
      provides: "SSE streaming hook using SDK Event types"
      contains: "Event"
    - path: "app/routes/chat.$sessionId.tsx"
      provides: "Chat route using SDK event type narrowing"
      contains: "extractTextFromEvent"
  key_links:
    - from: "app/components/chat/ChatMessage.tsx"
      to: "app/shared/engine-types.ts"
      via: "import Part type"
      pattern: "import.*Part.*from.*engine-types"
    - from: "app/hooks/useStreaming.ts"
      to: "app/shared/engine-types.ts"
      via: "import Event type"
      pattern: "import.*Event.*from.*engine-types"
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/hooks/useStreaming.ts"
      via: "useStreaming hook return type"
      pattern: "useStreaming"
---

<objective>
Update all chat-facing components and hooks to use SDK Part/Event discriminated unions instead of hand-rolled interfaces.

Purpose: ChatMessage.tsx has a custom `MessagePart {type: string, [key]: unknown}` and useStreaming.ts has a custom `StreamEvent {type: string, data: Record}` — both are loose typed. The SDK provides proper discriminated unions (Part with 12 variants, Event with 30+ variants) enabling exhaustive type checking. This eliminates the `[key: string]: unknown` escape hatches.

Output: All chat components use SDK types, `tsc --noEmit` passes with zero errors.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-sdk-type-realignment/11-RESEARCH.md
@.planning/phases/11-sdk-type-realignment/11-01-SUMMARY.md

Source files to read before editing:
@app/components/chat/ChatMessage.tsx
@app/hooks/useStreaming.ts
@app/routes/chat.$sessionId.tsx

SDK type definitions (read for reference):
@node_modules/@opencode-ai/sdk/dist/gen/types.gen.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ChatMessage.tsx to use SDK Part discriminated union</name>
  <files>app/components/chat/ChatMessage.tsx</files>
  <action>
Replace the hand-rolled `MessagePart` and `ChatMessageData` interfaces with SDK types:

**DELETE these interfaces:**
```typescript
export interface MessagePart {
  type: string
  text?: string
  toolName?: string
  args?: Record<string, unknown>
  result?: unknown
  [key: string]: unknown
}

export interface ChatMessageData {
  role: string
  content?: string
  parts?: MessagePart[]
}
```

**REPLACE with SDK imports from engine-types.ts:**
```typescript
import type { Part, TextPart, ToolPart, Message } from '@/shared/engine-types'
```

**Update `ChatMessageData`** — The SDK `Message` is `UserMessage | AssistantMessage`. For the chat component, we need a simpler props type:
```typescript
export interface ChatMessageData {
  role: 'user' | 'assistant'
  content?: string
  parts?: Part[]
}
```

**Update `PartRenderer`** — Replace the loose switch on `part.type` (string) with proper SDK type narrowing:
- `case "text":` → access `(part as TextPart).text` — SDK TextPart has `text: string`
- `case "tool":` → access `(part as ToolPart).tool` — SDK ToolPart has `tool: {name, args, output, ...}`. The old `part.toolName` becomes `part.tool.name`, `part.args` becomes `part.tool.args`, `part.result` becomes `part.tool.output`
- `case "reasoning":` → new case — show reasoning text with a subtle "Thinking" label
- `case "step-start":` / `case "step-finish":` → new cases — show step boundaries
- `default:` → keep JSON fallback for unhandled part types

**CRITICAL SDK ToolPart shape:**
```typescript
type ToolPart = {
  type: "tool"
  tool: {
    name: string
    args: Record<string, unknown>
    output?: unknown
    state: "pending" | "running" | "completed" | "error"
  }
}
```
This is different from our old `{toolName, args, result}` shape. Update the PartRenderer accordingly.

**Type guards approach:** Use `part.type` narrowing since Part is a discriminated union on `type`. TypeScript will narrow automatically:
```typescript
function PartRenderer({ part }: { part: Part }) {
  switch (part.type) {
    case "text": return part.text ? <Markdown>{part.text}</Markdown> : null
    case "tool": return <ToolPartView tool={part.tool} state={part.tool.state} />
    case "reasoning": return <ReasoningView text={part.text} />
    default: return <pre>{JSON.stringify(part, null, 2)}</pre>
  }
}
```
  </action>
  <verify>
Run: `npx tsc --noEmit 2>&1 | grep ChatMessage`
Expect: Zero errors in ChatMessage.tsx.
Verify: `grep "MessagePart" app/components/chat/ChatMessage.tsx` returns 0 matches (old interface deleted).
Verify: `grep "from.*engine-types" app/components/chat/ChatMessage.tsx` returns 1 match (SDK import present).
  </verify>
  <done>ChatMessage.tsx uses SDK Part discriminated union. No custom MessagePart interface. PartRenderer handles text, tool, reasoning, step-start, step-finish with proper type narrowing. Unknown parts fall back to JSON display.</done>
</task>

<task type="auto">
  <name>Task 2: Update useStreaming.ts and chat route to use SDK Event types</name>
  <files>app/hooks/useStreaming.ts, app/routes/chat.$sessionId.tsx</files>
  <action>
**app/hooks/useStreaming.ts:**

Replace the hand-rolled `StreamEvent` interface:
```typescript
// DELETE this:
export interface StreamEvent {
  type: string
  data: Record<string, unknown>
  timestamp: number
}
```

The SSE stream from the server sends events matching the SDK Event union. However, the SSE parsing layer adds a timestamp. Create a thin wrapper:

```typescript
import type { Event } from '@/shared/engine-types'

/** SSE event with client-side timestamp */
export interface StreamEvent {
  event: Event      // The SDK event payload
  timestamp: number // Client-side receive time
}
```

Update the SSE parsing in `sendPrompt`:
- When parsing `data:` lines, the JSON payload IS the SDK Event shape
- Construct `StreamEvent` as `{ event: parsedData as Event, timestamp: Date.now() }`
- The `type` field comes from the SSE `event:` line but is also inside the Event object

Update `StreamingState.events` to use the new `StreamEvent` type.

**app/routes/chat.$sessionId.tsx:**

Update `extractTextFromEvent(event: StreamEvent)`:
- Old code: `event.data.text` with loose `Record<string, unknown>` access
- New code: Use the SDK event discriminated union. Check `event.event.type`:
  - `"message.part.updated"` → check if `event.event.properties.part.type === "text"` → extract `event.event.properties.part.text`
  - Other event types → return null
- Use proper type narrowing on the Event union

The streaming event flow is: SSE sends `event: message.part.updated` + `data: {type: "message.part.updated", properties: {part: TextPart, delta: "new text"}}`. The `delta` field contains incremental text. Use `event.event.properties.delta` for streaming display.

Also check that `useStreaming` import in chat route matches the updated type.

**IMPORTANT:** The SSE server route (`app/routes/api/sessions.$id.prompt.ts`) serializes SDK events as JSON. The shapes already match the SDK Event union — no server-side changes needed. We're just properly typing what the client receives.
  </action>
  <verify>
Run: `npx tsc --noEmit 2>&1`
Expect: ZERO errors across the entire codebase. This is the final plan — everything must compile.
Verify: `grep "Record<string, unknown>" app/hooks/useStreaming.ts` returns 0 matches.
Verify: `grep "type: string" app/hooks/useStreaming.ts` returns 0 matches (no loose string typing).
Run full check: `npx tsc --noEmit && echo "TYPE CHECK PASSED"`
  </verify>
  <done>useStreaming.ts uses SDK Event discriminated union. extractTextFromEvent uses proper type narrowing. tsc --noEmit passes with zero errors across the entire app. Phase 11 type realignment complete.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` — ZERO errors (this is the final gate for Phase 11)
2. `grep -r "MessagePart" app/` — returns 0 matches (hand-rolled type deleted)
3. `grep -r "interface StreamEvent" app/hooks/useStreaming.ts` — no standalone `{type: string, data: Record}` shape
4. `grep -r "from '@opencode-ai/sdk'" app/shared/engine-types.ts` — SDK re-exports confirmed
5. No hand-rolled Part, Event, Session, Message, or SessionStatus types anywhere in app/
</verification>

<success_criteria>
- ChatMessage.tsx renders parts using SDK Part discriminated union with proper type narrowing
- useStreaming.ts wraps SDK Event in thin StreamEvent with client timestamp
- extractTextFromEvent uses SDK event type narrowing (not loose property access)
- `tsc --noEmit` passes with ZERO errors across the entire codebase
- Zero instances of hand-rolled SDK types remain in app/
</success_criteria>

<output>
After completion, create `.planning/phases/11-sdk-type-realignment/11-02-SUMMARY.md`
</output>
