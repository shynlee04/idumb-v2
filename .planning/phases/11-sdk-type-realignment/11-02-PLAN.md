---
phase: 11-sdk-type-realignment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - AGENTS.md
autonomous: true

must_haves:
  truths:
    - "AGENTS.md contains SDK type governance rules with taxonomy (SDK = law, app = internal only)"
    - "Banned patterns section lists concrete anti-patterns with code examples"
    - "False alarm registry table catalogues expected tsc warnings per downstream phase"
  artifacts:
    - path: "AGENTS.md"
      provides: "SDK Type Governance section + false alarm registry"
      contains: "SDK Type Governance"
  key_links:
    - from: "AGENTS.md type governance"
      to: "executor agents (templates.ts)"
      via: "agent contract enforcement"
      pattern: "SDK.*law|app.*internal"
---

<objective>
Add an SDK Type Governance section to AGENTS.md that establishes binding rules for how executors (human or AI) handle SDK types vs app types, plus a false alarm registry documenting expected tsc warnings that downstream phases will encounter.

Purpose: Without governance rules, future executors will hand-roll types that duplicate SDK shapes, use `as any` on SDK data, or create wrapper types that drift from the SDK. The false alarm registry prevents panic when downstream phases see known tsc warnings.

Output: Updated `AGENTS.md` with new SDK Type Governance section
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-sdk-type-realignment/11-RESEARCH.md
@AGENTS.md
@app/shared/engine-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SDK Type Governance rules to AGENTS.md</name>
  <files>AGENTS.md</files>
  <action>
Add a new top-level section to `AGENTS.md` titled `## SDK Type Governance` placed AFTER the "Code Style" section and BEFORE the "Development Commands" section. This section establishes binding rules for the entire project.

Include these subsections:

### Type Taxonomy
Define the two-tier type system:
- **SDK types** (source of truth = `@opencode-ai/sdk`) — Session, Message, Part, SessionStatus, and all Part subtypes. These are LAW. Never redefine, never approximate, never hand-roll.
- **App types** (source of truth = `app/shared/*.ts`) — EngineStatus, ProviderInfo, AgentInfo, DashboardConfig, WorkspaceConfig, IDE layout types. These are INTERNAL. Can be freely modified.

Rule: `engine-types.ts` re-exports SDK types via `import type / export type` (type-only, no runtime). Consumers import from `engine-types.ts` or `ide-types.ts`, NEVER directly from `@opencode-ai/sdk`.

### Import Path Rules
```
✅ import type { Message, Part } from '../shared/engine-types'
✅ import type { Session } from '../shared/ide-types'
❌ import { Message } from '@opencode-ai/sdk'  // Direct SDK import in app/
❌ import type { Message } from '@opencode-ai/sdk'  // Even type-only direct
```

Reason: Centralizing through engine-types.ts creates a single point where SDK upgrades are handled. If the SDK changes a type name, only engine-types.ts needs updating.

### Banned Patterns (with examples)

1. **`as any` on SDK types** — Never cast SDK data to `any`. Use discriminated union narrowing instead.
   ```ts
   // ❌ BANNED
   const content = (part as any).content
   // ✅ CORRECT
   if (part.type === 'text') { const content = part.content }
   ```

2. **Hand-rolling SDK shapes** — Never create an interface that duplicates an SDK type.
   ```ts
   // ❌ BANNED — duplicates SDK Session
   interface ChatSession { id: string; title: string; ... }
   // ✅ CORRECT — use SDK type directly
   import type { Session } from '../shared/engine-types'
   ```

3. **Wrapper types that shadow SDK types** — Response wrapper types (SessionListResponse, etc.) are acceptable only when they ADD information not in the SDK type. They must reference SDK types, not redefine fields.
   ```ts
   // ❌ BANNED — redefines Session fields
   interface SessionListResponse { sessions: Array<{ id: string; title: string }> }
   // ✅ CORRECT — references SDK Session
   interface SessionListResponse { sessions: Session[] }
   ```

4. **Untyped JSON.parse on SDK data** — SSE events carrying SDK data must be validated at the boundary, not left as `any` after JSON.parse.
   ```ts
   // ❌ BANNED
   const data = JSON.parse(line.slice(6))  // data is 'any'
   // ✅ CORRECT (after Plan 11-03)
   const data = parseSSEEvent(line.slice(6))  // returns typed union
   ```

5. **Optional chaining to hide type uncertainty** — If you need `msg?.parts?.map(...)`, the types are wrong. Fix the types, don't add `?.`.

### SDK Version Contract
Current: `@opencode-ai/sdk@^1.1.53`. When upgrading:
1. Read the SDK changelog for type changes
2. Update `11-CONTRACTS.md` with new shapes
3. Verify `tsc --noEmit` passes
4. Update Zod schemas in `sdk-validators.ts` if shapes changed
  </action>
  <verify>
`AGENTS.md` contains `## SDK Type Governance` section with subsections: Type Taxonomy, Import Path Rules, Banned Patterns (5 patterns with code examples), SDK Version Contract.
  </verify>
  <done>AGENTS.md establishes binding SDK type rules that prevent type drift, hand-rolling, and unsafe casts in all future work.</done>
</task>

<task type="auto">
  <name>Task 2: Add false alarm registry to AGENTS.md</name>
  <files>AGENTS.md</files>
  <action>
Add a `### Known Type Alarms (False Alarm Registry)` subsection within the SDK Type Governance section, AFTER the SDK Version Contract subsection.

This table documents expected tsc warnings/errors that downstream phases will encounter due to SDK type shapes, so executors don't panic or create workarounds.

Populate by analyzing:
1. Read `app/server/sessions.ts` — note the `JSON.parse(JSON.stringify())` workaround for TanStack Start JsonValue serialization. This is a KNOWN issue, not a bug to fix.
2. Read SDK types — `unknown` in index signatures will conflict with TanStack Start's `JsonValue` constraint.
3. Read `app/hooks/useStreaming.ts` — SSE data from `JSON.parse()` has type `any`, which becomes a warning if strict lint rules are added.

Format:

```markdown
### Known Type Alarms (False Alarm Registry)

Expected type issues that are NOT bugs — they have documented workarounds.

| Alarm | Affected Files | Phase | Workaround | Status |
|-------|---------------|-------|------------|--------|
| `Type 'unknown' is not assignable to type 'JsonValue'` | sessions.ts | 7+ | JSON.parse(JSON.stringify(data)) serialization bridge | Active — required by TanStack Start server function return constraint |
| `Parameter 'data' implicitly has an 'any' type` | useStreaming.ts SSE parsing | 11-04 | Zod validation at parse boundary (sdk-validators.ts) | Resolving in 11-03/11-04 |
| `Property 'content' does not exist on type 'Part'` | ChatMessage.tsx | 11-04 | Narrow on `part.type === 'text'` before accessing `.content` | Resolving in 11-04 |
| SDK Part union has 11 members — exhaustive switch is verbose | Any Part renderer | 7+ | Group by category: text parts, tool parts, meta parts. Handle unknown types with fallback. | Ongoing — acceptable |
```

Also add a note:
```
**Protocol:** When encountering a tsc error on SDK types:
1. Check this table first — it may be a known alarm
2. If known: apply documented workaround, do NOT create a new type
3. If unknown: add to this table with workaround, then fix
4. NEVER suppress with `@ts-ignore` or `as any`
```
  </action>
  <verify>
`AGENTS.md` contains "Known Type Alarms (False Alarm Registry)" subsection with a table of at least 4 known alarms. Each alarm has affected files, phase, workaround, and status. Protocol note is present.
  </verify>
  <done>False alarm registry prevents executor panic on known SDK type issues and establishes a protocol for handling new type alarms.</done>
</task>

</tasks>

<verification>
- `AGENTS.md` has new "SDK Type Governance" section
- 5 banned patterns documented with code examples
- Type taxonomy clearly separates SDK types from app types
- False alarm registry has 4+ entries with workarounds
- `npm run typecheck` still passes (AGENTS.md edits don't affect types, but verify nothing was broken by git operations)
</verification>

<success_criteria>
- Any executor reading AGENTS.md can determine: (1) which types come from SDK, (2) what patterns are banned, (3) which tsc warnings are expected, (4) how to handle SDK upgrades
</success_criteria>

<output>
After completion, create `.planning/phases/11-sdk-type-realignment/11-02-SUMMARY.md`
</output>
