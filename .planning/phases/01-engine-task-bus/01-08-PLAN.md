---
phase: 01-engine-task-bus
plan: 08
type: execute
wave: 1
depends_on: ["01-07"]
files_modified:
  - src/dashboard/frontend/src/pages/ChatPage.tsx
  - src/dashboard/frontend/src/components/chat/MessageList.tsx
  - src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx
  - src/index.ts
  - src/tools/tasks.ts
  - .idumb/brain/graph.json
  - .idumb/brain/state.json
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Clicking a chat session loads message history in the viewport"
    - "Active tasks render in task sidebar and detail panel without crashing"
    - "Existing corrupt agent-object data in graph.json/state.json is normalized to strings"
  artifacts:
    - path: "src/dashboard/frontend/src/pages/ChatPage.tsx"
      provides: "Flex column layout for chat content + loading/error states from useMessages"
      contains: "flex flex-col"
    - path: "src/dashboard/frontend/src/components/chat/MessageList.tsx"
      provides: "Flex-1 scroll area instead of h-full"
      contains: "min-h-0 flex-1"
    - path: "src/index.ts"
      provides: "Agent normalization in chat.params hook"
      contains: "typeof agent"
    - path: "src/tools/tasks.ts"
      provides: "Normalized getAgent() return value"
      contains: "typeof"
    - path: "src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx"
      provides: "Safe render of assignedTo field"
      contains: "typeof task.assignedTo"
  key_links:
    - from: "src/index.ts (chat.params)"
      to: "lib/persistence.ts (setCapturedAgent)"
      via: "normalized string passed to setCapturedAgent"
      pattern: "setCapturedAgent.*agentName"
    - from: "src/tools/tasks.ts (getAgent)"
      to: "TaskNode.assignedTo"
      via: "normalized string returned by getAgent"
      pattern: "typeof.*string"
---

<objective>
Close 2 UAT gaps from Phase 1 testing:
1. Chat viewport empty — messages not rendering (UAT Test 5)
2. React error #31 on active tasks — agent object rendered as React child (UAT Test 7)

Purpose: Unblock the 2 skipped UAT tests (6 and 8) and achieve full Phase 1 acceptance.
Output: Patched files + migrated data files. Both gaps verified closed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-engine-task-bus/01-UAT.md
@.planning/phases/01-engine-task-bus/01-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix chat viewport layout and error handling (Gap 1)</name>
  <files>
    src/dashboard/frontend/src/pages/ChatPage.tsx
    src/dashboard/frontend/src/components/chat/MessageList.tsx
  </files>
  <action>
  Three changes to fix the empty chat viewport:

  1. **ChatPage.tsx line 122** — The content wrapper div currently reads:
     ```
     <div className="min-h-0 flex-1">
     ```
     Change to:
     ```
     <div className="min-h-0 flex-1 flex flex-col">
     ```
     This makes the wrapper a flex column so its children (MessageList and DelegationThread) can use flex-1 sizing instead of collapsing.

  2. **MessageList.tsx line 43** — The ScrollArea currently reads:
     ```
     <ScrollArea className="h-full px-4 py-4">
     ```
     Change to:
     ```
     <ScrollArea className="min-h-0 flex-1 px-4 py-4">
     ```
     Inside a flex column parent, `h-full` on a flex child causes 100% of parent height consumption leaving no room for siblings. `min-h-0 flex-1` allows the scroll area to fill available space while respecting the DelegationThread below it.

  3. **ChatPage.tsx line 28** — The useMessages destructuring currently reads:
     ```
     const { data: messages = [], refetch: refetchMessages } = useMessages(sessionId)
     ```
     Change to:
     ```
     const { data: messages = [], refetch: refetchMessages, isLoading: messagesLoading, isError: messagesError } = useMessages(sessionId)
     ```
     Then between line 122 (the content wrapper div) and the MessageList component, add conditional rendering:
     ```tsx
     {messagesError ? (
       <div className="flex flex-1 items-center justify-center">
         <p className="text-sm text-red-300">Failed to load messages. Check engine connection.</p>
       </div>
     ) : messagesLoading ? (
       <div className="flex flex-1 items-center justify-center">
         <p className="text-sm text-muted-foreground">Loading messages...</p>
       </div>
     ) : (
       <MessageList
         messages={messages}
         streamingParts={streaming.parts}
         isStreaming={streaming.isStreaming}
       />
     )}
     ```
     This replaces the unconditional `<MessageList>` render so users see feedback instead of a silent empty area when the API fails.
  </action>
  <verify>
  1. `cd /Users/apple/Documents/coding-projects/idumb/v2/src/dashboard/frontend && npx tsc --noEmit` — zero errors
  2. Grep confirms: `grep "flex flex-col" src/dashboard/frontend/src/pages/ChatPage.tsx` matches line 122
  3. Grep confirms: `grep "min-h-0 flex-1" src/dashboard/frontend/src/components/chat/MessageList.tsx` matches ScrollArea
  4. Grep confirms: `grep "messagesError" src/dashboard/frontend/src/pages/ChatPage.tsx` matches error handling
  </verify>
  <done>
  Chat viewport renders messages in a properly sized scroll area. Loading and error states are visible. DelegationThread sits below MessageList without overflow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Normalize agent identity to string everywhere (Gap 2)</name>
  <files>
    src/index.ts
    src/tools/tasks.ts
    src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx
  </files>
  <action>
  Three changes to prevent agent objects from propagating through the system:

  1. **src/index.ts lines 120-124** — In the `chat.params` hook, the agent value comes from `input.agent` which the OpenCode SDK passes as a full object at runtime (with keys: name, mode, permission, options, native, prompt, description, color) despite its `string` type declaration. Normalize before storing:

     Current code:
     ```typescript
     const { sessionID, agent } = input
     verifyLog.info("HOOK FIRED: chat.params", { sessionID, agent })

     if (agent) {
       stateManager.setCapturedAgent(sessionID, agent)
     ```

     Change to:
     ```typescript
     const { sessionID, agent } = input
     verifyLog.info("HOOK FIRED: chat.params", { sessionID, agent })

     if (agent) {
       // OpenCode SDK passes agent as full object at runtime despite string type.
       // Normalize to string name to prevent object propagation into TaskNodes.
       const agentName: string =
         typeof agent === "object" && agent !== null
           ? ((agent as Record<string, unknown>).name as string) ?? String(agent)
           : String(agent)
       stateManager.setCapturedAgent(sessionID, agentName)
       log.info(`Agent captured: ${agentName}`, { sessionID })
     ```
     Also update the subsequent `log.info` and the auto-assign blocks (lines 128-146) to use `agentName` instead of `agent`:
     - Line 130: `activeTask.assignee = agentName`
     - Line 133: `log.info(\`Auto-assigned ${agentName} to task...\``
     - Line 142: `activeNode.assignedTo = agentName`
     - Line 144: `log.info(\`Auto-assigned ${agentName} to TaskNode...\``

  2. **src/tools/tasks.ts lines 26-28** — The `getAgent()` helper reads from `getCapturedAgent()` which may return a previously stored object from corrupt state. Add normalization:

     Current code:
     ```typescript
     function getAgent(sessionID: string): string {
       return stateManager.getCapturedAgent(sessionID) ?? "idumb-executor"
     }
     ```

     Change to:
     ```typescript
     function getAgent(sessionID: string): string {
       const raw = stateManager.getCapturedAgent(sessionID)
       if (!raw) return "idumb-executor"
       // Defensive: handle legacy object values from pre-normalization state
       if (typeof raw === "object" && raw !== null) {
         return ((raw as Record<string, unknown>).name as string) ?? "idumb-executor"
       }
       return String(raw)
     }
     ```
     Note: `getCapturedAgent` is typed as `string | null` but the runtime data may contain objects from before normalization was added. The `as Record` cast is intentional defense.

  3. **src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx line 38** — The `{task.assignedTo}` renders directly, crashing if the value is an object. Add safe rendering:

     Current code:
     ```tsx
     <p className="mt-1 text-sm text-zinc-200">{task.assignedTo}</p>
     ```

     Change to:
     ```tsx
     <p className="mt-1 text-sm text-zinc-200">
       {typeof task.assignedTo === "object" && task.assignedTo !== null
         ? (task.assignedTo as Record<string, unknown>).name as string ?? "unknown"
         : task.assignedTo ?? "unassigned"}
     </p>
     ```
     This prevents React error #31 by extracting the `.name` property from agent objects that leaked into the task graph before normalization was in place.
  </action>
  <verify>
  1. `cd /Users/apple/Documents/coding-projects/idumb/v2 && npm run typecheck` — zero errors
  2. `npm test` — all suites pass, no regressions
  3. Grep confirms: `grep "typeof agent" src/index.ts` matches normalization
  4. Grep confirms: `grep "typeof raw" src/tools/tasks.ts` matches normalization
  5. Grep confirms: `grep "typeof task.assignedTo" src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx` matches safe render
  </verify>
  <done>
  Agent identity is always stored and rendered as a string. No agent object can propagate into TaskNode.assignedTo, TaskNode.delegatedBy, or capturedAgent. React error #31 cannot recur.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate corrupt agent objects in persisted JSON files (Wave 2)</name>
  <files>
    .idumb/brain/graph.json
    .idumb/brain/state.json
  </files>
  <action>
  Write and execute a one-shot Node.js migration script that normalizes all agent-object values to strings in the two persisted data files. The script must:

  1. **Create** a temporary migration script at `scripts/migrate-agent-objects.mjs` (ESM, no dependencies):

  ```javascript
  /**
   * One-shot migration: normalize agent objects to string names
   * in graph.json and state.json.
   *
   * Targets:
   *   graph.json — workPlans[].ownedBy, workPlans[].tasks[].assignedTo, workPlans[].tasks[].delegatedBy
   *   state.json — sessions[*].capturedAgent
   *
   * Run: node scripts/migrate-agent-objects.mjs
   */
  import { readFileSync, writeFileSync, copyFileSync } from "node:fs"
  import { join } from "node:path"

  const BRAIN = join(process.cwd(), ".idumb", "brain")

  function normalize(value) {
    if (value === null || value === undefined) return value
    if (typeof value === "string") return value
    if (typeof value === "object" && value.name && typeof value.name === "string") return value.name
    return String(value)
  }

  // --- graph.json ---
  const graphPath = join(BRAIN, "graph.json")
  const graphBackup = join(BRAIN, "graph.json.bak")
  copyFileSync(graphPath, graphBackup)

  const graph = JSON.parse(readFileSync(graphPath, "utf-8"))
  let graphFixes = 0

  for (const wp of graph.workPlans ?? []) {
    if (typeof wp.ownedBy === "object") {
      wp.ownedBy = normalize(wp.ownedBy)
      graphFixes++
    }
    for (const task of wp.tasks ?? []) {
      if (typeof task.assignedTo === "object") {
        task.assignedTo = normalize(task.assignedTo)
        graphFixes++
      }
      if (typeof task.delegatedBy === "object") {
        task.delegatedBy = normalize(task.delegatedBy)
        graphFixes++
      }
    }
    for (const task of wp.planAhead ?? []) {
      if (typeof task.assignedTo === "object") {
        task.assignedTo = normalize(task.assignedTo)
        graphFixes++
      }
      if (typeof task.delegatedBy === "object") {
        task.delegatedBy = normalize(task.delegatedBy)
        graphFixes++
      }
    }
  }

  writeFileSync(graphPath, JSON.stringify(graph, null, 2))
  console.log(`graph.json: ${graphFixes} fields normalized. Backup: graph.json.bak`)

  // --- state.json ---
  const statePath = join(BRAIN, "state.json")
  const stateBackup = join(BRAIN, "state.json.bak")
  copyFileSync(statePath, stateBackup)

  const state = JSON.parse(readFileSync(statePath, "utf-8"))
  let stateFixes = 0

  for (const [_sid, session] of Object.entries(state.sessions ?? {})) {
    if (typeof session.capturedAgent === "object") {
      session.capturedAgent = normalize(session.capturedAgent)
      stateFixes++
    }
  }

  writeFileSync(statePath, JSON.stringify(state, null, 2))
  console.log(`state.json: ${stateFixes} fields normalized. Backup: state.json.bak`)
  console.log(`Total: ${graphFixes + stateFixes} fields fixed.`)
  ```

  2. **Run** the script: `node scripts/migrate-agent-objects.mjs`

  3. **Verify** migration succeeded by grepping the output files:
     - `grep -c '"assignedTo": {' .idumb/brain/graph.json` should return 0
     - `grep -c '"delegatedBy": {' .idumb/brain/graph.json` should return 0
     - `grep -c '"ownedBy": {' .idumb/brain/graph.json` should return 0
     - `grep -c '"capturedAgent": {' .idumb/brain/state.json` should return 0

  4. **Delete** the migration script after successful run: `rm scripts/migrate-agent-objects.mjs`
     Also delete backup files after verification: `rm .idumb/brain/graph.json.bak .idumb/brain/state.json.bak`
     (Or keep backups if the executor prefers — they are gitignored.)
  </action>
  <verify>
  1. `grep -c '"assignedTo": {' .idumb/brain/graph.json` returns 0
  2. `grep -c '"delegatedBy": {' .idumb/brain/graph.json` returns 0
  3. `grep -c '"ownedBy": {' .idumb/brain/graph.json` returns 0
  4. `grep -c '"capturedAgent": {' .idumb/brain/state.json` returns 0
  5. `grep '"assignedTo"' .idumb/brain/graph.json | head -5` shows string values like `"assignedTo": "idumb-executor"`
  6. File sizes are smaller (agent objects were ~1KB each, strings are ~20 bytes)
  </verify>
  <done>
  All persisted agent values in graph.json and state.json are plain strings. No agent-object data remains. The dashboard can render task detail panels for all tasks (active and historical) without React error #31.
  </done>
</task>

</tasks>

<verification>
After all 3 tasks complete, run the full verification sequence:

1. **TypeScript**: `npm run typecheck` — zero errors
2. **Frontend TypeScript**: `cd src/dashboard/frontend && npx tsc --noEmit` — zero errors
3. **Frontend build**: `cd src/dashboard/frontend && npm run build` — clean build, no warnings
4. **Test suite**: `npm test` — all suites pass, baseline maintained
5. **Data integrity**:
   - `grep -c '"assignedTo": {' .idumb/brain/graph.json` returns 0
   - `grep -c '"capturedAgent": {' .idumb/brain/state.json` returns 0
6. **Code correctness**:
   - `grep "flex flex-col" src/dashboard/frontend/src/pages/ChatPage.tsx` — content wrapper has flex column
   - `grep "typeof agent" src/index.ts` — chat.params normalizes agent
   - `grep "typeof task.assignedTo" src/dashboard/frontend/src/components/tasks/TaskDetailPanel.tsx` — safe render
</verification>

<success_criteria>
1. UAT Test 5 passes: clicking a chat session renders message history in the viewport with proper scroll behavior
2. UAT Test 7 passes: active tasks render in the task sidebar and detail panel without React error #31
3. UAT Tests 6 and 8 (previously skipped) are unblocked and can be tested
4. Zero TypeScript errors, zero test regressions
5. No agent-object data remains in any persisted JSON file
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-task-bus/01-08-SUMMARY.md`
</output>
