---
phase: 01-engine-task-bus
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - src/dashboard/frontend/src/components/governance/GovernanceBar.tsx
  - src/dashboard/frontend/src/components/governance/ActivityIndicator.tsx
  - src/dashboard/frontend/src/components/chat/DelegationThread.tsx
  - src/dashboard/frontend/src/components/layout/AppShell.tsx
  - src/dashboard/frontend/src/hooks/useEventStream.ts
autonomous: true

must_haves:
  truths:
    - "User sees governance status bar showing green/yellow/red state"
    - "User sees which agent is currently active in the chat"
    - "Sub-agent delegation renders as threaded/collapsible blocks"
    - "Inline governance warnings appear when writes are untracked"
    - "Activity indicators show when OpenCode is working"
  artifacts:
    - path: "src/dashboard/frontend/src/components/governance/GovernanceBar.tsx"
      provides: "Persistent governance status bar with mode + active task + write gate"
      min_lines: 60
    - path: "src/dashboard/frontend/src/components/governance/ActivityIndicator.tsx"
      provides: "Pulsing/spinning indicator for active operations"
      min_lines: 20
    - path: "src/dashboard/frontend/src/components/chat/DelegationThread.tsx"
      provides: "Threaded delegation view for sub-agent conversations"
      min_lines: 60
    - path: "src/dashboard/frontend/src/hooks/useEventStream.ts"
      provides: "Global SSE event stream hook for real-time updates"
      min_lines: 40
  key_links:
    - from: "src/dashboard/frontend/src/hooks/useEventStream.ts"
      to: "backend /api/events"
      via: "EventSource SSE connection"
      pattern: "EventSource|api/events"
    - from: "src/dashboard/frontend/src/components/governance/GovernanceBar.tsx"
      to: "src/dashboard/frontend/src/hooks/useTasks.ts"
      via: "useGovernance hook for state"
      pattern: "useGovernance"
    - from: "src/dashboard/frontend/src/components/chat/DelegationThread.tsx"
      to: "src/dashboard/frontend/src/hooks/useSession.ts"
      via: "useSession for child sessions"
      pattern: "useSession|children"
---

<objective>
Add multi-agent delegation visibility and governance status overlay.

Purpose: Users need real-time awareness of which agent is active, governance state (write-gate on/off), and delegation chains. Per user decisions: threaded delegation (collapsible), governance advisory bar (green/yellow/red), inline cues.

Output: GovernanceBar, ActivityIndicator, DelegationThread, global event stream hook.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-engine-task-bus/01-RESEARCH.md
@.planning/phases/01-engine-task-bus/01-03-SUMMARY.md
@.planning/phases/01-engine-task-bus/01-04-SUMMARY.md
@src/schemas/delegation.ts
@src/schemas/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Global Event Stream + Governance Components</name>
  <files>src/dashboard/frontend/src/hooks/useEventStream.ts, src/dashboard/frontend/src/components/governance/GovernanceBar.tsx, src/dashboard/frontend/src/components/governance/ActivityIndicator.tsx</files>
  <action>
**Create `src/dashboard/frontend/src/hooks/useEventStream.ts`:**
Global SSE event stream that all components can subscribe to:
- Creates a single `EventSource` connection to `/api/events`
- Maintains an event bus pattern: components register callbacks by event type
- `useEventStream()` ‚Äî returns `{ subscribe(type, callback), unsubscribe(type, callback), connected: boolean }`
- Auto-reconnects on disconnect (EventSource handles this natively with `retry:` header)
- Parse incoming events and dispatch to registered callbacks
- Track connection state: `connected`, `reconnecting`, `disconnected`
- Singleton pattern: only one EventSource per app (use React context or module-level variable)

**Create `src/dashboard/frontend/src/components/governance/GovernanceBar.tsx`:**
Persistent status bar at the top of the app shell. Per user decision: advisory bar with green/yellow/red.

- Width: full page, height: thin bar (h-8)
- States:
  - **Green** (bg-emerald-500/10, text-emerald-500): Active task, writes unlocked. Shows: "‚úì Task: {taskName} ‚Äî writes unlocked"
  - **Yellow** (bg-amber-500/10, text-amber-500): No active task, writes blocked. Shows: "‚ö† No active task ‚Äî writes blocked"
  - **Red** (bg-red-500/10, text-red-500): Governance error or failed task. Shows: "‚úó Task failed: {reason}"
  - **Gray** (bg-zinc-500/10, text-zinc-400): Governance not initialized. Shows: "‚óã Governance not active"
- Right side: governance mode badge (`strict`/`standard`/`relaxed`/`retard`), untracked writes counter (if > 0, shows "X untracked writes" in yellow)
- Subscribe to event stream for real-time updates
- Uses `useGovernance()` hook from useTasks.ts

**Create `src/dashboard/frontend/src/components/governance/ActivityIndicator.tsx`:**
Small component showing OpenCode activity:
- Pulsing blue dot when session is `running`
- Spinning loader when session is `compacting`
- Static gray dot when `idle`
- Agent name badge next to indicator (e.g., "executor", "investigator")
- Compact version for sidebar, expanded version for chat header
  </action>
  <verify>
`cd src/dashboard/frontend && npx tsc --noEmit` ‚Äî zero errors. Components render without crashes.
  </verify>
  <done>
GovernanceBar shows real-time governance state with color-coded advisory. ActivityIndicator shows agent activity. Event stream provides real-time updates to all subscribed components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Delegation Threading + Wire to App Shell</name>
  <files>src/dashboard/frontend/src/components/chat/DelegationThread.tsx, src/dashboard/frontend/src/components/layout/AppShell.tsx</files>
  <action>
**Create `src/dashboard/frontend/src/components/chat/DelegationThread.tsx`:**
Per user decision: threaded delegation with collapsible sub-conversations, inline cueing.

When an `agent` part appears in the message stream:
- Render a delegation block with:
  - Header: agent name badge (e.g., "üîç investigator" or "‚ö° executor") with role color
  - Collapsible body showing the sub-agent's messages
  - Status indicator: delegating ‚Üí working ‚Üí completed/failed
  - Visual indent to show nesting (delegation within delegation)
- Fetch child session messages using `client.session.children()` ‚Üí `client.session.messages(childId)`
- Collapsed by default (shows summary: "Delegated to investigator ‚Äî 3 messages"), expandable
- Expand shows: full message list from child session rendered with same PartRenderer
- Nesting: if child session also delegates, render nested DelegationThread (recursive, max depth 3)
- Connection line: subtle left border connecting parent to child (like GitHub thread UI)

**Update `src/dashboard/frontend/src/components/layout/AppShell.tsx`:**
- Add `GovernanceBar` at the top of the main content area (below AppShell header, above page content)
- Add `ActivityIndicator` to the sidebar footer, next to engine status
- Wrap the app in an EventStream provider context so all components share the SSE connection
- Structure: `<EventStreamProvider>` ‚Üí `<AppShell>` ‚Üí `<GovernanceBar>` + `<Outlet>`
  </action>
  <verify>
`cd src/dashboard/frontend && npm run build` succeeds. GovernanceBar visible at top. When agent delegation occurs in chat, threaded blocks render with collapsible content.
  </verify>
  <done>
Delegation threads render as collapsible, threaded blocks per user decision. GovernanceBar persistently shows governance state. ActivityIndicator in sidebar shows current agent activity. All components receive real-time updates via shared event stream.
  </done>
</task>

</tasks>

<verification>
1. `cd src/dashboard/frontend && npx tsc --noEmit` ‚Äî zero errors
2. `cd src/dashboard/frontend && npm run build` ‚Äî succeeds
3. GovernanceBar shows correct color state (green/yellow/red/gray)
4. Agent delegation in chat renders as threaded, collapsible blocks
5. Activity indicator pulses when session is running
6. Untracked writes counter appears when applicable
7. Event stream reconnects gracefully on disconnect
</verification>

<success_criteria>
- Governance status visible at all times via advisory bar per user decision
- Multi-agent delegation renders as threaded conversations per user decision
- Real-time updates via SSE (no polling for events)
- Agent identity visible during active work
- Untracked writes tracked and displayed
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-task-bus/01-05-SUMMARY.md`
</output>
