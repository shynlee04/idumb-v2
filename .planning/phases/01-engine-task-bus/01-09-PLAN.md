---
phase: 01-engine-task-bus
plan: 09
type: execute
wave: 1
depends_on: ["01-08"]
files_modified:
  - src/dashboard/backend/server.ts
  - src/dashboard/shared/engine-types.ts
  - src/dashboard/frontend/src/lib/api.ts
  - src/dashboard/frontend/src/hooks/useConfig.ts
  - src/dashboard/frontend/src/components/chat/ModelSelector.tsx
  - src/dashboard/frontend/src/components/chat/AgentSelector.tsx
  - src/dashboard/frontend/src/pages/ChatPage.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can see which AI providers are configured and their models via /api/providers"
    - "User can select a model from a grouped dropdown before sending a message"
    - "User can select an agent from a dropdown before sending a message"
    - "Selected model/agent are passed to session.create() and session.prompt()"
    - "Model/agent selection persists across page refreshes via localStorage"
  artifacts:
    - path: "src/dashboard/backend/server.ts"
      provides: "GET /api/providers, GET /api/agents, GET /api/config, GET /api/app routes"
      contains: "/api/providers"
    - path: "src/dashboard/shared/engine-types.ts"
      provides: "ProviderInfo, ModelInfo, AgentInfo shared types"
      contains: "ProviderInfo"
    - path: "src/dashboard/frontend/src/lib/api.ts"
      provides: "getProviders, getAgents, getConfig, getApp client functions + model/provider params on createSession/sendPrompt"
      contains: "getProviders"
    - path: "src/dashboard/frontend/src/hooks/useConfig.ts"
      provides: "useProviders, useAgents, useConfig React Query hooks"
      exports: ["useProviders", "useAgents", "useConfig"]
    - path: "src/dashboard/frontend/src/components/chat/ModelSelector.tsx"
      provides: "Model combobox grouped by provider"
      exports: ["ModelSelector"]
    - path: "src/dashboard/frontend/src/components/chat/AgentSelector.tsx"
      provides: "Agent dropdown selector"
      exports: ["AgentSelector"]
    - path: "src/dashboard/frontend/src/pages/ChatPage.tsx"
      provides: "Model/agent selectors in session header, passed to create/send"
      contains: "ModelSelector"
  key_links:
    - from: "components/chat/ModelSelector.tsx"
      to: "hooks/useConfig.ts → useProviders()"
      via: "React Query fetch"
      pattern: "useProviders"
    - from: "hooks/useConfig.ts → useProviders()"
      to: "/api/providers backend route"
      via: "api.getProviders()"
      pattern: "getProviders"
    - from: "pages/ChatPage.tsx"
      to: "api.createSession / api.sendPrompt"
      via: "modelID + providerID params"
      pattern: "modelID.*providerID"
    - from: "server.ts /api/providers"
      to: "engine.ts getClient().provider.list()"
      via: "SDK proxy"
      pattern: "provider\\.list"
---

<objective>
Close configuration gap (G1, G2, G3, G6 from 01-RESEARCH-config-gap): Add backend proxy routes for provider/agent/config data, create model and agent selector components, and wire them into the chat page so users can choose which model and agent handle their session.

Purpose: Without model/agent selection, the dashboard can't function as a standalone product — users have no way to control which AI they're talking to or which agent handles their session.
Output: 4 new backend routes, 3 new frontend files (hooks + 2 components), 3 modified files (server, api client, ChatPage).
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-engine-task-bus/01-RESEARCH-config-gap-2026-02-10.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend config proxy routes + shared types + API client</name>
  <files>
    src/dashboard/backend/server.ts
    src/dashboard/shared/engine-types.ts
    src/dashboard/frontend/src/lib/api.ts
  </files>
  <action>
  Three files to modify. All changes are additive — no existing functionality changes.

  **1. `src/dashboard/shared/engine-types.ts`** — Add shared types after the existing exports:

  ```typescript
  /** Provider model info from SDK provider.list() */
  export interface ModelInfo {
    id: string
    name: string
  }

  /** Provider info from SDK provider.list() */
  export interface ProviderInfo {
    id: string
    name: string
    models: ModelInfo[]
  }

  /** Agent info from SDK agent.list() */
  export interface AgentInfo {
    id: string
    name: string
    description?: string
  }

  /** App info from SDK app.get() */
  export interface AppInfo {
    path: { cwd: string; config: string; data: string }
    git?: Record<string, unknown>
    hostname?: string
  }
  ```

  **2. `src/dashboard/backend/server.ts`** — Add 4 new GET routes. Place them after the existing `/api/health` route (around line 80) and before the session routes. Follow the exact same error-handling pattern used by existing routes:

  ```typescript
  // ─── Config proxy routes ──────────────────────────────────
  app.get("/api/providers", async (_req: Request, res: Response) => {
    try {
      const result = await getClient().provider.list()
      // SDK returns { all: ProviderInfo[] }
      const providers = (result as Record<string, unknown>).all ?? result
      res.json(providers)
    } catch (err) {
      res.status(500).json({ error: `Failed to list providers: ${String(err)}` })
    }
  })

  app.get("/api/agents", async (_req: Request, res: Response) => {
    try {
      const result = await getClient().agent.list()
      // SDK returns Record<string, AgentInfo> — convert to array for frontend
      const agents = typeof result === "object" && result !== null
        ? Object.entries(result as Record<string, Record<string, unknown>>).map(([id, agent]) => ({
            id,
            name: (agent as Record<string, unknown>).name ?? id,
            description: (agent as Record<string, unknown>).description ?? "",
          }))
        : []
      res.json(agents)
    } catch (err) {
      res.status(500).json({ error: `Failed to list agents: ${String(err)}` })
    }
  })

  app.get("/api/config", async (_req: Request, res: Response) => {
    try {
      const result = await getClient().config.get()
      res.json(result)
    } catch (err) {
      res.status(500).json({ error: `Failed to get config: ${String(err)}` })
    }
  })

  app.get("/api/app", async (_req: Request, res: Response) => {
    try {
      const result = await getClient().app.get()
      res.json(result)
    } catch (err) {
      res.status(500).json({ error: `Failed to get app info: ${String(err)}` })
    }
  })
  ```

  Also modify the existing `POST /api/sessions` route (line 539) to pass through `modelID` and `providerID`:

  Current code (line 541):
  ```typescript
  const title = typeof req.body?.title === "string" ? req.body.title : undefined
  ```
  After this line, add:
  ```typescript
  const modelID = typeof req.body?.modelID === "string" ? req.body.modelID : undefined
  const providerID = typeof req.body?.providerID === "string" ? req.body.providerID : undefined
  ```

  Then change the body passed to `session.create()` (line 546):
  ```typescript
  // From:
  body: title ? { title } : {},
  // To:
  body: { ...(title ? { title } : {}), ...(modelID ? { modelID } : {}), ...(providerID ? { providerID } : {}) },
  ```

  Also modify `POST /api/sessions/:id/prompt` (line 722) to pass through model/provider:

  After line 693 (where `parts` is computed), add:
  ```typescript
  const modelID = typeof req.body?.modelID === "string" ? req.body.modelID : undefined
  const providerID = typeof req.body?.providerID === "string" ? req.body.providerID : undefined
  ```

  Then change the prompt body (line 722):
  ```typescript
  // From:
  body: { parts },
  // To:
  body: { parts, ...(modelID ? { modelID } : {}), ...(providerID ? { providerID } : {}) },
  ```

  **3. `src/dashboard/frontend/src/lib/api.ts`** — Add 4 new API functions and update 2 existing ones.

  After the `GovernanceStatus` interface (line 120), add the import:
  ```typescript
  import type { ProviderInfo, AgentInfo, AppInfo } from "../../../shared/engine-types"
  ```
  Note: This may need adjusting — if the shared types aren't importable due to Vite resolution, define the types inline in api.ts instead. Use the `@/` alias if configured, or fall back to relative path.

  Add to the `api` object (after `getGovernance` on line 200):

  ```typescript
  getProviders: (): Promise<ProviderInfo[]> =>
    fetch(`${API_BASE}/api/providers`).then(r => json<ProviderInfo[]>(r)),

  getAgents: (): Promise<AgentInfo[]> =>
    fetch(`${API_BASE}/api/agents`).then(r => json<AgentInfo[]>(r)),

  getConfig: (): Promise<Record<string, unknown>> =>
    fetch(`${API_BASE}/api/config`).then(r => json<Record<string, unknown>>(r)),

  getApp: (): Promise<AppInfo> =>
    fetch(`${API_BASE}/api/app`).then(r => json<AppInfo>(r)),
  ```

  Update `createSession` (line 141) to accept model/provider:
  ```typescript
  // From:
  createSession: (title?: string): Promise<Session> =>
    fetch(`${API_BASE}/api/sessions`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(title ? { title } : {}),
    }).then(r => json<Session>(r)),

  // To:
  createSession: (opts?: { title?: string; modelID?: string; providerID?: string }): Promise<Session> =>
    fetch(`${API_BASE}/api/sessions`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(opts ?? {}),
    }).then(r => json<Session>(r)),
  ```

  Update `sendPrompt` (line 171) to accept model/provider:
  ```typescript
  // From:
  sendPrompt: (id: string, text: string, signal?: AbortSignal): Promise<Response> =>
    fetch(`${API_BASE}/api/sessions/${id}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        parts: [{ type: "text", text }],
      }),
      signal,
    }),

  // To:
  sendPrompt: (id: string, text: string, signal?: AbortSignal, opts?: { modelID?: string; providerID?: string }): Promise<Response> =>
    fetch(`${API_BASE}/api/sessions/${id}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        parts: [{ type: "text", text }],
        ...(opts?.modelID ? { modelID: opts.modelID } : {}),
        ...(opts?.providerID ? { providerID: opts.providerID } : {}),
      }),
      signal,
    }),
  ```

  **IMPORTANT:** After changing `createSession` signature, check `useCreateSession` in `hooks/useEngine.ts`. It currently calls `api.createSession()` with no args. The new signature is backward compatible (optional param), so no change needed there. But `ChatPage.tsx`'s `createSession.mutate(undefined)` call also works because `undefined` maps to the optional parameter. Verify `useCreateSession` in useEngine.ts still works — if it passes through the mutate argument to `api.createSession`, then passing `{ modelID, providerID }` from ChatPage will work.
  </action>
  <verify>
  1. `cd src/dashboard/frontend && npx tsc --noEmit` — zero TypeScript errors
  2. `npm run typecheck` — zero errors (backend)
  3. `grep "/api/providers" src/dashboard/backend/server.ts` — route exists
  4. `grep "/api/agents" src/dashboard/backend/server.ts` — route exists
  5. `grep "/api/config" src/dashboard/backend/server.ts` — route exists
  6. `grep "/api/app" src/dashboard/backend/server.ts` — route exists
  7. `grep "getProviders" src/dashboard/frontend/src/lib/api.ts` — API function exists
  8. `grep "modelID" src/dashboard/frontend/src/lib/api.ts` — model param in createSession and sendPrompt
  9. `grep "ProviderInfo" src/dashboard/shared/engine-types.ts` — type exported
  </verify>
  <done>
  Backend has 4 config proxy routes (providers, agents, config, app). Frontend API client has matching fetch functions. Session creation and prompt sending accept optional modelID/providerID. All types shared via engine-types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: React Query hooks + Model/Agent selectors + ChatPage wiring</name>
  <files>
    src/dashboard/frontend/src/hooks/useConfig.ts
    src/dashboard/frontend/src/components/chat/ModelSelector.tsx
    src/dashboard/frontend/src/components/chat/AgentSelector.tsx
    src/dashboard/frontend/src/pages/ChatPage.tsx
  </files>
  <action>
  Create 3 new files and modify ChatPage to wire everything together.

  **1. `src/dashboard/frontend/src/hooks/useConfig.ts`** — Create React Query hooks following `useEngine.ts` pattern:

  ```typescript
  /**
   * useConfig hooks — React Query wrappers for provider/agent/config data.
   *
   * - useProviders()  — fetches configured AI providers with their models
   * - useAgents()     — fetches available agents
   * - useConfig()     — fetches OpenCode config
   */
  import { useQuery } from "@tanstack/react-query"
  import { api } from "@/lib/api"

  export const configKeys = {
    providers: ["providers"] as const,
    agents: ["agents"] as const,
    config: ["config"] as const,
    app: ["app"] as const,
  }

  /** Fetch all configured providers with their models. Refetches every 30s. */
  export function useProviders() {
    return useQuery({
      queryKey: configKeys.providers,
      queryFn: () => api.getProviders(),
      refetchInterval: 30_000,
      staleTime: 10_000,
    })
  }

  /** Fetch all available agents. Refetches every 30s. */
  export function useAgents() {
    return useQuery({
      queryKey: configKeys.agents,
      queryFn: () => api.getAgents(),
      refetchInterval: 30_000,
      staleTime: 10_000,
    })
  }

  /** Fetch OpenCode config. Refetches every 60s (config changes rarely). */
  export function useConfig() {
    return useQuery({
      queryKey: configKeys.config,
      queryFn: () => api.getConfig(),
      refetchInterval: 60_000,
      staleTime: 30_000,
    })
  }
  ```

  **2. `src/dashboard/frontend/src/components/chat/ModelSelector.tsx`** — Model selector dropdown:

  Follow shadcn `button` + custom dropdown pattern (since we have `button.tsx` but not `select.tsx`). Use a simple button + absolute-positioned dropdown. Do NOT install new shadcn components — use existing `button.tsx` + Tailwind.

  ```tsx
  import { useState, useRef, useEffect } from "react"
  import { ChevronDown, Cpu } from "lucide-react"
  import { useProviders } from "@/hooks/useConfig"
  import { cn } from "@/lib/utils"

  interface ModelSelectorProps {
    modelID: string | null
    providerID: string | null
    onSelect: (modelID: string, providerID: string) => void
  }

  export function ModelSelector({ modelID, providerID, onSelect }: ModelSelectorProps) {
    const { data: providers = [], isLoading } = useProviders()
    const [open, setOpen] = useState(false)
    const ref = useRef<HTMLDivElement>(null)

    // Close on outside click
    useEffect(() => {
      const handler = (e: MouseEvent) => {
        if (ref.current && !ref.current.contains(e.target as Node)) setOpen(false)
      }
      document.addEventListener("mousedown", handler)
      return () => document.removeEventListener("mousedown", handler)
    }, [])

    // Auto-select first model if none selected
    useEffect(() => {
      if (!modelID && providers.length > 0) {
        const firstProvider = providers[0]
        const firstModel = firstProvider.models?.[0]
        if (firstModel) {
          onSelect(firstModel.id, firstProvider.id)
        }
      }
    }, [modelID, providers, onSelect])

    const selectedLabel = modelID
      ? `${modelID.split("/").pop() ?? modelID}`
      : "Select model..."

    return (
      <div className="relative" ref={ref}>
        <button
          type="button"
          className={cn(
            "flex items-center gap-1.5 rounded-md border border-border px-2.5 py-1 text-xs transition-colors",
            "hover:bg-zinc-800/60 text-zinc-300",
            open && "bg-zinc-800/60 ring-1 ring-blue-500/30"
          )}
          onClick={() => setOpen(!open)}
        >
          <Cpu className="h-3 w-3 text-zinc-500" />
          <span className="max-w-[160px] truncate">{selectedLabel}</span>
          <ChevronDown className={cn("h-3 w-3 text-zinc-500 transition-transform", open && "rotate-180")} />
        </button>

        {open && (
          <div className="absolute left-0 top-full z-50 mt-1 max-h-64 w-72 overflow-y-auto rounded-md border border-border bg-zinc-900 py-1 shadow-lg">
            {isLoading ? (
              <p className="px-3 py-2 text-xs text-zinc-500">Loading providers...</p>
            ) : providers.length === 0 ? (
              <p className="px-3 py-2 text-xs text-zinc-500">No providers configured</p>
            ) : (
              providers.map((provider) => (
                <div key={provider.id}>
                  <p className="px-3 py-1.5 text-[10px] font-semibold uppercase tracking-wider text-zinc-500">
                    {provider.name || provider.id}
                  </p>
                  {(provider.models ?? []).map((model) => (
                    <button
                      key={`${provider.id}/${model.id}`}
                      type="button"
                      className={cn(
                        "flex w-full items-center px-3 py-1.5 text-xs transition-colors",
                        modelID === model.id && providerID === provider.id
                          ? "bg-blue-500/15 text-blue-300"
                          : "text-zinc-300 hover:bg-zinc-800/60"
                      )}
                      onClick={() => {
                        onSelect(model.id, provider.id)
                        setOpen(false)
                      }}
                    >
                      {model.name || model.id}
                    </button>
                  ))}
                </div>
              ))
            )}
          </div>
        )}
      </div>
    )
  }
  ```

  **3. `src/dashboard/frontend/src/components/chat/AgentSelector.tsx`** — Agent selector dropdown:

  Same pattern as ModelSelector but simpler (flat list, no grouping).

  ```tsx
  import { useState, useRef, useEffect } from "react"
  import { ChevronDown, Bot } from "lucide-react"
  import { useAgents } from "@/hooks/useConfig"
  import { cn } from "@/lib/utils"

  interface AgentSelectorProps {
    agentID: string | null
    onSelect: (agentID: string) => void
  }

  export function AgentSelector({ agentID, onSelect }: AgentSelectorProps) {
    const { data: agents = [], isLoading } = useAgents()
    const [open, setOpen] = useState(false)
    const ref = useRef<HTMLDivElement>(null)

    useEffect(() => {
      const handler = (e: MouseEvent) => {
        if (ref.current && !ref.current.contains(e.target as Node)) setOpen(false)
      }
      document.addEventListener("mousedown", handler)
      return () => document.removeEventListener("mousedown", handler)
    }, [])

    const selectedLabel = agentID
      ? agents.find(a => a.id === agentID)?.name ?? agentID
      : "Default agent"

    return (
      <div className="relative" ref={ref}>
        <button
          type="button"
          className={cn(
            "flex items-center gap-1.5 rounded-md border border-border px-2.5 py-1 text-xs transition-colors",
            "hover:bg-zinc-800/60 text-zinc-300",
            open && "bg-zinc-800/60 ring-1 ring-blue-500/30"
          )}
          onClick={() => setOpen(!open)}
        >
          <Bot className="h-3 w-3 text-zinc-500" />
          <span className="max-w-[120px] truncate">{selectedLabel}</span>
          <ChevronDown className={cn("h-3 w-3 text-zinc-500 transition-transform", open && "rotate-180")} />
        </button>

        {open && (
          <div className="absolute left-0 top-full z-50 mt-1 max-h-48 w-56 overflow-y-auto rounded-md border border-border bg-zinc-900 py-1 shadow-lg">
            {/* Default (no agent override) */}
            <button
              type="button"
              className={cn(
                "flex w-full items-center px-3 py-1.5 text-xs transition-colors",
                !agentID ? "bg-blue-500/15 text-blue-300" : "text-zinc-300 hover:bg-zinc-800/60"
              )}
              onClick={() => { onSelect(""); setOpen(false) }}
            >
              Default agent
            </button>
            {isLoading ? (
              <p className="px-3 py-2 text-xs text-zinc-500">Loading agents...</p>
            ) : (
              agents.map((agent) => (
                <button
                  key={agent.id}
                  type="button"
                  className={cn(
                    "flex w-full flex-col items-start px-3 py-1.5 text-xs transition-colors",
                    agentID === agent.id
                      ? "bg-blue-500/15 text-blue-300"
                      : "text-zinc-300 hover:bg-zinc-800/60"
                  )}
                  onClick={() => { onSelect(agent.id); setOpen(false) }}
                >
                  <span>{agent.name || agent.id}</span>
                  {agent.description ? (
                    <span className="mt-0.5 text-[10px] text-zinc-500 line-clamp-1">{agent.description}</span>
                  ) : null}
                </button>
              ))
            )}
          </div>
        )}
      </div>
    )
  }
  ```

  **4. `src/dashboard/frontend/src/pages/ChatPage.tsx`** — Add model/agent selectors to session header and pass to API calls.

  **4a.** Add imports at the top (after existing imports):
  ```typescript
  import { useCallback } from "react"
  import { ModelSelector } from "@/components/chat/ModelSelector"
  import { AgentSelector } from "@/components/chat/AgentSelector"
  ```
  Note: `useMemo` is already imported. Add `useCallback` and `useState` alongside the existing imports.

  **4b.** Inside the `ChatPage` function (after `const streaming = useStreaming(sessionId)` on line 31), add model/agent state with localStorage persistence:

  ```typescript
  // Model/agent selection — persisted in localStorage
  const [modelID, setModelID] = useState<string | null>(() =>
    localStorage.getItem("idumb-selected-model")
  )
  const [providerID, setProviderID] = useState<string | null>(() =>
    localStorage.getItem("idumb-selected-provider")
  )
  const [agentID, setAgentID] = useState<string | null>(() =>
    localStorage.getItem("idumb-selected-agent")
  )

  const handleModelSelect = useCallback((model: string, provider: string) => {
    setModelID(model)
    setProviderID(provider)
    localStorage.setItem("idumb-selected-model", model)
    localStorage.setItem("idumb-selected-provider", provider)
  }, [])

  const handleAgentSelect = useCallback((agent: string) => {
    setAgentID(agent || null)
    if (agent) {
      localStorage.setItem("idumb-selected-agent", agent)
    } else {
      localStorage.removeItem("idumb-selected-agent")
    }
  }, [])
  ```

  **4c.** Update `onSend` (line 38) to pass model/provider to streaming:
  ```typescript
  // Current sendPrompt doesn't accept opts yet — it calls api.sendPrompt internally.
  // The useStreaming hook calls api.sendPrompt(sessionId, text, abortController.signal).
  // For now, model/provider selection is passed at session creation time (below).
  // Future: extend useStreaming to accept model/provider per-message.
  ```
  Note: For Phase 1, model/provider is set at session creation time. Per-message model switching requires refactoring useStreaming (Phase 2 scope).

  **4d.** Update `onNewChat` (line 43) to pass model/provider:
  ```typescript
  const onNewChat = () => {
    createSession.mutate(
      { ...(modelID ? { modelID } : {}), ...(providerID ? { providerID } : {}) },
      {
        onSuccess: (session) => navigate(`/chat/${session.id}`),
      },
    )
  }
  ```

  **4e.** In the session header bar (lines 117-122), add the selectors:

  Replace:
  ```tsx
  <div className="border-b border-border px-4 py-2">
    <h1 className="text-sm font-semibold">Session {sessionId.slice(0, 8)}</h1>
    {streaming.error ? (
      <p className="mt-1 text-xs text-red-300">{streaming.error}</p>
    ) : null}
  </div>
  ```

  With:
  ```tsx
  <div className="flex items-center justify-between border-b border-border px-4 py-2">
    <h1 className="text-sm font-semibold">Session {sessionId.slice(0, 8)}</h1>
    <div className="flex items-center gap-2">
      <ModelSelector
        modelID={modelID}
        providerID={providerID}
        onSelect={handleModelSelect}
      />
      <AgentSelector
        agentID={agentID}
        onSelect={handleAgentSelect}
      />
    </div>
  </div>
  {streaming.error ? (
    <p className="px-4 py-1 text-xs text-red-300">{streaming.error}</p>
  ) : null}
  ```

  **4f.** IMPORTANT: Also check that `useCreateSession` in `hooks/useEngine.ts` passes its `mutate()` argument through to `api.createSession()`. Currently:
  ```typescript
  export function useCreateSession() {
    const qc = useQueryClient()
    return useMutation({
      mutationFn: api.createSession,
      onSuccess: () => qc.invalidateQueries({ queryKey: engineKeys.sessions }),
    })
  }
  ```
  `mutationFn: api.createSession` means whatever argument is passed to `mutate(arg)` goes to `api.createSession(arg)`. Since we changed `api.createSession` to accept `(opts?)`, this works. No change needed to useEngine.ts.
  </action>
  <verify>
  1. `cd src/dashboard/frontend && npx tsc --noEmit` — zero TypeScript errors
  2. `cd src/dashboard/frontend && npm run build` — clean Vite build
  3. `grep "useProviders" src/dashboard/frontend/src/hooks/useConfig.ts` — hook exists
  4. `grep "ModelSelector" src/dashboard/frontend/src/pages/ChatPage.tsx` — component wired
  5. `grep "AgentSelector" src/dashboard/frontend/src/pages/ChatPage.tsx` — component wired
  6. `grep "handleModelSelect" src/dashboard/frontend/src/pages/ChatPage.tsx` — handler exists
  7. `grep "localStorage" src/dashboard/frontend/src/pages/ChatPage.tsx` — persistence wired
  </verify>
  <done>
  Model and agent selector dropdowns appear in the chat session header. Model selector groups models by provider (Anthropic, OpenAI, etc.). Agent selector lists available agents with descriptions. Selection persists in localStorage across page refreshes. Selected model/provider passed to session creation.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. **TypeScript clean**: `npm run typecheck` + `cd src/dashboard/frontend && npx tsc --noEmit` — zero errors
2. **Frontend build**: `cd src/dashboard/frontend && npm run build` — clean build
3. **Test baseline**: `npm test` — all existing tests pass (no tests added — these are UI components)
4. **Backend routes exist**: `grep -c "/api/providers\|/api/agents\|/api/config\|/api/app" src/dashboard/backend/server.ts` — 4 matches
5. **Frontend hooks exist**: `grep "export function use" src/dashboard/frontend/src/hooks/useConfig.ts` — 3 hooks
6. **Selectors wired**: `grep "ModelSelector\|AgentSelector" src/dashboard/frontend/src/pages/ChatPage.tsx` — both present
</verification>

<success_criteria>
1. GET /api/providers returns array of providers with nested models
2. GET /api/agents returns array of agents with id/name/description
3. GET /api/config returns OpenCode config object
4. GET /api/app returns app info (cwd, paths)
5. ModelSelector component renders grouped model dropdown
6. AgentSelector component renders agent dropdown with descriptions
7. ChatPage has both selectors in session header bar
8. Model/agent selection persists in localStorage
9. Selected model/provider passed to session.create()
10. Zero TypeScript errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-task-bus/01-09-SUMMARY.md`
</output>
