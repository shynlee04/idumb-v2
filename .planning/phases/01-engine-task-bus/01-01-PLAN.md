---
phase: 01-engine-task-bus
plan: 01-revised
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/backend/engine.ts
  - src/dashboard/backend/server.ts
  - src/dashboard/shared/engine-types.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard detects or accepts OpenCode server port (default 4096)"
    - "OpenCode server starts and returns a reachable URL"
    - "Sessions can be listed, created, and deleted via REST API"
    - "SSE events stream to browser with client-side session filtering"
    - "Server gracefully shuts down with SIGTERM/SIGINT handlers"
  artifacts:
    - path: "src/dashboard/backend/engine.ts"
      provides: "OpenCode server lifecycle manager + SDK client singleton with port configuration"
      min_lines: 100
    - path: "src/dashboard/backend/server.ts"
      provides: "Session CRUD routes + SSE relay endpoint + graceful shutdown"
      exports: ["startServer"]
    - path: "src/dashboard/shared/engine-types.ts"
      provides: "Shared types for engine API requests/responses including port config"
      min_lines: 30
  key_links:
    - from: "src/dashboard/backend/engine.ts"
      to: "@opencode-ai/sdk/server"
      via: "createOpencode with configurable port"
      pattern: "createOpencode({ port, timeout, config })"
    - from: "src/dashboard/backend/server.ts"
      to: "src/dashboard/backend/engine.ts"
      via: "import getClient, startEngine"
      pattern: "getClient|startEngine"
    - from: "src/dashboard/backend/server.ts"
      to: "browser"
      via: "SSE text/event-stream response with client-side filtering"
      pattern: "text/event-stream"
    - from: "user/dashboard-config"
      to: "src/dashboard/backend/server.ts"
      via: "DashboardConfig.port or user input"
      pattern: "port configuration"

---

<objective>
Create OpenCode server engine and session proxy API with port configuration and graceful shutdown.

Purpose: This is the backbone â€” Express backend wraps OpenCode's SDK to provide session management and real-time event streaming to browser. The backend must detect or accept the OpenCode server port (user needs to know where their OpenCode is running).

Output: `engine.ts` (server lifecycle + client singleton + port config), session CRUD routes in `server.ts` with SSE filtering and graceful shutdown, shared types.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-engine-task-bus/01-RESEARCH.md
@.planning/phases/01-engine-task-bus/01-01-PLAN.md (original)
@src/dashboard/backend/server.ts
@src/dashboard/shared/schema-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenCode Engine Manager with Port Configuration + Shared Types</name>
  <files>src/dashboard/backend/engine.ts, src/dashboard/shared/engine-types.ts</files>
  <action>
Create `src/dashboard/backend/engine.ts` â€” OpenCode server lifecycle manager:

1. Import `createOpencode` from `@opencode-ai/sdk` (new API that returns both server and client)
2. Create a singleton module pattern with:
   - `startEngine(projectDir: string, port?: number)` â€” calls `createOpencode({ port, timeout, config })`, stores both server and client. Port defaults to 4096 (standard OpenCode port). Accepts user-specified port.
   - `getClient()` â€” returns the `OpencodeClient` instance. Throws if engine not started.
   - `stopEngine()` â€” calls `server.close()` if available, clears references, handles Windows ghost port cleanup.
   - `getEngineStatus()` â€” returns `{ running: boolean, url?: string, projectDir?: string, port?: number }`
   - `getActualPort()` â€” returns the actual port OpenCode server is running on.

3. Add graceful shutdown handlers:
   - SIGTERM: call `stopEngine()` then `process.exit(0)`
   - SIGINT: call `stopEngine()` then `process.exit(0)`
   - Prevent double shutdown with `isStopping` flag

4. Add error handling: if `createOpencode()` fails (timeout, port conflict), log via `createLogger` and throw with context. Include port number in error message.

5. Track compaction counts per session in a `Map<sessionId, number>` â€” increment when event shows `time.compacting` transition from non-null to null.

6. Health check: `ensureHealthy()` method that calls `client.global.health()` and returns boolean. Throws if not healthy after 3 retries with exponential backoff.

Create `src/dashboard/shared/engine-types.ts`:
- `EngineStatus` type: `{ running: boolean, url?: string, projectDir?: string, port?: number }`
- `DashboardConfig` type: `{ projectDir: string, port?: number, backendPort?: number }`
- `SessionPromptRequest` type: `{ parts: Array<{ type: "text", text: string }> }`
- `SessionListResponse`, `SessionCreateResponse`, `SessionMessagesResponse` types mirroring SDK responses
- Re-export relevant SDK types: `Session`, `Message`, `Part`, `Event`, `SessionStatus` from `@opencode-ai/sdk`
- Add `PortConfig` type for port detection/acceptance: `{ detect: boolean, autoPort: number, userPort?: number }`

Use existing `createLogger` from `../../lib/logging.js` for all logging. NO console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` â€” zero errors on new files. Verify imports resolve correctly.
  </verify>
  <done>
engine.ts exports startEngine/getClient/stopEngine/getEngineStatus/getActualPort/ensureHealthy with port configuration support. engine-types.ts exports all shared types. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Session Proxy Routes + SSE Relay with Client-Side Filtering to Express Server</name>
  <files>src/dashboard/backend/server.ts</files>
  <action>
Add session proxy routes and SSE relay to existing Express app in `server.ts`. Insert AFTER existing `/api/health` route block. Do NOT rewrite existing routes â€” append new ones.

**Session CRUD routes (all proxy to SDK client):**
- `GET /api/sessions` â€” calls `client.session.list()`, returns `Session[]`. Wrap in try/catch, return `{ error: string }` on failure with HTTP 500.
- `POST /api/sessions` â€” calls `client.session.create({ body: { title } })`, returns new `Session` with HTTP 201. Accept `{ title }` in request body.
- `GET /api/sessions/:id` â€” calls `client.session.get({ path: { id } })`, returns `Session` or 404 if not found.
- `DELETE /api/sessions/:id` â€” calls `client.session.delete({ path: { id } })`, returns `{ success: true }`.
- `GET /api/sessions/:id/messages` â€” calls `client.session.messages({ path: { id } })`, returns `Message[]`.
- `GET /api/sessions/:id/children` â€” calls `client.session.children({ path: { id } })`, returns `Session[]`.
- `POST /api/sessions/:id/abort` â€” calls `client.session.abort({ path: { id } })`, returns `{ success: true }`.
- `GET /api/sessions/:id/status` â€” calls `client.session.status({ path: { id } })`, returns session status.

**SSE streaming endpoint:**
- `POST /api/sessions/:id/prompt` â€” calls `client.session.prompt({ path: { id }, body: req.body })`. This is a streaming call â€” use `for await...of` pattern from SDK. Set headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`.
  - IMPORTANT: Use `client.event.subscribe()` then `client.session.prompt()` pattern. Event subscription MUST happen BEFORE sending prompt to catch all response events.
  - Stream response as SSE: `res.write(\`data: ${JSON.stringify({ type: "event", event })}\n\n\`)`.
  - **Client-side filtering note:** OpenCode broadcasts ALL events to ALL subscribers. Frontend must filter events by sessionID. Document this in API docs.

- `GET /api/events` (optional global SSE relay) â€” Subscribe to `client.event.subscribe()` and relay all events. Add `?sessionID=xxx` query param hint for client-side filtering (server-side filtering not yet available in OpenCode). Handle client disconnect by catching req close event.

**Engine lifecycle routes:**
- `GET /api/engine/status` â€” returns `getEngineStatus()` (includes port for transparency).
- `POST /api/engine/start` â€” accepts `{ projectDir, port }` in request body, calls `startEngine(projectDir, port)`, returns status.
- `POST /api/engine/stop` â€” calls `stopEngine()`, returns `{ success: true }`.
- `POST /api/engine/restart` â€” calls `stopEngine()` then `startEngine(projectDir, port)` for port changes.

**Port configuration:**
- Update `DashboardConfig` interface to include `opencodePort?: number` (user-specified OpenCode port).
- Update `startServer()` to accept `opencodePort` in config.
- If `opencodePort` not provided, prompt user: "OpenCode port (default 4096):" and store in config. For automated startup, read from environment variable `OPENCOD_PORT` (fallback to 4096).
- Pass port to `startEngine(projectDir, opencodePort)`.

Import `getClient`, `startEngine`, `stopEngine`, `getEngineStatus`, `ensureHealthy` from `./engine.js`. Wrap all SDK calls in try/catch â€” return `{ error: string }` with appropriate HTTP status (404 for session not found, 409 for conflict, 500 for SDK errors).

Update `startServer()` function:
- Call `startEngine(config.projectDir, config.opencodePort)` during initialization.
- Add graceful shutdown: on process exit, call `stopEngine()` to cleanup.
- Log actual OpenCode port on startup: `ðŸš€ OpenCode server running on port {actualPort}`.

**SSE Connection Management:**
- Track SSE connections in a `Map<connectionId, Response>`.
- On client disconnect, clean up SDK event subscription after delay (allow drain).
- Use `AbortController` to cancel SDK event subscription when all SSE clients disconnect.
  </action>
  <verify>
Run `npx tsc --noEmit` â€” zero errors. Start dashboard server manually and verify:
- `/api/engine/status` returns `{ running: true, port: 4096 }` (or custom port)
- `GET /api/sessions` returns an array (may be empty)
- `GET /api/events` opens SSE connection (verify with `curl -N` for 5 seconds)
  </verify>
  <done>
All session proxy routes respond with correct HTTP status codes and JSON. SSE relay streams events to browser. Engine starts with configurable port (user can specify or uses default 4096). Graceful shutdown handlers installed. Zero TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm test` â€” existing 814 assertions still pass (no regressions)
3. Manual verification: start dashboard with `OPENCOD_PORT=4190` (test custom port), hit `/api/engine/status` â†’ `{ running: true, port: 4190 }`
4. Manual verification: create session via `POST /api/sessions` â†’ returns 201 with Session object
5. Manual verification: connect SSE to `/api/events?sessionID=xxx` and verify events stream
6. Manual verification: stop dashboard (Ctrl+C) â†’ graceful shutdown, no zombie port binding
</verification>

<success_criteria>
- OpenCode server starts and is reachable through Express proxy
- Port is configurable (user can specify or use default 4096)
- All 9 session routes respond with correct data or structured errors
- SSE relay streams real-time events from OpenCode server to browser with client-side filtering documented
- Engine status endpoint reports running state and actual port
- Graceful shutdown handlers (SIGTERM, SIGINT) prevent ghost port bindings
- Health check method validates server before operations
- Zero TypeScript errors, zero test regressions
- User knows their OpenCode port (logged, configurable)
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-task-bus/01-01-revised-SUMMARY.md`
</output>
