---
phase: 01-engine-task-bus
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dashboard/backend/engine.ts
  - src/dashboard/backend/server.ts
  - src/dashboard/shared/engine-types.ts
autonomous: true

must_haves:
  truths:
    - "OpenCode server starts and returns a reachable URL"
    - "Sessions can be listed, created, and deleted via REST API"
    - "Messages stream to browser via SSE in real-time"
    - "Session prompt sends user message and returns streaming response"
  artifacts:
    - path: "src/dashboard/backend/engine.ts"
      provides: "OpenCode server lifecycle manager + SDK client singleton"
      min_lines: 80
    - path: "src/dashboard/backend/server.ts"
      provides: "Session CRUD routes + SSE relay endpoint"
      exports: ["startServer"]
    - path: "src/dashboard/shared/engine-types.ts"
      provides: "Shared types for engine API requests/responses"
      min_lines: 30
  key_links:
    - from: "src/dashboard/backend/engine.ts"
      to: "@opencode-ai/sdk/server"
      via: "createOpencodeServer + createOpencodeClient"
      pattern: "createOpencodeServer|createOpencodeClient"
    - from: "src/dashboard/backend/server.ts"
      to: "src/dashboard/backend/engine.ts"
      via: "import getClient"
      pattern: "getClient|getEngine"
    - from: "src/dashboard/backend/server.ts"
      to: "browser"
      via: "SSE text/event-stream response"
      pattern: "text/event-stream"
---

<objective>
Create the OpenCode server engine and session proxy API.

Purpose: This is the backbone — the Express backend wraps OpenCode's SDK to provide session management and real-time event streaming to the browser. Without this, no chat, no agents, no streaming.

Output: `engine.ts` (server lifecycle + client singleton), session CRUD routes in `server.ts`, SSE relay endpoint, shared types.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-engine-task-bus/01-RESEARCH.md
@src/dashboard/backend/server.ts
@src/dashboard/shared/schema-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenCode Engine Manager + Shared Types</name>
  <files>src/dashboard/backend/engine.ts, src/dashboard/shared/engine-types.ts</files>
  <action>
Create `src/dashboard/backend/engine.ts` — the OpenCode server lifecycle manager:

1. Import `createOpencodeServer` from `@opencode-ai/sdk/server` and `createOpencodeClient` from `@opencode-ai/sdk`
2. Create a singleton module pattern with:
   - `startEngine(projectDir: string)` — calls `createOpencodeServer()`, creates `OpencodeClient` pointing at the server URL, stores both. Returns `{ url: string }`
   - `getClient()` — returns the `OpencodeClient` instance. Throws if engine not started
   - `stopEngine()` — calls `server.close()`, clears references
   - `getEngineStatus()` — returns `{ running: boolean, url?: string, projectDir?: string }`
3. Add error handling: if `createOpencodeServer()` fails, log via `createLogger` (not console.log!) and throw with context
4. Track compaction counts per session in a `Map<sessionId, number>` — increment when `session.updated` event shows `time.compacting` transitioning from non-null to null

Create `src/dashboard/shared/engine-types.ts`:
- `EngineStatus` type: `{ running: boolean, url?: string, projectDir?: string }`
- `SessionPromptRequest` type: `{ parts: Array<{ type: "text", text: string }> }`
- `SessionListResponse`, `SessionCreateResponse`, `SessionMessagesResponse` types mirroring SDK responses
- Re-export relevant SDK types: `Session`, `Message`, `Part`, `Event` from `@opencode-ai/sdk`

Use the existing `createLogger` from `../../lib/logging.js` for all logging. NO console.log.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors on new files. Verify imports resolve correctly.
  </verify>
  <done>
engine.ts exports startEngine/getClient/stopEngine/getEngineStatus. engine-types.ts exports all shared types. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Session Proxy Routes + SSE Relay to Express Server</name>
  <files>src/dashboard/backend/server.ts</files>
  <action>
Add session proxy routes to the existing Express app in `server.ts`. Insert AFTER the existing `/api/health` route block. Do NOT rewrite existing routes — append new ones.

**Session CRUD routes (all proxy to SDK client):**
- `GET /api/sessions` — calls `client.session.list()`, returns `Session[]`
- `POST /api/sessions` — calls `client.session.create({ body: { path: projectDir } })`, returns new `Session`
- `GET /api/sessions/:id` — calls `client.session.get({ path: { id } })`, returns `Session`
- `DELETE /api/sessions/:id` — calls `client.session.delete({ path: { id } })`
- `GET /api/sessions/:id/messages` — calls `client.session.messages({ path: { id } })`, returns `Message[]`
- `POST /api/sessions/:id/prompt` — calls `client.session.prompt({ path: { id }, body: req.body })`. This is a streaming call — read the async iterable from the SDK and pipe each chunk as SSE to the response. Set headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`
- `POST /api/sessions/:id/abort` — calls `client.session.abort({ path: { id } })`
- `GET /api/sessions/:id/status` — calls `client.session.status({ path: { id } })`
- `GET /api/sessions/:id/children` — calls `client.session.children({ path: { id } })`

**Global SSE relay:**
- `GET /api/events` — Opens SSE connection. Calls `client.global.event()` and relays each event as `data: {JSON}\n\n`. Handle client disconnect by aborting the SDK stream (use `AbortController`). Set `retry: 3000` for auto-reconnect.

**Engine lifecycle routes:**
- `GET /api/engine/status` — returns `getEngineStatus()`
- `POST /api/engine/start` — calls `startEngine(configuredProjectDir)`, returns status

Import `getClient`, `startEngine`, `getEngineStatus` from `./engine.js`. Wrap all SDK calls in try/catch — return `{ error: string }` with appropriate HTTP status (404 for session not found, 500 for SDK errors).

Update `startServer()` function to call `startEngine(config.projectDir)` during initialization — the OpenCode server starts when the dashboard starts.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. Start the dashboard server manually and verify `/api/engine/status` returns `{ running: true }`. Test `GET /api/sessions` returns an array (may be empty).
  </verify>
  <done>
All session proxy routes respond. SSE relay endpoint streams events. Engine starts automatically with dashboard. Error responses are structured JSON with appropriate HTTP status codes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm test` — existing 814 assertions still pass (no regressions)
3. Manual verification: start dashboard, hit `/api/engine/status` → `{ running: true }`
4. Manual verification: `GET /api/sessions` returns `[]` or existing sessions
5. Manual verification: `GET /api/events` opens SSE connection (verify with `curl -N`)
</verification>

<success_criteria>
- OpenCode server starts and is reachable through Express proxy
- All 9 session routes respond with correct data or structured errors
- SSE relay streams real-time events from OpenCode server to browser
- Engine status endpoint reports running state
- Zero TypeScript errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01-engine-task-bus/01-01-SUMMARY.md`
</output>
