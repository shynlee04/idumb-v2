---
phase: 05-framework-foundation
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/shared/ide-types.ts
  - app/db/schema.ts
  - app/db/index.ts
  - drizzle.config.ts
  - app/server/settings.ts
autonomous: true

must_haves:
  truths:
    - "Settings persist across dev server restarts in SQLite"
    - "Drizzle ORM reads and writes settings table with type-safe queries"
    - "Database file exists at .idumb/data/idumb.db after first write"
    - "Shared type contracts define all Phase 5 data shapes in one module"
  artifacts:
    - path: "app/db/schema.ts"
      provides: "Drizzle schema — settings + workspace_config tables"
      contains: "sqliteTable"
    - path: "app/db/index.ts"
      provides: "Database client singleton"
      exports: ["db"]
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit migration configuration"
      contains: "defineConfig"
    - path: "app/shared/ide-types.ts"
      provides: "Shared type contracts re-exporting engine types + adding Phase 5 types"
      exports: ["SettingsEntry", "WorkspaceConfig"]
    - path: "app/server/settings.ts"
      provides: "Settings CRUD server functions"
      exports: ["getSettingFn", "setSettingFn", "getAllSettingsFn"]
  key_links:
    - from: "app/server/settings.ts"
      to: "app/db/index.ts"
      via: "import db singleton for queries"
      pattern: "import.*db.*from.*db"
    - from: "app/server/settings.ts"
      to: "app/db/schema.ts"
      via: "import table references for type-safe queries"
      pattern: "import.*settings.*from.*schema"
    - from: "app/db/index.ts"
      to: "app/db/schema.ts"
      via: "schema passed to drizzle() for relational queries"
      pattern: "drizzle.*schema"
---

<objective>
Create shared type contracts (ide-types.ts) and the Drizzle ORM data layer with SQLite for persistent settings and workspace config. Establish the schema-first development pattern that all future phases build on.

Purpose: Delivers FND-03 (shared type contracts) and FND-04 (schema-first data layer). Settings and workspace config persist in SQLite — the first data that survives server restarts. This pattern extends to all persistent state in future phases.
Output: Working Drizzle ORM pipeline (schema -> migration -> query), shared types module, settings persistence server functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-framework-foundation/05-CONTEXT.md
@.planning/phases/05-framework-foundation/05-RESEARCH.md
@.planning/phases/05-framework-foundation/05-01-SUMMARY.md
@src/dashboard/shared/engine-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared Types + Drizzle Schema + Database Client + Migrations</name>
  <files>
    app/shared/ide-types.ts
    app/db/schema.ts
    app/db/index.ts
    drizzle.config.ts
  </files>
  <action>
    **1. Create app/shared/ide-types.ts — consolidated type contracts:**
    ```typescript
    /**
     * IDE Type Contracts — shared between server functions and frontend.
     *
     * Phase 5: Engine, Session, Settings, WorkspaceConfig types.
     * Phase 6+: File, Terminal, Editor types will be added when consumers exist.
     * Rule: max 50 LOC per feature, must have consumer in same phase.
     */

    // Re-export all existing engine types for backward compatibility
    export type {
      ModelInfo,
      ProviderInfo,
      AgentInfo,
      AppInfo,
      EngineStatus,
      DashboardConfig,
      PortConfig,
      SessionPromptRequest,
      SessionListResponse,
      SessionCreateResponse,
      SessionMessagesResponse,
      SessionStatusResponse,
      SessionChildrenResponse,
      EngineErrorResponse,
    } from './engine-types'

    // Re-export SDK types
    export type {
      Session,
      Message,
      Part,
      Event,
      SessionStatus,
    } from '@opencode-ai/sdk'

    // Phase 5 additions — consumed by Drizzle schema + settings server functions

    /** A single key-value setting persisted in SQLite */
    export interface SettingsEntry {
      key: string
      value: string
      updatedAt: Date | null
    }

    /** Workspace configuration per project directory */
    export interface WorkspaceConfig {
      projectDir: string
      name: string | null
      lastOpened: Date | null
      config: Record<string, unknown> | null
    }
    ```
    Do NOT add File, Terminal, Editor types — no consumer until Phase 6 (per schema budget decision: "max 50 LOC per feature, must have consumer in same phase").
    Target: ~40 LOC

    **2. Create app/db/schema.ts — Drizzle ORM schema:**
    ```typescript
    import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core'

    /**
     * Settings — key-value store for app preferences, UI state, model config.
     * Consumed by: settings server functions (Phase 5), settings UI (Phase 7).
     */
    export const settings = sqliteTable('settings', {
      id: integer('id').primaryKey({ autoIncrement: true }),
      key: text('key').notNull().unique(),
      value: text('value').notNull(),
      updatedAt: integer('updated_at', { mode: 'timestamp' }),
    })

    /**
     * Workspace Config — per-project metadata for multi-project support.
     * Consumed by: workspace switching (Phase 6+).
     */
    export const workspaceConfig = sqliteTable('workspace_config', {
      id: integer('id').primaryKey({ autoIncrement: true }),
      projectDir: text('project_dir').notNull().unique(),
      name: text('name'),
      lastOpened: integer('last_opened', { mode: 'timestamp' }),
      config: text('config'), // JSON blob — parsed by server functions
    })
    ```
    Two tables, ~25 LOC. Well within schema budget.

    **3. Create drizzle.config.ts at project root:**
    ```typescript
    import { defineConfig } from 'drizzle-kit'

    export default defineConfig({
      dialect: 'sqlite',
      schema: './app/db/schema.ts',
      out: './drizzle',
      dbCredentials: {
        url: './.idumb/data/idumb.db',
      },
    })
    ```
    CRITICAL: Use `defineConfig()` from `drizzle-kit` (not `satisfies Config`). No `driver` field needed — Drizzle Kit infers better-sqlite3 from dialect + url pattern.

    **4. Create app/db/index.ts — database client singleton:**
    ```typescript
    import Database from 'better-sqlite3'
    import { drizzle } from 'drizzle-orm/better-sqlite3'
    import { existsSync, mkdirSync } from 'fs'
    import { dirname } from 'path'
    import * as schema from './schema'

    const DB_PATH = '.idumb/data/idumb.db'

    // Ensure directory exists
    const dbDir = dirname(DB_PATH)
    if (!existsSync(dbDir)) {
      mkdirSync(dbDir, { recursive: true })
    }

    const sqlite = new Database(DB_PATH)

    // Enable WAL mode for better concurrent read performance
    sqlite.pragma('journal_mode = WAL')

    export const db = drizzle({ client: sqlite, schema })
    ```
    CRITICAL: Use `drizzle({ client: sqlite, schema })` (object syntax, not positional args). This is the current API as of drizzle-orm v0.45.1.

    **5. Generate and apply migrations:**
    ```bash
    npx drizzle-kit generate    # Creates SQL migration in ./drizzle/
    npx drizzle-kit migrate     # Applies migration to .idumb/data/idumb.db
    ```
    Verify: `./drizzle/` directory contains at least one SQL migration file. `.idumb/data/idumb.db` file exists.

    **6. Add .gitignore entries (if not already present):**
    - `.idumb/data/` — SQLite database files are per-instance, not committed
    - But `drizzle/` (migration SQL files) SHOULD be committed — they define the schema evolution
  </action>
  <verify>
    - app/shared/ide-types.ts exists and re-exports all engine-types + adds SettingsEntry, WorkspaceConfig
    - app/db/schema.ts exists with settings and workspace_config table definitions
    - app/db/index.ts exists and exports `db` singleton
    - drizzle.config.ts exists at project root
    - `npx drizzle-kit generate` runs without errors (migration files created in ./drizzle/)
    - `npx drizzle-kit migrate` runs without errors (database created/updated)
    - .idumb/data/idumb.db file exists
    - `npx tsc --noEmit -p tsconfig.app.json` — zero type errors in db/ and shared/ files
  </verify>
  <done>
    Drizzle ORM pipeline operational: schema defined, migration generated and applied, database client singleton ready, shared type contracts consolidate all Phase 5 data shapes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings Server Functions + Persistence Verification</name>
  <files>
    app/server/settings.ts
  </files>
  <action>
    **1. Create app/server/settings.ts — settings CRUD server functions:**
    ```typescript
    import { createServerFn } from '@tanstack/react-start'
    import { db } from '@/db'
    import { settings } from '@/db/schema'
    import { eq } from 'drizzle-orm'

    /**
     * Get a single setting by key. Returns the value string or null.
     */
    export const getSettingFn = createServerFn()
      .validator((d: { key: string }) => d)
      .handler(async ({ data }) => {
        try {
          const result = await db
            .select()
            .from(settings)
            .where(eq(settings.key, data.key))
            .limit(1)

          return { value: result[0]?.value ?? null }
        } catch (e) {
          return { value: null, error: String(e) }
        }
      })

    /**
     * Set a setting (upsert — insert or update on conflict).
     */
    export const setSettingFn = createServerFn({ method: 'POST' })
      .validator((d: { key: string; value: string }) => d)
      .handler(async ({ data }) => {
        try {
          await db
            .insert(settings)
            .values({
              key: data.key,
              value: data.value,
              updatedAt: new Date(),
            })
            .onConflictDoUpdate({
              target: settings.key,
              set: {
                value: data.value,
                updatedAt: new Date(),
              },
            })

          return { success: true }
        } catch (e) {
          return { success: false, error: String(e) }
        }
      })

    /**
     * Get all settings as a key-value record.
     */
    export const getAllSettingsFn = createServerFn()
      .handler(async () => {
        try {
          const rows = await db.select().from(settings)
          const record: Record<string, string> = {}
          for (const row of rows) {
            record[row.key] = row.value
          }
          return { settings: record }
        } catch (e) {
          return { settings: {}, error: String(e) }
        }
      })

    /**
     * Delete a setting by key.
     */
    export const deleteSettingFn = createServerFn({ method: 'POST' })
      .validator((d: { key: string }) => d)
      .handler(async ({ data }) => {
        try {
          await db.delete(settings).where(eq(settings.key, data.key))
          return { success: true }
        } catch (e) {
          return { success: false, error: String(e) }
        }
      })
    ```
    Target: ~80 LOC. All server functions wrapped in try/catch.

    Note on Drizzle query API: `db.select().from(settings)` uses the query builder (not `db.query.settings.findMany()`). Both work, but the query builder is more explicit and works without relational config. Use whichever is cleaner; if using relational queries (`db.query`), ensure the schema is passed to `drizzle()` in db/index.ts (it is).

    **2. Verify persistence round-trip:**
    After creating settings.ts, verify it works by doing a quick manual test or creating a temporary test script.

    Option A — Manual test via dev server:
    - Start `npm run dev:app`
    - In browser console or via a temporary route, call:
      ```javascript
      // From a component or route loader
      import { setSettingFn, getSettingFn } from '@/server/settings'
      await setSettingFn({ data: { key: 'test.phase5', value: 'works' } })
      const result = await getSettingFn({ data: { key: 'test.phase5' } })
      console.log(result) // Should print { value: 'works' }
      ```
    - Restart dev server
    - Call getSettingFn again — value should persist

    Option B — Script test:
    Create a temporary `scripts/test-db.ts`:
    ```typescript
    import { db } from '../app/db/index.ts'
    import { settings } from '../app/db/schema.ts'
    import { eq } from 'drizzle-orm'

    // Write
    db.insert(settings).values({ key: 'test', value: 'hello', updatedAt: new Date() })
      .onConflictDoUpdate({ target: settings.key, set: { value: 'hello' } })
      .run()

    // Read
    const result = db.select().from(settings).where(eq(settings.key, 'test')).all()
    console.log('Result:', result)

    // Cleanup
    db.delete(settings).where(eq(settings.key, 'test')).run()
    console.log('Persistence verified!')
    ```
    Run: `npx tsx scripts/test-db.ts`
    Delete the test script after verification.

    **3. Verify database file:**
    - `.idumb/data/idumb.db` exists and is a valid SQLite database
    - `sqlite3 .idumb/data/idumb.db ".tables"` should show `settings` and `workspace_config`
  </action>
  <verify>
    - app/server/settings.ts exists with getSettingFn, setSettingFn, getAllSettingsFn, deleteSettingFn exports
    - Settings round-trip works: write a value, read it back, get same value
    - Persistence survives restart: write value, restart dev server, read value — still present
    - .idumb/data/idumb.db contains `settings` and `workspace_config` tables
    - `npx tsc --noEmit -p tsconfig.app.json` — zero type errors
    - No console.log in production code (test script is temporary and deleted)
  </verify>
  <done>
    Drizzle ORM data layer fully operational. Settings persist in SQLite across server restarts. Server functions provide typed CRUD for settings. Database at .idumb/data/idumb.db with auto-generated migrations. workspace_config table ready for Phase 6+ use.
  </done>
</task>

</tasks>

<verification>
**Phase-level checks for Plan 03:**
1. `npx drizzle-kit generate` produces clean migrations
2. `npx drizzle-kit migrate` applies without errors
3. Settings write -> read -> restart -> read roundtrip works
4. .idumb/data/idumb.db has correct tables (settings, workspace_config)
5. ide-types.ts re-exports all engine types + adds Phase 5 types
6. No schema bloat: only types with Phase 5 consumers exist
</verification>

<success_criteria>
- Drizzle ORM reads and writes SQLite tables with type-safe queries
- Settings persist across dev server restarts
- Shared type contracts consolidate all Phase 5 data shapes in one importable module
- Migration files tracked in drizzle/ directory
- Schema budget respected: only SettingsEntry and WorkspaceConfig added (both consumed in this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/05-framework-foundation/05-03-SUMMARY.md`
</output>
