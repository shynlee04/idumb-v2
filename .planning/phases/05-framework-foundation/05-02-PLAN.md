---
phase: 05-framework-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/server/sdk-client.server.ts
  - app/server/engine.ts
  - app/server/sessions.ts
  - app/server/config.ts
  - app/server/validators.ts
  - app/routes/api/sessions.$id.prompt.ts
  - app/routes/api/events.ts
  - app/hooks/useEngine.ts
  - app/hooks/useSession.ts
  - app/hooks/useStreaming.ts
  - app/hooks/useEventStream.tsx
autonomous: false

must_haves:
  truths:
    - "User sends a chat message and sees AI response stream via SSE"
    - "User starts and stops the OpenCode engine from the UI"
    - "User creates, lists, switches, and deletes sessions"
    - "Engine auto-starts when dev server boots — no manual engine setup"
    - "No Express route handlers exist — all transport via server functions and server routes"
  artifacts:
    - path: "app/server/sdk-client.ts"
      provides: "OpenCode SDK client singleton with connect-or-start lifecycle"
      exports: ["getClient", "startEngine", "stopEngine", "getEngineStatus"]
    - path: "app/server/sessions.ts"
      provides: "Session CRUD server functions"
      exports: ["getSessionsFn", "createSessionFn", "getSessionFn", "deleteSessionFn", "getSessionMessagesFn"]
    - path: "app/server/engine.ts"
      provides: "Engine lifecycle server functions"
      exports: ["getEngineStatusFn", "startEngineFn", "stopEngineFn"]
    - path: "app/routes/api/sessions.$id.prompt.ts"
      provides: "SSE server route for chat response streaming"
      contains: "text/event-stream"
    - path: "app/routes/api/events.ts"
      provides: "SSE server route for global event relay"
      contains: "text/event-stream"
  key_links:
    - from: "app/hooks/useStreaming.ts"
      to: "app/routes/api/sessions.$id.prompt.ts"
      via: "fetch with SSE EventSource pattern"
      pattern: "text/event-stream|EventSource|fetch.*api.*sessions.*prompt"
    - from: "app/server/sessions.ts"
      to: "app/server/sdk-client.ts"
      via: "getClient() for SDK operations"
      pattern: "getClient\\(\\)"
    - from: "app/hooks/useEngine.ts"
      to: "app/server/engine.ts"
      via: "direct server function import and call"
      pattern: "import.*from.*server/engine"
    - from: "app/routes/api/sessions.$id.prompt.ts"
      to: "app/server/sdk-client.ts"
      via: "getClient() for event subscription"
      pattern: "getClient\\(\\)"
---

<objective>
Migrate all Express routes to TanStack Start server functions and server routes. Establish SSE streaming for chat responses and global events. Update frontend hooks to call server functions directly. Prove the critical path: engine auto-start, session management, and working chat with streamed AI responses.

Purpose: This is the functional proof that TanStack Start can replace Express for the entire application transport layer. After this plan, a user can send a message and see an AI response — the "it works" moment.
Output: Working end-to-end chat flow with no Express dependency. Server functions for all API operations. SSE server routes for streaming.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-framework-foundation/05-CONTEXT.md
@.planning/phases/05-framework-foundation/05-RESEARCH.md
@.planning/phases/05-framework-foundation/05-01-SUMMARY.md
@src/dashboard/backend/server.ts
@src/dashboard/backend/engine.ts
@src/dashboard/shared/engine-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server Functions for Engine + Sessions + Config</name>
  <files>
    app/server/sdk-client.ts
    app/server/engine.ts
    app/server/sessions.ts
    app/server/config.ts
  </files>
  <action>
    **1. Create app/server/sdk-client.server.ts — SDK client singleton:**
    NAMING: Use `.server.ts` suffix to prevent client-side import. TanStack Start tree-shakes `.server.ts` files from the client bundle. This module contains native Node.js imports (@opencode-ai/sdk) that MUST NOT leak to the browser.
    Extract the connect-or-start pattern from `src/dashboard/backend/engine.ts` (235 LOC). This module owns the OpenCode SDK client lifecycle.

    Exports:
    - `getClient(): OpencodeClient` — returns initialized client, throws if not connected
    - `ensureEngine(projectDir?: string): Promise<void>` — connect to existing OpenCode server or start a new one. Uses `createOpencodeClient` to try connecting first, then `createOpencode` to start a new server if needed.
    - `getEngineStatus(): EngineStatus` — returns { running, url, port, projectDir }
    - `stopEngine(): Promise<void>` — gracefully stops the engine if we started it

    Implementation notes:
    - Import `createOpencode`, `createOpencodeClient` from `@opencode-ai/sdk`
    - Keep the connect-first-then-start pattern from engine.ts
    - Module-level state for client singleton, engine handle, project dir
    - Auto-detect project directory from process.cwd() if not specified
    - NO console.log — use a file-based logger (import `createLogger` from the plugin's `src/lib/logging.ts` or create a minimal app logger)
    - Target: ~100-120 LOC
    - IMPORTANT: All imports of this file in other server files must use `'./sdk-client.server'` (with the `.server` suffix)

    **2. Create app/server/engine.ts — engine lifecycle server functions:**
    NOTE (file-separation convention): TanStack Start conventionally uses `.functions.ts` suffix for
    files containing server functions (e.g., `engine.functions.ts`). We use the `app/server/` directory
    approach instead, which is equally valid. Be consistent — if this project uses `app/server/`, all
    server function files go there WITHOUT the `.functions.ts` suffix.
    ```typescript
    import { createServerFn } from '@tanstack/react-start'
    import { ensureEngine, getEngineStatus, stopEngine } from './sdk-client.server'

    export const getEngineStatusFn = createServerFn()
      .handler(async () => {
        try {
          return getEngineStatus()
        } catch (e) {
          return { running: false, error: String(e) }
        }
      })

    export const startEngineFn = createServerFn({ method: 'POST' })
      .handler(async () => {
        try {
          await ensureEngine()
          return { success: true, ...getEngineStatus() }
        } catch (e) {
          return { success: false, error: String(e) }
        }
      })

    export const stopEngineFn = createServerFn({ method: 'POST' })
      .handler(async () => {
        try {
          await stopEngine()
          return { success: true }
        } catch (e) {
          return { success: false, error: String(e) }
        }
      })

    export const restartEngineFn = createServerFn({ method: 'POST' })
      .handler(async () => {
        try {
          await stopEngine()
          await ensureEngine()
          return { success: true, ...getEngineStatus() }
        } catch (e) {
          return { success: false, error: String(e) }
        }
      })
    ```
    CRITICAL: Wrap ALL handlers in try/catch. Per research: "Middleware doesn't catch server function errors." Return error objects, never throw unhandled.
    Target: ~60-80 LOC

    **3. Create app/server/sessions.ts — session CRUD server functions:**
    Extract session operations from `src/dashboard/backend/server.ts` lines ~350-700.

    Server functions to create (all using `createServerFn`):

    **CRITICAL (sf-input-validation):** All validators MUST use Zod schemas, NOT inline type assertions.
    Inline `(d: { key: string }) => d` provides ZERO runtime validation — it's an identity function.
    Create a shared validators file first:

    ```typescript
    // app/server/validators.ts — Shared Zod schemas for server function inputs
    import { z } from 'zod'

    export const SessionIdSchema = z.object({ sessionId: z.string().min(1) })
    export const CreateSessionSchema = z.object({ name: z.string().optional() })
    ```

    Then use in each server function:
    - `getSessionsFn` (GET): calls `getClient().session.list()`, returns `{ sessions: Session[] }`
    - `createSessionFn` (POST, `.validator(CreateSessionSchema)`): calls `getClient().session.create()`, returns `{ session: Session }`
    - `getSessionFn` (GET, `.validator(SessionIdSchema)`): calls `getClient().session.get(sessionId)`, returns session object
    - `deleteSessionFn` (POST, `.validator(SessionIdSchema)`): calls `getClient().session.delete(sessionId)`, returns `{ success: true }`
    - `getSessionMessagesFn` (GET, `.validator(SessionIdSchema)`): calls `getClient().session.messages(sessionId)`, returns `{ messages }`
    - `abortSessionFn` (POST, `.validator(SessionIdSchema)`): calls `getClient().session.abort(sessionId)`, returns `{ success: true }`
    - `getSessionStatusFn` (GET, `.validator(SessionIdSchema)`): returns session's current status
    - `getSessionChildrenFn` (GET, `.validator(SessionIdSchema)`): returns child sessions

    Pattern for each: try/catch wrapper, return typed response or `{ error: string }`.
    Refer to `server.ts` for exact SDK method names and response normalization.
    Target: ~150-180 LOC

    **4. Create app/server/config.ts — configuration server functions:**
    Extract from `src/dashboard/backend/server.ts` lines ~82-200.

    Server functions:
    - `healthCheckFn` (GET): returns `{ status: 'ok', timestamp: Date.now() }`
    - `getProvidersFn` (GET): calls `getClient().config.providers()`, normalizes into `ProviderInfo[]`
    - `getAgentsFn` (GET): calls `getClient().config.agents()` or equivalent, returns `AgentInfo[]`
    - `getConfigFn` (GET): returns merged config
    - `getAppInfoFn` (GET): calls `getClient().app.get()`, returns `AppInfo`

    Import types from `@/shared/engine-types` (moved to app/shared/ in Plan 01).
    Target: ~80-100 LOC
  </action>
  <verify>
    - All 5 files exist in app/server/ (sdk-client.server.ts, engine.ts, sessions.ts, config.ts, validators.ts)
    - `npx tsc --noEmit -p tsconfig.app.json` — zero type errors in server function files
    - Each server function uses createServerFn with try/catch wrapping
    - All server functions with inputs use `.validator(ZodSchema)` — NO inline type assertions
    - validators.ts exports Zod schemas used by sessions.ts and config.ts
    - No import of `express` anywhere in app/server/
    - sdk-client.server.ts exports getClient, ensureEngine, getEngineStatus, stopEngine
    - sessions.ts exports at least 5 server functions (getSessionsFn, createSessionFn, getSessionFn, deleteSessionFn, getSessionMessagesFn)
  </verify>
  <done>
    All Express route handlers from server.ts (Phase 5 critical path: engine, sessions, config, health) are replaced by server functions. SDK client singleton extracted and importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSE Server Routes + Frontend Hook Migration + Engine Auto-start</name>
  <files>
    app/routes/api/sessions.$id.prompt.ts
    app/routes/api/events.ts
    app/hooks/useEngine.ts
    app/hooks/useSession.ts
    app/hooks/useStreaming.ts
    app/hooks/useEventStream.tsx
  </files>
  <action>
    **1. Create SSE server route for chat streaming:**
    `app/routes/api/sessions.$id.prompt.ts`

    ```typescript
    import { createFileRoute } from '@tanstack/react-router'
    import { getClient, ensureEngine } from '@/server/sdk-client'

    export const Route = createFileRoute('/api/sessions/$id/prompt')({
      server: {
        handlers: {
          POST: async ({ request, params }) => {
            try {
              await ensureEngine()
              const client = getClient()
              const { id } = params
              const body = await request.json()
              const parts = body.parts || []

              // Send prompt to session via SDK
              // The exact SDK method: client.chat.send() or client.session.prompt()
              // Check src/dashboard/backend/server.ts ~line 850 for the actual pattern

              const stream = new ReadableStream({
                async start(controller) {
                  const encoder = new TextEncoder()
                  try {
                    // Subscribe to SDK events for this session
                    const subscription = client.event.subscribe()
                    for await (const event of subscription) {
                      // Filter events for this session
                      const data = `data: ${JSON.stringify(event)}\n\n`
                      controller.enqueue(encoder.encode(data))
                      // Break when session completes (check event type)
                    }
                  } catch (err) {
                    const errorData = `data: ${JSON.stringify({ type: 'error', error: String(err) })}\n\n`
                    controller.enqueue(encoder.encode(errorData))
                  } finally {
                    controller.close()
                  }
                },
              })

              return new Response(stream, {
                headers: {
                  'Content-Type': 'text/event-stream',
                  'Cache-Control': 'no-cache',
                  'Connection': 'keep-alive',
                },
              })
            } catch (err) {
              return new Response(JSON.stringify({ error: String(err) }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' },
              })
            }
          },
        },
      },
    })
    ```

    CRITICAL: Use `createFileRoute` from `@tanstack/react-router` with `server.handlers` — there is NO `createServerFileRoute` function (confirmed in research). Server routes return raw Response objects — the framework passes them through without NDJSON wrapping. This is why SSE works here but NOT via server function streaming.

    Reference `src/dashboard/backend/server.ts` lines ~800-1000 for the exact SSE event subscription pattern, prompt sending logic, and event filtering.

    **2. Create SSE server route for global events:**
    `app/routes/api/events.ts`

    ```typescript
    import { createFileRoute } from '@tanstack/react-router'
    import { getClient, ensureEngine } from '@/server/sdk-client'

    export const Route = createFileRoute('/api/events')({
      server: {
        handlers: {
          GET: async ({ request }) => {
            try {
              await ensureEngine()
              const client = getClient()

              const stream = new ReadableStream({
                async start(controller) {
                  const encoder = new TextEncoder()
                  try {
                    const subscription = client.event.subscribe()
                    for await (const event of subscription) {
                      const data = `data: ${JSON.stringify(event)}\n\n`
                      controller.enqueue(encoder.encode(data))
                    }
                  } catch (err) {
                    controller.close()
                  }
                },
                cancel() {
                  // Cleanup subscription on client disconnect
                },
              })

              return new Response(stream, {
                headers: {
                  'Content-Type': 'text/event-stream',
                  'Cache-Control': 'no-cache',
                  'Connection': 'keep-alive',
                },
              })
            } catch (err) {
              return new Response(JSON.stringify({ error: String(err) }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' },
              })
            }
          },
        },
      },
    })
    ```

    **3. Migrate frontend hooks to use server functions:**

    `app/hooks/useEngine.ts` (currently 126 LOC):
    - Remove all `fetch('/api/engine/...')` calls
    - Import server functions: `import { getEngineStatusFn, startEngineFn, stopEngineFn, restartEngineFn } from '@/server/engine'`
    - Replace fetch calls with direct server function calls:
      - `fetch('/api/engine/status')` -> `getEngineStatusFn()`
      - `fetch('/api/engine/start', { method: 'POST' })` -> `startEngineFn()`
      - etc.
    - Server functions are called directly from the client — TanStack Start handles the RPC transport automatically
    - Keep the React Query hooks (useQuery, useMutation) — just change the query/mutation functions

    `app/hooks/useSession.ts` (currently 69 LOC):
    - Replace `fetch('/api/sessions/...')` with server function imports from `@/server/sessions`
    - `getSessionsFn()`, `createSessionFn({ data: { name } })`, `deleteSessionFn({ data: { sessionId } })`, etc.
    - Keep React Query hooks

    `app/hooks/useStreaming.ts` (currently 173 LOC):
    - The SSE streaming hook uses fetch or EventSource to connect to `/api/sessions/:id/prompt`
    - This URL path stays the same (it's now a server route, not Express) — the SSE connection pattern is identical
    - Update the URL if needed (e.g., from proxy-based `/api/sessions/${id}/prompt` to absolute URL or same path)
    - The fetch-based SSE pattern (POST with ReadableStream response) should work unchanged since server routes are pass-through
    - Verify the response handling matches: `data: JSON\n\n` format

    `app/hooks/useEventStream.tsx` (currently 92 LOC):
    - Uses EventSource for `/api/events`
    - URL path stays the same — server route replaces Express endpoint
    - Should work with minimal changes (path might need adjustment)

    **4. Engine auto-start:**
    Add auto-start logic so the engine starts when the dev server boots, not when the user clicks "start."

    Options (choose the simplest that works):
    a) In `app/routes/__root.tsx`, add a server-side `beforeLoad` that calls `ensureEngine()`:
       ```typescript
       export const Route = createRootRoute({
         beforeLoad: async () => {
           // This runs on the server for every navigation
           // Only need to start once — ensureEngine is idempotent
           await ensureEngine()
         },
         component: RootLayout,
       })
       ```
       NOTE: In SPA mode, beforeLoad may run on the client. If so, use a server function:
       ```typescript
       const ensureEngineFn = createServerFn().handler(async () => {
         await ensureEngine()
         return getEngineStatus()
       })
       ```
       Call this from the root route's beforeLoad or from the first server function call.
    b) Make `getClient()` in sdk-client.ts auto-call `ensureEngine()` on first access (lazy init).

    The goal: user runs `npm run dev:app`, opens browser, and the engine is already running. No manual "start engine" step needed.

    **5. Verify the complete flow:**
    - Start dev server
    - Open browser, navigate to /chat
    - Engine should be running (check UI status indicator)
    - Create a session (if none exists)
    - Type a message and send
    - See SSE response stream — text appears progressively
    - Session list updates
  </action>
  <verify>
    - SSE routes exist: app/routes/api/sessions.$id.prompt.ts and app/routes/api/events.ts
    - Both SSE routes set Content-Type: text/event-stream
    - Frontend hooks import from @/server/* (not fetch('/api/...'))
    - useStreaming.ts connects to SSE endpoint (fetch or EventSource pattern)
    - Engine auto-starts on dev server boot
    - `npx tsc --noEmit -p tsconfig.app.json` — zero type errors
    - No imports of `express` or `cors` anywhere in app/ directory
    - `npm run dev:app` starts successfully
  </verify>
  <done>
    All Express routes replaced. SSE streaming works through server routes. Frontend hooks call server functions directly. Engine auto-starts. The complete transport chain is proven: browser -> server function/route -> OpenCode SDK -> SSE -> browser.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Working Chat End-to-End</name>
  <what-built>
    Complete TanStack Start migration replacing Express. Server functions handle engine lifecycle and session CRUD. SSE server routes handle chat streaming and global events. Engine auto-starts on dev server boot. Frontend hooks call server functions directly — no fetch('/api/...') pattern.
  </what-built>
  <how-to-verify>
    1. Run `npm run dev:app` — dev server should start and engine should connect/start automatically
    2. Open browser at the localhost URL shown in terminal
    3. You should see the AppShell layout with sidebar navigation
    4. Navigate to /chat — ChatPage should load
    5. If no session exists, create one (the UI should allow this)
    6. Type "hello" or any message and press send
    7. Watch for the AI response — it should stream in progressively (not appear all at once)
    8. Verify engine status shows "running" in the UI
    9. Try stopping and restarting the engine from the UI
    10. Create another session, switch between sessions
    11. Delete a session — it should disappear from the list
    12. Open browser dev tools Network tab — confirm requests go to server functions (not Express), and SSE connections show text/event-stream content type
    13. Confirm: no Express server process running (only the Vite/TanStack Start dev server)
  </how-to-verify>
  <resume-signal>Type "approved" if working chat is confirmed, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
**Phase-level checks for Plan 02:**
1. Zero Express route handlers — all replaced by server functions and server routes
2. SSE streaming works: POST /api/sessions/:id/prompt returns text/event-stream
3. Global events: GET /api/events returns text/event-stream
4. Engine lifecycle: start/stop/status via server functions
5. Session CRUD: create/list/get/delete/messages via server functions
6. Frontend hooks use direct server function imports (not fetch)
7. Engine auto-starts — no manual setup required
</verification>

<success_criteria>
- User sends a chat message and sees AI response stream via SSE through TanStack Start server routes
- All Phase 5 critical path operations work: engine start/stop, session CRUD, chat streaming, event relay
- No Express dependency in the transport chain
- Frontend hooks call server functions directly (typed, no manual fetch)
</success_criteria>

<output>
After completion, create `.planning/phases/05-framework-foundation/05-02-SUMMARY.md`
</output>
