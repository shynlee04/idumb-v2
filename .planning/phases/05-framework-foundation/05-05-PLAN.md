---
phase: 05-framework-foundation
plan: 05
type: execute
wave: 1
depends_on: ["05-04"]
files_modified:
  - app/lib/utils.ts
  - app/components/chat/ChatMessage.tsx
  - app/components/chat/ChatInput.tsx
  - app/components/chat/ChatMessages.tsx
  - app/components/layout/SessionSidebar.tsx
  - app/components/layout/EngineStatus.tsx
  - app/routes/chat.tsx
  - app/routes/chat.$sessionId.tsx
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "User can send a chat message and see a streaming AI response via SSE"
    - "Chat responses render with basic markdown (headers, bold, code blocks)"
    - "User can create new chat sessions, switch between them, and delete them"
    - "User can see whether the OpenCode engine is connected and start/stop it"
  artifacts:
    - path: "app/routes/chat.$sessionId.tsx"
      provides: "Full chat page with streaming, message history, and input"
      contains: "useStreaming"
    - path: "app/routes/chat.tsx"
      provides: "Chat layout with session sidebar and engine status"
      contains: "SessionSidebar"
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Single message rendering with react-markdown"
      contains: "ReactMarkdown"
    - path: "app/components/chat/ChatInput.tsx"
      provides: "Message input textarea with send and abort controls"
      contains: "sendPrompt"
    - path: "app/components/chat/ChatMessages.tsx"
      provides: "Scrollable message list with auto-scroll on new messages"
      contains: "ChatMessage"
    - path: "app/components/layout/SessionSidebar.tsx"
      provides: "Session list with create, switch, and delete"
      contains: "useSessions"
    - path: "app/components/layout/EngineStatus.tsx"
      provides: "Engine connection indicator with start/stop toggle"
      contains: "useEngineStatus"
  key_links:
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/hooks/useStreaming.ts"
      via: "import useStreaming, call sendPrompt(text)"
      pattern: "useStreaming.*sendPrompt"
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/hooks/useSession.ts"
      via: "import useSessionMessages for message history"
      pattern: "useSessionMessages"
    - from: "app/components/layout/SessionSidebar.tsx"
      to: "app/hooks/useSession.ts"
      via: "import useSessions + useCreateSession + useDeleteSession"
      pattern: "useSessions"
    - from: "app/components/layout/EngineStatus.tsx"
      to: "app/hooks/useEngine.ts"
      via: "import useEngineStatus + useEngineStart + useEngineStop"
      pattern: "useEngineStatus"
    - from: "app/routes/chat.tsx"
      to: "app/routes/chat.$sessionId.tsx"
      via: "Outlet renders child chat route"
      pattern: "Outlet"
---

<objective>
Deliver the working chat interface that Phase 5 CONTEXT.md promised — the "it works" moment
where a user sends a message and sees an AI response stream in via SSE, with session management
and engine controls.

This closes the critical gap: Plans 01-03 built 18 server functions, 2 SSE routes, and 5 React
hooks — all READY and WIRED — but all 3 route files are static text stubs that display
"Stub — will be replaced." No UI component was ever created to use the hooks.

Purpose: Fulfill CONTEXT.md locked decisions — "Chat + SSE streaming + engine control + session
management must all be functional." Without this, Phase 5 has zero user-facing functionality
despite a complete backend.

Output: Working chat page with streaming AI responses, session sidebar, engine status indicator.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-framework-foundation/05-CONTEXT.md
@.planning/phases/05-framework-foundation/05-02-SUMMARY.md
@.planning/phases/05-framework-foundation/05-03-SUMMARY.md

CRITICAL — Read these existing hooks BEFORE implementing. They are READY TO USE:
@app/hooks/useEngine.ts
@app/hooks/useSession.ts
@app/hooks/useStreaming.ts
@app/hooks/useEventStream.tsx

CRITICAL — Read these server functions to understand return types:
@app/server/sessions.ts
@app/server/engine.ts

CRITICAL — Read shared types:
@app/shared/engine-types.ts
@app/shared/ide-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat components — message rendering, input, and message list</name>
  <files>
    app/lib/utils.ts
    app/components/chat/ChatMessage.tsx
    app/components/chat/ChatInput.tsx
    app/components/chat/ChatMessages.tsx
  </files>
  <action>
    FIRST: Read `app/hooks/useStreaming.ts` and `app/shared/engine-types.ts` to understand
    the exact types for Message, Part, and StreamPart. All component props must match these types.
    Also read `app/hooks/useSession.ts` to see what `useSessionMessages` returns.

    **1. Create `app/lib/utils.ts`** (~10 LOC)

    Standard Tailwind class merge utility:
    ```typescript
    import { clsx, type ClassValue } from "clsx"
    import { twMerge } from "tailwind-merge"
    export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)) }
    ```

    Both `clsx` and `tailwind-merge` are already in app/package.json.

    **2. Create `app/components/chat/ChatMessage.tsx`** (~100 LOC)

    Renders a single message with role indicator and markdown content.

    Props: `{ message: { role: string; content?: string; parts?: Part[] } }`

    Implementation:
    - Show role badge: "You" for user (left-aligned, subtle bg), "AI" for assistant (left-aligned, accent bg)
    - For `message.content` (string): render with `<ReactMarkdown remarkPlugins={[remarkGfm]}>`
    - For `message.parts` (array): iterate parts. For each part:
      - `type === "text"`: render `part.text` with ReactMarkdown
      - `type === "tool-call"`: render a small card with tool name and "Running..." or args summary
      - `type === "tool-result"`: render result text in a muted box
      - Other types: render `JSON.stringify(part)` in a pre block
    - Wrap message in a div with appropriate spacing (py-4 border-b border-border last:border-0)
    - Use Tailwind prose classes for markdown: `prose prose-sm dark:prose-invert max-w-none`

    Import react-markdown and remark-gfm (already in app/package.json):
    ```typescript
    import ReactMarkdown from "react-markdown"
    import remarkGfm from "remark-gfm"
    ```

    **3. Create `app/components/chat/ChatInput.tsx`** (~80 LOC)

    Text input area with send button and abort button.

    Props: `{ onSend: (text: string) => void; onAbort: () => void; streaming: boolean; disabled?: boolean }`

    Implementation:
    - Textarea (plain HTML with Tailwind) that auto-grows up to 200px max-height
    - Send button (right side): disabled when textarea empty or streaming
    - When streaming=true: show "Stop" button (red) that calls onAbort instead of Send
    - Keyboard: Enter sends (calls onSend with textarea value, clears textarea), Shift+Enter inserts newline
    - Use useRef for textarea, useState for value
    - Styling: fixed bottom area with border-t, p-4, dark bg slightly different from main

    Do NOT use shadcn components — plain HTML + Tailwind. Keep it simple per CONTEXT.md
    ("not fancy").

    **4. Create `app/components/chat/ChatMessages.tsx`** (~80 LOC)

    Scrollable message list that auto-scrolls to bottom on new messages.

    Props: `{ messages: Array<{ role: string; content?: string; parts?: Part[] }>; streaming?: boolean }`

    Implementation:
    - Wrapper div with `flex-1 overflow-y-auto` for scrolling
    - Map over messages, render `<ChatMessage>` for each
    - Auto-scroll: useRef on container, useEffect scrolls to bottom when messages.length changes
      or when streaming changes
    - Empty state: centered text "Send a message to start" when messages is empty
    - Import ChatMessage from same directory

    After creating all 4 files, verify:
    - `npx tsc --noEmit -p tsconfig.app.json` passes (no type errors)
  </action>
  <verify>
    1. `test -f app/lib/utils.ts` — utils file exists
    2. `test -f app/components/chat/ChatMessage.tsx` — message component exists
    3. `test -f app/components/chat/ChatInput.tsx` — input component exists
    4. `test -f app/components/chat/ChatMessages.tsx` — messages list exists
    5. `grep -q 'ReactMarkdown' app/components/chat/ChatMessage.tsx` — uses react-markdown
    6. `grep -q 'remarkGfm' app/components/chat/ChatMessage.tsx` — uses GFM plugin
    7. `grep -q 'onSend' app/components/chat/ChatInput.tsx` — has send callback
    8. `grep -q 'onAbort' app/components/chat/ChatInput.tsx` — has abort callback
    9. `npx tsc --noEmit -p tsconfig.app.json` exits 0
  </verify>
  <done>
    Four chat component files created: utils.ts, ChatMessage.tsx (with react-markdown),
    ChatInput.tsx (with send/abort), ChatMessages.tsx (scrollable list with auto-scroll).
    All compile with zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Chat route + layout + session sidebar + engine status</name>
  <files>
    app/components/layout/SessionSidebar.tsx
    app/components/layout/EngineStatus.tsx
    app/routes/chat.tsx
    app/routes/chat.$sessionId.tsx
  </files>
  <action>
    FIRST: Read these hooks to understand exact exports and return types:
    - `app/hooks/useSession.ts` — need: useSessions, useSessionMessages, useCreateSession, useDeleteSession
    - `app/hooks/useEngine.ts` — need: useEngineStatus, useEngineStart, useEngineStop (or useStartEngine/useStopEngine — check actual export names)
    - `app/hooks/useStreaming.ts` — need: useStreaming(sessionId) → { state, data, streaming, sendPrompt, abort, error }

    CRITICAL: Use the ACTUAL export names from the hooks, not assumed names. Read the files first.

    **1. Create `app/components/layout/EngineStatus.tsx`** (~50 LOC)

    Engine connection indicator with start/stop toggle.

    Implementation:
    - Import useEngineStatus, useEngineStart (or useStartEngine), useEngineStop (or useStopEngine)
      from `@/hooks/useEngine` — USE THE ACTUAL EXPORT NAMES from the hook file
    - Show colored dot: green when engine running, red when stopped, yellow when loading
    - Show text: "Connected" / "Disconnected" / "Starting..."
    - Show toggle button: "Stop" when running (calls stop mutation), "Start" when stopped (calls start)
    - Compact layout: inline flex, text-xs, gap-2
    - Wrap in try/catch mentality: if query fails, show "Unknown" with yellow dot

    **2. Create `app/components/layout/SessionSidebar.tsx`** (~140 LOC)

    Session list with create, switch, and delete.

    Implementation:
    - Import from `@/hooks/useSession`: useSessions, useCreateSession, useDeleteSession
      USE THE ACTUAL EXPORT NAMES from the hook file
    - Import Link and useParams from `@tanstack/react-router`
    - Import EngineStatus from `@/components/layout/EngineStatus`

    Structure:
    ```
    <aside class="w-64 border-r border-border bg-muted/30 flex flex-col h-full">
      <!-- Header: New Chat button + Engine Status -->
      <div class="p-3 border-b border-border space-y-2">
        <button "New Chat" → createSession.mutateAsync() then navigate to /chat/${newId}>
        <EngineStatus />
      </div>

      <!-- Session list: scrollable -->
      <div class="flex-1 overflow-y-auto">
        {sessions.map(session => (
          <div class="group flex items-center px-3 py-2 hover:bg-accent/50
                       cursor-pointer {active ? 'bg-accent' : ''}">
            <Link to="/chat/$sessionId" params={{ sessionId: session.id }}
                  class="flex-1 truncate text-sm">
              {session.title || "New Chat"}
            </Link>
            <button class="opacity-0 group-hover:opacity-100" onClick={delete}>×</button>
          </div>
        ))}
      </div>
    </aside>
    ```

    - Active session: compare session.id with current sessionId from URL params
    - "New Chat" button: calls createSession mutation, on success navigates to `/chat/${newSession.id}`
    - Delete button: appears on hover, calls deleteSession mutation with session.id
    - Empty state: "No sessions yet" text when list is empty
    - For navigation: use `useNavigate()` from `@tanstack/react-router`
    - Get current sessionId: use `useParams({ strict: false })` since sidebar lives in layout
      route, not the child route — check TanStack Router docs for getting child route params
      from parent. May need `useMatch` or `useMatches` instead.

    **3. Create `app/routes/chat.tsx`** (NEW layout route, ~40 LOC)

    Layout route for `/chat/*` — renders sidebar + child content.

    This is a TanStack Router LAYOUT route. When a user navigates to `/chat/abc123`:
    - `chat.tsx` renders (layout)
    - `chat.$sessionId.tsx` renders inside chat.tsx's `<Outlet />`

    Implementation:
    ```tsx
    import { createFileRoute, Outlet } from "@tanstack/react-router"
    import { SessionSidebar } from "@/components/layout/SessionSidebar"

    export const Route = createFileRoute("/chat")({
      component: ChatLayout,
    })

    function ChatLayout() {
      return (
        <div className="flex h-full">
          <SessionSidebar />
          <main className="flex-1 flex flex-col min-w-0">
            <Outlet />
          </main>
        </div>
      )
    }
    ```

    After creating chat.tsx, the route tree will auto-regenerate. `chat.$sessionId.tsx` becomes
    a child of `chat.tsx`.

    **4. REWRITE `app/routes/chat.$sessionId.tsx`** (from stub to full implementation, ~150 LOC)

    This is the core of the "it works" moment. Full chat interface with streaming.

    IMPORTANT: Delete the entire stub content and replace with:

    ```tsx
    import { createFileRoute, useNavigate } from "@tanstack/react-router"
    import { useState, useEffect, useCallback } from "react"
    import { useSessionMessages, useCreateSession } from "@/hooks/useSession"
    import { useStreaming } from "@/hooks/useStreaming"
    import { ChatMessages } from "@/components/chat/ChatMessages"
    import { ChatInput } from "@/components/chat/ChatInput"

    // USE ACTUAL HOOK NAMES — verify by reading the hook files first

    export const Route = createFileRoute("/chat/$sessionId")({
      component: ChatPage,
    })

    function ChatPage() {
      const { sessionId } = Route.useParams()
      const navigate = useNavigate()
      const isNew = sessionId === "new"

      // Create session when landing on /chat/new
      const createSession = useCreateSession() // USE ACTUAL EXPORT NAME
      useEffect(() => {
        if (isNew) {
          createSession.mutateAsync().then((session) => {
            navigate({
              to: "/chat/$sessionId",
              params: { sessionId: session.id },
              replace: true,
            })
          }).catch(() => {
            // Session creation failed — stay on /chat/new, show error
          })
        }
      }, [isNew])

      // Don't render chat UI while creating session
      if (isNew) {
        return (
          <div className="flex items-center justify-center h-full text-muted-foreground">
            Creating session...
          </div>
        )
      }

      return <ChatContent sessionId={sessionId} />
    }

    function ChatContent({ sessionId }: { sessionId: string }) {
      // Message history from server
      const { data: historyMessages = [], refetch } = useSessionMessages(sessionId)

      // Streaming hook for sending prompts
      const { state, data: streamData, streaming, sendPrompt, abort } = useStreaming(sessionId)
      // USE ACTUAL RETURN SHAPE — read useStreaming.ts first

      // Track the user's message while streaming (before it appears in history)
      const [pendingUserMsg, setPendingUserMsg] = useState<string | null>(null)

      // When streaming completes, refresh history and clear pending message
      useEffect(() => {
        if (state === "success") {
          setPendingUserMsg(null)
          refetch()
        }
      }, [state, refetch])

      // Combine: history + pending user msg + streaming assistant response
      const displayMessages = [
        ...historyMessages,
        ...(pendingUserMsg ? [{ role: "user" as const, content: pendingUserMsg }] : []),
        ...(streaming && streamData
          ? [{ role: "assistant" as const, content: streamData.text, parts: streamData.parts }]
          : []),
      ]

      const handleSend = useCallback((text: string) => {
        setPendingUserMsg(text)
        sendPrompt(text)
      }, [sendPrompt])

      return (
        <div className="flex flex-col h-full">
          <ChatMessages messages={displayMessages} streaming={streaming} />
          <ChatInput
            onSend={handleSend}
            onAbort={abort}
            streaming={streaming}
          />
        </div>
      )
    }
    ```

    CRITICAL ADAPTATION NOTES:
    - The above code uses assumed hook return shapes. Before writing, READ the actual hooks
      and adapt the code to match their REAL types and export names.
    - If `useStreaming` returns `data.text` → use it for content.
      If it returns `data.parts` → pass parts to ChatMessage.
    - If `useCreateSession` is named differently (e.g., `useSessionCreate`), use the actual name.
    - If `useSessionMessages` returns messages in a different shape, adapt displayMessages.
    - The `refetch` pattern assumes React Query. If the hook uses a different invalidation
      pattern, adapt accordingly.

    After creating/modifying all 4 files:
    - Wait for route tree to regenerate (auto on file save in dev, or run build)
    - `npx tsc --noEmit -p tsconfig.app.json` must pass
    - `npm test` must pass (no regressions to existing tests)
  </action>
  <verify>
    1. `test -f app/components/layout/EngineStatus.tsx` — engine status exists
    2. `test -f app/components/layout/SessionSidebar.tsx` — sidebar exists
    3. `test -f app/routes/chat.tsx` — layout route exists
    4. `grep -q 'useStreaming' app/routes/chat.\$sessionId.tsx` — uses streaming hook
    5. `grep -q 'useSessionMessages' app/routes/chat.\$sessionId.tsx` — uses message history hook
    6. `grep -q 'ChatMessages' app/routes/chat.\$sessionId.tsx` — renders message list
    7. `grep -q 'ChatInput' app/routes/chat.\$sessionId.tsx` — renders input
    8. `grep -q 'useSessions' app/components/layout/SessionSidebar.tsx` — uses sessions hook
    9. `grep -q 'useEngineStatus' app/components/layout/EngineStatus.tsx` — uses engine hook
    10. `grep -q 'Outlet' app/routes/chat.tsx` — layout renders child content
    11. `npx tsc --noEmit -p tsconfig.app.json` exits 0
    12. `npm test` passes
  </verify>
  <done>
    Chat layout route created with SessionSidebar (session list + create/delete + engine status).
    Chat route fully implemented with streaming AI responses, message history, send/abort controls.
    All hooks wired: useStreaming for SSE, useSessionMessages for history, useSessions for sidebar,
    useEngineStatus for connection indicator. TypeScript clean, tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify working chat — the "it works" moment</name>
  <what-built>
    Complete chat interface delivering what Phase 5 CONTEXT.md promised:
    1. Chat components: ChatMessage (react-markdown), ChatInput (send/abort), ChatMessages (scrollable list)
    2. Session sidebar: session list, "New Chat" button, delete, active highlight
    3. Engine status: connection indicator with start/stop toggle
    4. Chat layout route (chat.tsx) with sidebar + Outlet
    5. Full chat route (chat.$sessionId.tsx) with streaming, history, send/abort
  </what-built>
  <how-to-verify>
    1. Start OpenCode in your project: `opencode` (needs to be running for SDK connection)
    2. Start the dashboard dev server: `cd app && npm run dev`
    3. Open browser at http://localhost:5180

    **Chat flow:**
    4. EXPECT: `/` redirects to `/chat/new`, which auto-creates a session and redirects to `/chat/{sessionId}`
    5. EXPECT: You see a chat interface — message area (empty, "Send a message to start") + input bar at bottom
    6. Type "Hello, what can you do?" and press Enter
    7. EXPECT: Your message appears in the list, then an AI response streams in word-by-word via SSE
    8. EXPECT: The AI response renders with basic markdown — headers, bold, code blocks are formatted (not raw text)

    **Session management:**
    9. Click "New Chat" button in sidebar → EXPECT: new session created, navigated to it
    10. EXPECT: Previous session appears in sidebar list, clickable to switch back
    11. Hover over a session → EXPECT: delete button (×) appears, clicking it removes the session

    **Engine controls:**
    12. EXPECT: Engine status indicator visible in sidebar — green dot + "Connected" if OpenCode is running
    13. Click "Stop" → EXPECT: engine stops, dot turns red, "Start" button appears
    14. Click "Start" → EXPECT: engine starts, dot turns green

    **Error handling:**
    15. If OpenCode is NOT running: EXPECT: engine shows "Disconnected", chat gracefully shows error when trying to send (not a crash)
  </how-to-verify>
  <resume-signal>Type "approved" if chat works end-to-end, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Phase 05 gap closure (plan 05) verification:
1. Chat sends messages and receives streaming AI responses via SSE
2. Chat responses render with react-markdown (headers, bold, code blocks)
3. Session sidebar lists sessions, creates new ones, switches, deletes
4. Engine status shows connection state with start/stop controls
5. TypeScript clean: `npx tsc --noEmit -p tsconfig.app.json`
6. Test suite passes: `npm test`
7. No hardcoded data — all data flows through hooks → server functions → OpenCode SDK
</verification>

<success_criteria>
- User can send a message and see a streaming AI response (the "it works" moment)
- Chat responses are readable with basic markdown rendering
- User can create, switch between, and delete chat sessions
- User can see engine connection status and start/stop the engine
- All data flows through the existing hooks (useStreaming, useSession, useEngine) — no bypasses
- Zero TypeScript errors, existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-framework-foundation/05-05-SUMMARY.md`
</output>
