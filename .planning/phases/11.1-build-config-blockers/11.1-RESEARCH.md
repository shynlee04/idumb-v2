# Phase 11.1: Build & Config Blockers - Research

**Researched:** 2026-02-11
**Domain:** Build tooling (Vite/Rollup), TypeScript config, SDK type governance, package.json hygiene
**Confidence:** HIGH (all findings verified against live codebase, actual build/test output captured)

## Summary

Phase 11.1 addresses 7 concrete blockers identified in `v2.0-MILESTONE-AUDIT.md` that prevent Phase 7 from starting. Every issue was reproduced and root-caused during this research. The two critical blockers (GAP-1: production build failure, GAP-2: typecheck failure) are each single-line fixes. The type governance violations (GOV-1, GOV-2, GOV-3) require adding 4 type re-exports and replacing 2 unsafe casts. The config drift items (DRIFT-1, DRIFT-2, CONFIG-1, CONFIG-2) are dead alias removal, doc updates, and entry point cleanup.

All 7 fixes are small, targeted, and independent of each other. No new dependencies, no architectural changes, no library upgrades. This is purely a cleanup/hardening phase.

**Primary recommendation:** Fix all 7 issues in a single plan. Execute in dependency order: GAP-1 and GAP-2 first (unblock build/typecheck), then GOV-1 (unblocks type governance), then remaining items in any order. Verify with `npm run build:app && npm run typecheck:app && npm test` after each fix.

## Standard Stack

No new libraries needed. All fixes use existing tooling:

### Core (Already Installed)
| Library | Version | Purpose | Role in Phase |
|---------|---------|---------|---------------|
| `vite` | 7.3.1 | Build tool | GAP-1 fix (vite.config.ts) |
| `typescript` | 5.7.3 | Type checker | GAP-2 fix, GOV-1 verification |
| `@opencode-ai/sdk` | 1.1.53 (locked 1.1.54 in lockfile) | SDK types | GOV-1 type re-exports |
| `zod` | 4.3.6 | Schema validation | GOV-2/GOV-3 type-safe alternatives |

### No New Installations Required
This phase adds zero dependencies. Every fix is configuration or code change only.

## Architecture Patterns

### Pattern 1: SDK Type Gateway (engine-types.ts)
**What:** All `app/` code imports SDK types exclusively from `app/shared/engine-types.ts`, never from `@opencode-ai/sdk` directly. Only two files may import from `@opencode-ai/sdk`: `engine-types.ts` (the gateway) and `sdk-client.server.ts` (the runtime client).
**When to use:** Any time a new SDK type is needed in `app/` code.
**Example (GOV-1 fix):**
```typescript
// In app/shared/engine-types.ts — add to the existing import/export block:
import type {
  Session,
  // ... existing imports ...
  Provider,
  Agent,
  Path,
  VcsInfo,
} from '@opencode-ai/sdk'

export type {
  Session,
  // ... existing exports ...
  Provider,
  Agent,
  Path,
  VcsInfo,
}
```
Then in `app/server/config.ts`:
```typescript
// BEFORE (violation):
import type { Provider, Agent, Path, VcsInfo } from "@opencode-ai/sdk"

// AFTER (compliant):
import type { Provider, Agent, Path, VcsInfo } from "../shared/engine-types"
```

### Pattern 2: Zod .parse() for Typed Returns
**What:** Use Zod `.parse()` (not `.safeParse()`) when the validated data needs to be returned with its typed shape. `.parse()` returns the typed output; `.safeParse()` returns `{ success, data }` which loses the type when used as a pass-through.
**When to use:** GOV-2 and GOV-3 fixes — replacing `as Record<string, unknown>` casts and JSON roundtrips.
**Example (GOV-3 fix):**
```typescript
// BEFORE (type chain broken):
validateMessages(messages)
return JSON.parse(JSON.stringify(messages))

// AFTER (type chain preserved):
// Option A: Parse and return (throws on validation failure)
return z.array(MessageSchema).parse(messages)

// Option B: If TanStack serialization still rejects unknown in index signatures,
// use JSON roundtrip but cast to the known return type after validation:
validateMessages(messages)
return JSON.parse(JSON.stringify(messages)) as z.infer<typeof MessageSchema>[]
```
**Note:** The JSON roundtrip in sessions.ts exists because TanStack Start's serialization doesn't accept `unknown` in index signatures. The fix needs to preserve serialization compatibility while restoring type information. Testing with the actual TanStack runtime is required to determine which approach works.

### Pattern 3: Vite Environment-Specific Config
**What:** Vite 7 builds both client and SSR environments. Config that only applies to client builds (like `manualChunks` for code splitting) must not conflict with SSR externals.
**When to use:** GAP-1 fix.
**Example:**
```typescript
// SIMPLEST FIX — just remove manualChunks entirely:
// Monaco lazy loading via dynamic import() already code-splits.
build: {
  rollupOptions: {
    external: ["@opencode-ai/sdk", /^node:/],
    // manualChunks REMOVED — MonacoEditor.lazy.tsx handles splitting
  },
}
```

### Anti-Patterns to Avoid
- **`as Record<string, unknown>` on SDK return values:** Destroys type information. Use Zod validation schemas instead.
- **`JSON.parse(JSON.stringify(x))` after Zod validation:** The validation proves the shape, but the JSON roundtrip produces `any`. If needed for serialization, re-assert the type afterward.
- **`@ts-expect-error` without periodic review:** Error suppressions become stale when dependencies upgrade. Review all `@ts-expect-error` directives after dependency updates.
- **`manualChunks` for externalized modules:** Rollup cannot chunk a module that is also externalized. Use dynamic `import()` for code splitting instead.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| SDK type validation at server boundaries | Manual `typeof`/shape checks | Zod schemas in `sdk-validators.ts` | Already built, 12-member Part union, 3-member SessionStatus union |
| SDK type re-exports | Separate type files per consumer | Single `engine-types.ts` gateway | Centralized, auditable, one place to check compliance |
| Monaco code splitting | `manualChunks` config | Dynamic `import()` in `MonacoEditor.lazy.tsx` | Already implemented, works in both client and SSR builds |

**Key insight:** Every "don't hand-roll" item in this phase already has the correct solution implemented. The bugs are places where the wrong approach was used alongside the correct one.

## Common Pitfalls

### Pitfall 1: manualChunks vs SSR Externals
**What goes wrong:** `manualChunks` tells Rollup to group module X into a named chunk. But if module X is also marked `external`, Rollup cannot include it in any chunk — producing a build error.
**Why it happens:** Vite 7+ builds both client and SSR environments from a single config. The client build succeeds because `monaco-editor` is bundled. The SSR build fails because `monaco-editor` resolves as external in SSR mode (it's a browser-only module).
**How to avoid:** Never put browser-only modules in `manualChunks`. Use lazy dynamic imports (`React.lazy(() => import(...))`) for code splitting instead.
**Warning signs:** Client build succeeds but SSR build fails. Error message mentions "resolved as an external module."

### Pitfall 2: Stale @ts-expect-error After Dependency Upgrades
**What goes wrong:** A `@ts-expect-error` directive suppresses an error that no longer exists, causing TS2578 ("Unused @ts-expect-error directive").
**Why it happens:** A dependency upgrade (TanStack Start, Vite, or their type declarations) added proper types for a previously untyped import pattern (like `?url` imports). The suppression becomes unnecessary but isn't removed.
**How to avoid:** After dependency upgrades, run `npm run typecheck:app` before committing. Remove any unused error suppressions.
**Warning signs:** `tsc --noEmit` reports TS2578 errors.

### Pitfall 3: Dead Path Aliases Confusing Future Developers
**What goes wrong:** `tsconfig.app.json` and `vite.config.ts` define `@shared/` pointing to `src/dashboard/shared/` which was deleted in Phase 1A. No code uses the alias, but a developer seeing it might create imports using `@shared/` — which would compile but fail at runtime.
**Why it happens:** Path aliases weren't cleaned up when the target directory was deleted.
**How to avoid:** When deleting directories, grep for path aliases referencing them. Clean up `tsconfig.*.json` paths and Vite resolve.alias entries.
**Warning signs:** `paths` entries in tsconfig.json that point to non-existent directories.

### Pitfall 4: Package Entry Point Pointing to Stale Build Artifact
**What goes wrong:** `package.json` declares `"main": "dist/index.js"` but `src/index.ts` was archived. The `dist/index.js` file exists as a stale artifact from before the archive. Running `tsc` doesn't regenerate it because the source file is gone.
**Why it happens:** The plugin architecture was archived in Phase 1A (`src/index.ts` moved to `src/_archived-plugin/index.ts`), but `package.json` entry points weren't updated.
**How to avoid:** When archiving entry point files, update `package.json` `main`, `types`, and `exports` fields.
**Warning signs:** `dist/` files with older timestamps than the last `tsc` run; `package.json` `main` field pointing to a file with no corresponding source.

### Pitfall 5: Phantom Peer Dependencies in Lockfile
**What goes wrong:** `package-lock.json` contains `@opencode-ai/plugin` v1.1.54 as a peer dependency — not from this project, but from `hivemind-context-governance` which declares it as a non-optional peer dependency.
**Why it happens:** `hivemind-context-governance` was designed as an OpenCode plugin companion. Its peer dependency declaration pulls `@opencode-ai/plugin` into the lockfile even though idumb-v2 no longer uses it directly.
**How to avoid:** Audit transitive peer dependencies when adding plugin-ecosystem packages. Consider whether the package is still appropriate after architectural changes.
**Warning signs:** `npm ls @opencode-ai/plugin` shows it in the dependency tree despite not being in `package.json` dependencies.

### Pitfall 6: TanStack Start Serialization vs SDK Unknown Types
**What goes wrong:** SDK types use `unknown` in index signatures (e.g., `metadata: Record<string, unknown>`). TanStack Start's serialization layer rejects objects with `unknown` in their type signatures, requiring either JSON roundtrips or type assertions.
**Why it happens:** TanStack Start enforces serialization-safe types for server function return values. The SDK's use of `unknown` (correctly loose for a generated API client) conflicts with this constraint.
**How to avoid:** At server function return boundaries, either: (a) use `.parse()` with a Zod schema that maps `unknown` to a serialization-safe type, or (b) use JSON roundtrip with a typed assertion. Document the workaround inline.
**Warning signs:** `Type 'unknown' is not assignable to type '{}'` errors from TanStack Start.

## Detailed Gap Analysis (Verified)

### GAP-1: Production Build Fails (BLOCKER)
**File:** `app/vite.config.ts` lines 37-38
**Error reproduced:**
```
"monaco-editor" cannot be included in manualChunks because it is resolved
as an external module by the "external" option or plugins.
```
**Build output:** Client build succeeds in 65s (2419 modules). SSR build fails in 2.35s.
**Root cause:** `manualChunks: { 'monaco-editor': ['monaco-editor'] }` conflicts with `external: ["@opencode-ai/sdk", /^node:/]` during SSR build, where monaco-editor resolves as external.
**Fix:** Remove lines 37-38 (the `manualChunks` block). Monaco code splitting is already handled by `MonacoEditor.lazy.tsx` which uses dynamic `import()`.
**Confidence:** HIGH — error reproduced, fix is straightforward removal.

### GAP-2: App Typecheck Fails (BLOCKER)
**File:** `app/routes/__root.tsx` line 23
**Error reproduced:** `TS2578: Unused '@ts-expect-error' directive.`
**Root cause:** The `@ts-expect-error` comment on the `?url` CSS import is no longer needed — type declarations for Vite `?url` imports now exist (likely from a TanStack Start or Vite upgrade).
**Fix:** Remove line 23 (`// @ts-expect-error -- Vite ?url import, resolved at build time`).
**Confidence:** HIGH — error reproduced, fix is single-line removal.

### GOV-1: Direct SDK Import in config.ts
**File:** `app/server/config.ts` line 17
**Violation:** `import type { Provider, Agent, Path, VcsInfo } from "@opencode-ai/sdk"` — bypasses `engine-types.ts` gateway.
**SDK verification:** All 4 types confirmed exported from `@opencode-ai/sdk` via `types.gen.d.ts`.
**Currently in engine-types.ts:** 18 types re-exported. Missing: `Provider`, `Agent`, `Path`, `VcsInfo` (4 types).
**Fix:** (1) Add 4 types to `engine-types.ts` import/export block. (2) Change config.ts import to `from "../shared/engine-types"`.
**Confidence:** HIGH — types verified in SDK, import path validated.

### GOV-2: `as Record<string, unknown>` Cast (sessions.ts:143)
**File:** `app/server/sessions.ts` line 143
**Code:** `const statusMap = unwrapSdkResult(result) as Record<string, unknown>`
**Context:** `session.status()` returns a map of session IDs to `SessionStatus` objects. The cast to `Record<string, unknown>` discards the type information.
**Fix approach:** Use Zod validation. `SessionStatusSchema` already exists in `sdk-validators.ts`. After unwrapping, validate the individual status entry rather than casting the entire map.
**TanStack serialization note:** The `return JSON.parse(JSON.stringify(status))` on line 150 also needs a type assertion post-validation (same pattern as GOV-3).
**Confidence:** HIGH — schema exists, fix is mechanical.

### GOV-3: JSON Roundtrip Destroys Type Chain (sessions.ts:107-108)
**File:** `app/server/sessions.ts` lines 107-108
**Code:** `validateMessages(messages); return JSON.parse(JSON.stringify(messages))`
**Context:** `validateMessages()` runs `.safeParse()` for error detection but returns the original `data` parameter (generic `T`), not the parsed result. The JSON roundtrip is needed for TanStack serialization compatibility but produces `any`.
**Fix options:**
1. Use `z.array(MessageSchema).parse(messages)` — returns typed `z.infer<typeof MessageSchema>[]`. But may fail if TanStack serialization rejects the result type.
2. Keep JSON roundtrip but add type assertion: `return JSON.parse(JSON.stringify(messages)) as Message[]` — preserves serialization compat, restores type information.
3. Change `validateMessages()` to return `z.infer` result instead of generic passthrough — requires updating all 4 validator functions in sdk-validators.ts.

**Recommended:** Option 2 for minimal risk. Option 3 is cleaner but higher scope.
**Confidence:** HIGH — problem understood, multiple fix paths available. Runtime testing needed to pick final approach.

### DRIFT-1: Dead `@shared` Alias
**Files:** `tsconfig.app.json` line 18, `app/vite.config.ts` line 20
**Alias:** `@shared → src/dashboard/shared/`
**Target exists:** NO — `src/dashboard/shared/` was deleted in Phase 1A.
**Code using alias:** NO — grep found zero `@shared/` imports in `app/`.
**Fix:** Remove line 18 from `tsconfig.app.json` (`"@shared/*": ["./src/dashboard/shared/*"]`), remove line 20 from `vite.config.ts` (`"@shared": resolve(__dirname, "../src/dashboard/shared")`).
**Confidence:** HIGH — verified target doesn't exist, verified no code uses it.

### DRIFT-2: Test Baseline Stale in CLAUDE.md
**CLAUDE.md claims:** "10 suites, ~512 assertions"
**Actual (reproduced):**
- 10 test files in `tests/` directory (confirmed by `ls`)
- 10 test commands in `package.json` test script
- 9 suites produce "Results:" output with assertion counts
- 1 suite (`smoke-code-quality.ts`) produces warnings/info but no "Results:" line
- Total countable assertions: 65 + 89 + 54 + 44 + 52 + 56 + 112 + 40 + 79 = **591**
**Fix:** Update CLAUDE.md testing section to "10 suites, 591 assertions"
**Confidence:** HIGH — run reproduced, numbers counted from output.

### CONFIG-1: Package Entry Point Stale
**package.json fields:**
```json
"main": "dist/index.js",
"types": "dist/index.d.ts",
"exports": { ".": { "import": "./dist/index.js", "types": "./dist/index.d.ts" } }
```
**Source file:** `src/index.ts` does NOT exist (archived to `src/_archived-plugin/index.ts`)
**dist file:** `dist/index.js` exists (7360 bytes, last modified Feb 10 04:23) — stale build artifact
**Impact:** `npm run build` (tsc) does NOT regenerate `dist/index.js` because there's no source. The entry point is a zombie artifact. Anyone importing `idumb-v2` would get the old plugin API which no longer has backing source code.
**Fix options:**
1. Remove `main`, `types`, `exports` fields from package.json (if the package is not meant to be imported as a library).
2. Create a minimal `src/index.ts` that exports the CLI-relevant APIs (schemas, persistence, etc.).
3. Point entry to CLI: `"main": "dist/cli.js"` — but this is unusual for a library.

**Recommended:** Option 1 if idumb-v2 is only used via CLI (`bin` field). Option 2 if other packages need to import from it.
**Confidence:** HIGH — verified src/index.ts missing, dist/index.js stale.

### CONFIG-2: Phantom @opencode-ai/plugin in package-lock.json
**In package.json:** NO (not listed in dependencies or devDependencies)
**In package-lock.json:** YES — `@opencode-ai/plugin` v1.1.54 installed as `"peer": true`
**Source:** `hivemind-context-governance@1.3.0` declares it as a non-optional peerDependency:
```json
"peerDependencies": { "@opencode-ai/plugin": "*" },
"peerDependenciesMeta": { "@opencode-ai/plugin": { "optional": false } }
```
**Impact:** Not a build issue (npm resolves it), but it's conceptually misleading — idumb-v2 archived its plugin architecture, yet `@opencode-ai/plugin` still appears in node_modules.
**Fix options:**
1. Accept as harmless transitive dependency (lowest effort).
2. File issue / PR on `hivemind-context-governance` to make `@opencode-ai/plugin` optional.
3. Evaluate whether `hivemind-context-governance` is still needed in idumb-v2.

**Recommended:** Option 1 for now. This is not a blocker for Phase 7.
**Confidence:** HIGH — lockfile analyzed, source traced.

## Additional Findings (Not in Audit)

### `as any` Casts in SSE Routes
**Files:** `app/routes/api/events.ts:81`, `app/routes/api/sessions.$id.prompt.ts:139`
**Pattern:** Both SSE route files end with `}) as any)` to satisfy TanStack Start's route type system.
**Context:** TanStack Start's `createFileRoute()` expects specific handler shapes. The SSE routes use raw `server.handlers.GET/POST` for streaming Response objects, which don't match the expected type signature. The `as any` is documented with `eslint-disable-next-line` comments.
**Assessment:** These are NOT SDK type violations. They're framework compatibility workarounds. Not a Phase 11.1 concern, but worth tracking for when TanStack Start adds proper SSE route types.

### console.warn in Server Functions
**Files:** `app/server/config.ts` lines 38, 68
**Pattern:** `console.warn("[config] SDK providers/agents response...")` in server-side code.
**Assessment:** The CLAUDE.md rule says "NO `console.log` — it breaks TUI rendering." These are `console.warn` in server-side code (not TUI), so technically allowed but stylistically inconsistent. Not a Phase 11.1 concern.

### SDK Part Union: 12 Members (Including Inline Subtask)
**SDK `Part` type:** TextPart | { type: "subtask"; ... } | ReasoningPart | FilePart | ToolPart | StepStartPart | StepFinishPart | SnapshotPart | PatchPart | AgentPart | RetryPart | CompactionPart
**Note:** The `subtask` type is an inline anonymous type in the SDK union (no named `SubtaskPart` export). The Zod schema in `sdk-validators.ts` correctly handles all 12 members. This is documented but worth noting: the engine-types.ts gateway cannot re-export a named `SubtaskPart` type because the SDK doesn't export one.

## Execution Order Recommendation

| Order | Gap | Fix Complexity | Verification |
|-------|-----|----------------|--------------|
| 1 | GAP-1 (build fails) | Remove 3 lines from vite.config.ts | `npm run build:app` succeeds |
| 2 | GAP-2 (typecheck fails) | Remove 1 line from __root.tsx | `npm run typecheck:app` passes |
| 3 | GOV-1 (config.ts bypass) | Add 4 types to engine-types.ts, update 1 import | `npm run typecheck:app` still passes |
| 4 | DRIFT-1 (dead alias) | Remove 1 line each from tsconfig.app.json and vite.config.ts | `npm run typecheck:app` + `npm run build:app` |
| 5 | GOV-2 (Record cast) | Replace cast with Zod validation in sessions.ts | `npm run typecheck:app` |
| 6 | GOV-3 (JSON roundtrip) | Add type assertion or use .parse() in sessions.ts | `npm run typecheck:app` |
| 7 | DRIFT-2 (test baseline) | Update CLAUDE.md numbers | Manual review |
| 8 | CONFIG-1 (entry point) | Update/remove package.json main/types/exports | `npm run build` |
| 9 | CONFIG-2 (phantom dep) | Accept as-is or evaluate hivemind-context-governance | No action needed |

**Total estimated time:** 20-30 minutes for all fixes.

## Open Questions

1. **GOV-3 TanStack Serialization Compatibility**
   - What we know: `JSON.parse(JSON.stringify())` is used because TanStack Start rejects `unknown` in index signatures.
   - What's unclear: Whether `z.array(MessageSchema).parse()` return type satisfies TanStack's serialization constraint, or whether the JSON roundtrip is still required.
   - Recommendation: Try Option 2 (type assertion after JSON roundtrip) first — lowest risk. If typecheck passes and runtime works, keep it.

2. **CONFIG-1 Entry Point Decision**
   - What we know: `src/index.ts` is archived, `dist/index.js` is stale, `package.json` entry points are zombie references.
   - What's unclear: Whether any external code imports from `idumb-v2` as a library (vs. using CLI only).
   - Recommendation: Remove entry point fields. The `bin` field for CLI usage is unaffected.

3. **hivemind-context-governance Relevance**
   - What we know: It pulls `@opencode-ai/plugin` as a peer dependency. idumb-v2 lists it as a dependency.
   - What's unclear: Whether it's actively used in the current codebase or if it's leftover from v1.
   - Recommendation: Defer to Phase 7 or later. Not a blocker.

## Sources

### Primary (HIGH confidence)
- Live build output: `npm run build:app` — captured actual error (Monaco manualChunks conflict)
- Live typecheck output: `npm run typecheck:app` — captured actual TS2578 error
- Live test output: `npm test` — captured 10 suites, 591 assertions
- Codebase grep: Direct `@opencode-ai/sdk` imports in `app/` — 3 files found, 1 violation
- File system verification: `src/dashboard/shared/` confirmed non-existent, `src/index.ts` confirmed non-existent
- SDK type verification: `node_modules/@opencode-ai/sdk/dist/gen/types.gen.d.ts` — Provider, Agent, Path, VcsInfo confirmed exported
- Lockfile analysis: `package-lock.json` — `@opencode-ai/plugin` sourced from `hivemind-context-governance` peer dependency

### Secondary (MEDIUM confidence)
- `v2.0-MILESTONE-AUDIT.md` — audit findings used as investigation checklist, all items independently verified

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new libraries, all verified against installed versions
- Architecture: HIGH — all patterns verified in existing codebase, no speculation
- Pitfalls: HIGH — all pitfalls reproduced from actual build/typecheck failures
- Fix approaches: HIGH for GAP-1/GAP-2/GOV-1/DRIFT-1/DRIFT-2, MEDIUM for GOV-2/GOV-3 (TanStack serialization compat needs runtime testing)

**Research date:** 2026-02-11
**Valid until:** 2026-03-11 (stable — no dependency upgrades expected)
