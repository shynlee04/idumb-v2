---
phase: 07-chat-terminal
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - app/components/chat/StepCluster.tsx
  - app/components/chat/ChatMessages.tsx
  - app/routes/chat.$sessionId.tsx
  - app/hooks/useStreaming.ts
autonomous: true

must_haves:
  truths:
    - "User sees multi-step AI operations grouped into collapsible step clusters"
    - "User sees count badge on each cluster showing number of operations inside"
    - "User sees status display with icon + text + duration timer on each cluster"
    - "Latest/running step cluster is expanded, older completed clusters are collapsed"
    - "Tool calls and text within a step are nested inside their parent step cluster"
  artifacts:
    - path: "app/components/chat/StepCluster.tsx"
      provides: "Collapsible step cluster component with status, count badge, duration timer"
      min_lines: 70
    - path: "app/components/chat/ChatMessages.tsx"
      provides: "Updated message list rendering clustered message groups"
      min_lines: 40
    - path: "app/routes/chat.$sessionId.tsx"
      provides: "Part grouping logic that converts flat Part[] into clustered structure"
      min_lines: 100
  key_links:
    - from: "app/routes/chat.$sessionId.tsx"
      to: "app/components/chat/StepCluster.tsx"
      via: "import and render clustered parts"
      pattern: "import.*StepCluster"
    - from: "app/hooks/useStreaming.ts"
      to: "app/routes/chat.$sessionId.tsx"
      via: "StreamEvent type used for step boundary detection"
      pattern: "step-start|step-finish"
    - from: "app/components/chat/StepCluster.tsx"
      to: "app/components/chat/parts/ToolCallAccordion.tsx"
      via: "renders tool parts from Plan 07-01 inside clusters"
      pattern: "ToolCallAccordion"
---

<objective>
Implement step clustering — group SDK Parts by step-start/step-finish boundaries into collapsible clusters with count badges, status indicators, and duration timers.

Purpose: AI operations often involve multiple tool calls per step. Clustering reduces visual noise by grouping related operations, showing the latest/running step expanded while collapsing completed ones (CHAT-02).

Output: StepCluster component + part grouping logic + streaming step awareness.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-chat-terminal/07-RESEARCH.md
@.planning/phases/07-chat-terminal/07-CONTEXT.md
@.planning/phases/07-chat-terminal/07-01-SUMMARY.md
@app/components/chat/ChatMessage.tsx
@app/components/chat/ChatMessages.tsx
@app/components/chat/parts/ToolCallAccordion.tsx
@app/routes/chat.$sessionId.tsx
@app/hooks/useStreaming.ts
@app/shared/engine-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: StepCluster component and part grouping utility</name>
  <files>
    app/components/chat/StepCluster.tsx
    app/routes/chat.$sessionId.tsx
  </files>
  <action>
**Create StepCluster.tsx** (~100 LOC):

Define a `ClusteredGroup` type for the output of part grouping:
```typescript
export interface ClusteredGroup {
  /** Unique key for React rendering */
  key: string
  /** 'step' for step-bounded groups, 'content' for ungrouped text/file parts */
  type: 'step' | 'content'
  /** Parts inside this group (excluding step-start/step-finish themselves) */
  parts: Part[]
  /** Step status: 'running' if no step-finish yet, 'completed' if step-finish found, 'failed' if step-finish reason contains error */
  status: 'running' | 'completed' | 'failed'
  /** Number of tool calls in this group */
  toolCount: number
  /** Duration in milliseconds (computed from step-start to step-finish or Date.now()) */
  durationMs: number
  /** StepFinishPart data if completed (cost, tokens) */
  finish?: { reason: string; cost: number; tokens: { input: number; output: number } }
}
```

**StepCluster component** props: `{ group: ClusteredGroup; isLatest: boolean }`
- `isLatest` controls initial expanded state (latest expanded, others collapsed)
- Use `useState(isLatest)` for open/closed state
- **Header row** (always visible, clickable to toggle):
  - Status icon: spinner for running (Loader2 animate-spin), checkmark (CheckCircle) for completed, X (XCircle) for failed — from lucide-react
  - Status text: "Running {toolCount} tools..." / "Completed {toolCount} tools" / "Failed"
  - Duration: formatted as "X.Xs" or "Xm Xs" for longer durations
  - Count badge: small `bg-muted rounded-full px-1.5 text-[10px]` showing `toolCount`
  - Chevron (ChevronRight/ChevronDown) on the right
  - Colors: running=blue, completed=muted, failed=destructive
- **Expanded body** (visible when open):
  - Render each `group.parts` through the existing `PartRenderer` from ChatMessage.tsx
  - Import and use the PartRenderer or render parts inline using the part components from Plan 07-01
- **Animation**: `transition-all duration-200` on the body container, `max-h-0 overflow-hidden` when collapsed
- Per user decision: "icon + text + duration timer" and "count badge"

**Create groupPartsIntoClusters utility function** (export from StepCluster.tsx or a separate util):

```typescript
export function groupPartsIntoClusters(parts: Part[]): ClusteredGroup[]
```

Algorithm:
1. Walk through parts sequentially
2. When encountering `step-start`: begin a new step group, push subsequent parts into it
3. When encountering `step-finish`: close the current step group, set status/duration/finish data
4. Parts outside any step (before first step-start, or between step-finish and next step-start): group as `type: 'content'`
5. If a step-start has no matching step-finish: status = 'running', durationMs = Date.now() - start timestamp
6. Count tool parts: `parts.filter(p => p.type === 'tool').length`
7. Filter out step-start and step-finish parts from the `parts` array in each group (they're metadata, not renderable)

**Update chat.$sessionId.tsx**:

1. Import `groupPartsIntoClusters` and `StepCluster`
2. In the `historyMessages` useMemo, convert from flat `ChatMessageData[]` to a structure that preserves Part arrays per message
3. Add a new component `ClusteredMessage` that:
   - Takes `{ message: ChatMessageData }`
   - If message has `parts`: call `groupPartsIntoClusters(message.parts)` to get clustered groups
   - Render each group: if `type === 'content'`, render parts directly. If `type === 'step'`, render `<StepCluster>`
   - Mark the last step group as `isLatest={true}` (expanded)
   - Non-step parts (text, file without steps) render directly via PartRenderer
   - If message has `content` (streaming text), render as before (plain markdown)
4. Replace `<ChatMessage>` usage in the message list with `<ClusteredMessage>` for assistant messages (user messages don't have steps)

Keep user messages rendering as-is (no clustering for user messages).
  </action>
  <verify>
`npm run typecheck:app` passes. The groupPartsIntoClusters function correctly groups test data: a sequence of [text, step-start, tool, tool, step-finish, step-start, tool, text] should produce [content(text), step(tool,tool), step(tool)] groups.
  </verify>
  <done>
StepCluster component renders collapsible step groups with status icon, tool count badge, and duration timer. groupPartsIntoClusters converts flat Part[] into ClusteredGroup[]. Assistant messages in chat render with step clustering — latest step expanded, older collapsed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Streaming step awareness</name>
  <files>
    app/hooks/useStreaming.ts
    app/routes/chat.$sessionId.tsx
  </files>
  <action>
**Enhance useStreaming.ts** to track step boundaries during streaming:

1. Add `streamingParts` to the streaming state — accumulate Part objects from SSE events (not just text):
   ```typescript
   interface StreamingState {
     isStreaming: boolean
     events: StreamEvent[]
     streamingParts: Part[]  // NEW: accumulated parts from streaming
     error: string | null
   }
   ```

2. In the SSE parsing loop, detect Part-related events from the SDK:
   - Event type `message.part.updated` with `properties.part` containing a Part object
   - When a new Part arrives, append to `streamingParts`
   - When an existing Part updates (same `part.id`), replace in `streamingParts`
   - Detect Part type from `properties.part.type` — accumulate TextPart, ToolPart, ReasoningPart, StepStartPart, StepFinishPart, FilePart

3. In `clearEvents`, also clear `streamingParts: []`

4. The existing `extractTextFromEvent` function stays for backward compat but the primary rendering path should use `streamingParts` when available

**Update chat.$sessionId.tsx** streaming message construction:

1. Get `streamingParts` from useStreaming (alongside events)
2. Build the streaming assistant message with both paths:
   - If `streamingParts.length > 0`: use `parts: streamingParts` (enables step clustering during streaming)
   - Else fall back to text-based `content` from `extractTextFromEvent` (backward compat)
3. The `ClusteredMessage` component from Task 1 handles both cases — if streaming message has `parts`, it will cluster them; if it has `content`, it renders plain markdown
4. During streaming, the latest step will naturally be `status: 'running'` (no step-finish yet) and `isLatest={true}` (expanded)

**Key considerations:**
- SDK SSE events carry Part data in `event.properties.part` — validate that the part has `.type` and `.id` before adding
- Streaming parts are ephemeral — when streaming ends and session messages are re-fetched, the server-sourced parts replace streaming parts
- Use functional setState to avoid stale closure issues: `setState(prev => ({ ...prev, streamingParts: [...prev.streamingParts, newPart] }))`
- For Part updates (e.g., ToolPart status going from 'running' to 'completed'), match by `part.id` and replace
  </action>
  <verify>
`npm run typecheck:app` passes. During an active chat session: sending a prompt that triggers tool use should show a running step cluster with tool accordions inside. When the step completes, the cluster should auto-collapse and show "Completed N tools — X.Xs".
  </verify>
  <done>
useStreaming accumulates Part objects from SSE events during streaming. chat.$sessionId.tsx constructs streaming messages with parts (enabling live step clustering). Running steps show expanded with spinner, completed steps auto-collapse with duration. Step clustering works for both historical messages and live streaming.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck:app` — zero errors
2. `npm run build:app` — succeeds
3. Historical messages: assistant messages with multiple steps show collapsed step clusters with count badges
4. Streaming: active AI responses show running step cluster expanded, with tool calls appearing inside as they execute
5. Step status: completed steps show green checkmark + duration, running shows blue spinner
6. No regression: simple text-only messages still render correctly (no steps = no clustering)
</verification>

<success_criteria>
- StepCluster component exists with collapsible UI, status icons, count badges, duration timers
- groupPartsIntoClusters correctly groups Part[] by step-start/step-finish boundaries
- Historical messages render with step clustering
- Streaming messages accumulate Parts and render with live step clustering
- Latest/running cluster expanded, older collapsed (user locked decision)
- No regressions on existing chat functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-chat-terminal/07-02-SUMMARY.md`
</output>
