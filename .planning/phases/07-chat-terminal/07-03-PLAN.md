---
phase: 07-chat-terminal
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - app/server/pty.server.ts
  - app/hooks/useTerminal.ts
  - app/components/terminal/TerminalPanel.tsx
  - app/components/ide/IDEShell.tsx
  - app/routes/terminal.tsx
  - app/styles/app.css
autonomous: true

must_haves:
  truths:
    - "User executes commands in an integrated terminal with ANSI color rendering"
    - "Terminal is available in IDE bottom panel and as standalone /terminal page"
    - "Terminal resizes correctly when panel is dragged or window is resized"
    - "Terminal matches app theme (dark background, consistent colors)"
    - "Terminal process is cleaned up when navigating away or closing the panel"
  artifacts:
    - path: "app/server/pty.server.ts"
      provides: "Server functions for PTY lifecycle via SDK client.pty.* API"
      exports: ["createPtyFn", "listPtyFn", "removePtyFn", "resizePtyFn", "getPtyConnectionInfoFn"]
      min_lines: 60
    - path: "app/hooks/useTerminal.ts"
      provides: "Hook managing PTY lifecycle, WebSocket connection, and xterm.js instance"
      min_lines: 80
    - path: "app/components/terminal/TerminalPanel.tsx"
      provides: "Terminal panel component wrapping xterm.js with header bar"
      min_lines: 50
    - path: "app/routes/terminal.tsx"
      provides: "Standalone terminal page route"
      min_lines: 15
  key_links:
    - from: "app/hooks/useTerminal.ts"
      to: "app/server/pty.server.ts"
      via: "createPtyFn to create PTY session"
      pattern: "createPtyFn"
    - from: "app/hooks/useTerminal.ts"
      to: "WebSocket"
      via: "connects xterm.js to SDK PTY WebSocket endpoint"
      pattern: "new WebSocket.*pty.*connect"
    - from: "app/components/ide/IDEShell.tsx"
      to: "app/components/terminal/TerminalPanel.tsx"
      via: "replaces TerminalPlaceholder"
      pattern: "TerminalPanel"
---

<objective>
Implement an integrated terminal using OpenCode SDK PTY API + xterm.js — available in the IDE bottom panel and as a standalone /terminal route.

Purpose: Users need to execute commands directly within the IDE without switching to an external terminal. The SDK provides built-in PTY management (no node-pty required), and xterm.js provides the terminal emulator frontend (IDE-03).

Output: PTY server functions, useTerminal hook, TerminalPanel component, IDEShell integration, standalone route.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-chat-terminal/07-RESEARCH.md
@.planning/phases/07-chat-terminal/07-CONTEXT.md
@app/server/sdk-client.server.ts
@app/components/ide/IDEShell.tsx
@app/stores/layout-store.ts
@app/shared/ide-types.ts
@app/vite.config.ts
@app/styles/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install xterm packages + PTY server functions + useTerminal hook</name>
  <files>
    package.json
    app/server/pty.server.ts
    app/server/validators.ts
    app/hooks/useTerminal.ts
  </files>
  <action>
**Install xterm.js packages:**
```bash
npm install @xterm/xterm @xterm/addon-fit
```
These provide: Terminal emulator, auto-resize addon, WebSocket attachment.
Do NOT install node-pty (SDK handles PTY — user locked decision).

**Create app/server/pty.server.ts** (~80 LOC):

Server functions wrapping SDK `client.pty.*` API. Use `.server.ts` suffix (prevents Vite client bundling).

```typescript
import { createServerFn } from "@tanstack/react-start"
import { getClient, getProjectDir, unwrapSdkResult, sdkQuery } from "./sdk-client.server"
import { getEngineStatus } from "./sdk-client.server"
import { z } from "zod"
```

Functions:
1. `createPtyFn` (POST) — calls `client.pty.create({ body: { title: "Terminal" }, query: sdkQuery() })`
   - Returns: `{ id: string, wsUrl: string }` where wsUrl is constructed from engine URL
   - Construct wsUrl: take engine URL from `getEngineStatus().url`, replace `http://` with `ws://`, append `/pty/${id}/connect`
   - Input: optional `{ command?: string, cwd?: string }`

2. `listPtyFn` (GET) — calls `client.pty.list({ query: sdkQuery() })`
   - Returns: array of PTY info objects

3. `removePtyFn` (POST) — calls `client.pty.remove({ path: { id }, query: sdkQuery() })`
   - Input: `{ id: string }`

4. `resizePtyFn` (POST) — calls `client.pty.update({ path: { id }, body: { size: { rows, cols } }, query: sdkQuery() })`
   - Input: `{ id: string, rows: number, cols: number }`

5. `getPtyConnectionInfoFn` (GET) — returns the WebSocket base URL for PTY connections
   - Returns: `{ baseUrl: string }` from engine status URL with ws:// scheme
   - This lets the frontend construct WebSocket URLs without hardcoding ports

**Add Zod validators to app/server/validators.ts:**
```typescript
export const PtyCreateSchema = z.object({
  command: z.string().optional(),
  cwd: z.string().optional(),
})

export const PtyIdSchema = z.object({
  id: z.string().min(1, "PTY ID is required"),
})

export const PtyResizeSchema = z.object({
  id: z.string().min(1, "PTY ID is required"),
  rows: z.number().int().positive(),
  cols: z.number().int().positive(),
})
```

**Create app/hooks/useTerminal.ts** (~120 LOC):

Custom hook managing the full PTY + xterm.js lifecycle:

```typescript
export function useTerminal(containerRef: React.RefObject<HTMLDivElement | null>)
```

Returns: `{ isConnected: boolean, error: string | null, reconnect: () => void }`

Implementation:
1. On mount (when containerRef.current exists):
   a. Import xterm.js dynamically: `const { Terminal } = await import("@xterm/xterm")`
   b. Import FitAddon: `const { FitAddon } = await import("@xterm/addon-fit")`
   c. Create Terminal instance with theme matching app theme:
      ```typescript
      const term = new Terminal({
        cursorBlink: true,
        fontSize: 13,
        fontFamily: "var(--font-mono)",
        theme: {
          background: "#1e1e2e",    // matches --color-terminal
          foreground: "#cdd6f4",    // matches --color-terminal-foreground
          cursor: "#f5e0dc",
          // ... standard dark theme colors for ANSI
        },
      })
      ```
   d. Load FitAddon: `term.loadAddon(fitAddon)`
   e. Open terminal: `term.open(containerRef.current)`
   f. Fit after mount: `requestAnimationFrame(() => fitAddon.fit())` — timing is critical per research

2. After terminal is open, create PTY and connect WebSocket:
   a. Call `createPtyFn()` to create a PTY session
   b. Get the `wsUrl` from the response
   c. Create WebSocket: `new WebSocket(wsUrl)`
   d. Pipe: `ws.onmessage = (e) => term.write(e.data)` (WS → terminal display)
   e. Pipe: `term.onData((data) => ws.send(data))` (terminal input → WS)
   f. Set `isConnected = true` when WS opens

3. Handle resize:
   - Listen to ResizeObserver on containerRef for size changes
   - On resize: `fitAddon.fit()`, then call `resizePtyFn({ id, rows: term.rows, cols: term.cols })`
   - Debounce resize calls (100ms) to avoid flooding the SDK

4. Cleanup on unmount:
   - Close WebSocket
   - Call `removePtyFn({ id })` to clean up the PTY process
   - Dispose terminal instance: `term.dispose()`
   - Disconnect ResizeObserver

5. Error handling:
   - WS close/error → set `isConnected = false`, set error message
   - `reconnect()` function: dispose everything, start fresh (call the whole mount sequence again)

**Important:** Dynamic imports for xterm.js are required because it uses DOM APIs that don't exist during SSR. Use `typeof window !== 'undefined'` guard.
  </action>
  <verify>
`npm run typecheck:app` passes. `@xterm/xterm` and `@xterm/addon-fit` are in package.json dependencies. All server functions exist with proper Zod validators. useTerminal hook compiles without type errors.
  </verify>
  <done>
xterm.js packages installed. PTY server functions wrap SDK client.pty.* API with Zod validation. useTerminal hook manages full lifecycle: PTY creation, WebSocket connection, xterm.js rendering, resize synchronization, cleanup on unmount.
  </done>
</task>

<task type="auto">
  <name>Task 2: TerminalPanel component + IDEShell integration + standalone route</name>
  <files>
    app/components/terminal/TerminalPanel.tsx
    app/components/ide/IDEShell.tsx
    app/routes/terminal.tsx
    app/styles/app.css
  </files>
  <action>
**Create app/components/terminal/TerminalPanel.tsx** (~60 LOC):

Component wrapping useTerminal with a header bar:

```typescript
export function TerminalPanel() {
  const containerRef = useRef<HTMLDivElement>(null)
  const { isConnected, error, reconnect } = useTerminal(containerRef)
  // ...
}
```

Layout:
- Header bar (h-8): "Terminal" label + connection status indicator (green/red dot) + reconnect button (if disconnected)
  - Use `TerminalSquare` icon from lucide-react
  - Status: green dot + "Connected" / red dot + "Disconnected"
  - Reconnect button: `RotateCcw` icon, only visible when disconnected
- Terminal container: `ref={containerRef}` div that fills remaining space (`flex-1`)
  - Background: `bg-terminal` (use the CSS variable from app.css)
  - Important: container must have explicit height (not just flex-1) for xterm.js to render correctly. Use `className="flex-1 min-h-0"` on the container.
- Error state: if error, show error message overlay with retry button

**Update app/components/ide/IDEShell.tsx:**

1. Replace the `TerminalPlaceholder` function with an import of `TerminalPanel`
2. Lazy-load TerminalPanel to avoid SSR issues with xterm.js:
   ```typescript
   const LazyTerminalPanel = lazy(() =>
     import('../terminal/TerminalPanel').then(m => ({ default: m.TerminalPanel }))
   )
   ```
3. In the terminal Panel render, wrap with Suspense:
   ```tsx
   <Panel id="terminal" ...>
     <Suspense fallback={<TerminalLoadingFallback />}>
       <LazyTerminalPanel />
     </Suspense>
   </Panel>
   ```
4. Create a small `TerminalLoadingFallback` component (same visual as old placeholder but with "Loading terminal..." text)
5. Delete the `TerminalPlaceholder` function entirely

**Create app/routes/terminal.tsx** (~20 LOC):

Standalone terminal page route at `/terminal`:
```typescript
import { createFileRoute } from "@tanstack/react-router"
import { lazy, Suspense } from "react"

const LazyTerminalPanel = lazy(() =>
  import("../components/terminal/TerminalPanel").then(m => ({ default: m.TerminalPanel }))
)

export const Route = createFileRoute("/terminal")({
  component: TerminalPage,
})

function TerminalPage() {
  return (
    <div className="h-screen w-screen bg-terminal">
      <Suspense fallback={<div className="flex h-full items-center justify-center text-muted-foreground">Loading terminal...</div>}>
        <LazyTerminalPanel />
      </Suspense>
    </div>
  )
}
```

**Update app/styles/app.css:**

Add xterm.js base CSS import (required for proper rendering):
```css
@import "@xterm/xterm/css/xterm.css";
```

Add terminal-specific overrides to match app theme:
```css
/* xterm.js theme overrides */
.xterm {
  padding: 4px;
}
.xterm-viewport {
  scrollbar-width: thin;
}
```

**After creating terminal.tsx**, regenerate the route tree:
```bash
cd app && npx @tanstack/router-cli generate
```
(Or it auto-generates on `npm run dev:app`)
  </action>
  <verify>
`npm run typecheck:app` passes. `npm run build:app` succeeds (xterm.js CSS resolves, lazy import works). Navigate to `/ide` — terminal should render in the bottom panel with a working shell. Navigate to `/terminal` — standalone terminal page works.
  </verify>
  <done>
TerminalPanel renders xterm.js terminal with connection status header. IDEShell uses lazy-loaded TerminalPanel instead of TerminalPlaceholder. Standalone /terminal route provides full-screen terminal. xterm.js CSS and theme overrides are loaded. Terminal matches app theme colors.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck:app` — zero errors
2. `npm run build:app` — succeeds (xterm.js is client-only, lazy-loaded, no SSR issues)
3. Navigate to /ide — bottom panel shows working terminal with shell prompt
4. Type commands in terminal — output appears with ANSI colors
5. Drag the terminal panel divider — terminal resizes correctly
6. Navigate to /terminal — full-screen terminal works
7. Navigate away from terminal and back — process cleanup and reconnection work
8. Connection status indicator shows green when connected
</verification>

<success_criteria>
- Terminal renders in IDE bottom panel (replaces placeholder)
- Terminal renders on standalone /terminal page
- SDK PTY API used (NOT node-pty) — per user locked decision
- Single terminal instance (NOT multi-tab) — per user locked decision
- ANSI colors render correctly
- Terminal resizes on panel drag
- Theme matches app theme — per user locked decision
- Process cleanup on disconnect/navigate-away
- xterm.js is lazy-loaded (no SSR issues)
</success_criteria>

<output>
After completion, create `.planning/phases/07-chat-terminal/07-03-SUMMARY.md`
</output>
