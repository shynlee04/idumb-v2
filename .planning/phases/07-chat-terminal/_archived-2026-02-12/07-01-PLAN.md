---
phase: 07-chat-terminal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/shared/engine-types.ts
  - app/components/chat/ChatMessage.tsx
  - app/components/chat/parts/TextPart.tsx
  - app/components/chat/parts/ToolCallPart.tsx
  - app/components/chat/parts/ReasoningPart.tsx
  - app/components/chat/parts/CodeBlock.tsx
  - app/styles/app.css
autonomous: true

must_haves:
  truths:
    - "User sees markdown-formatted chat messages (headings, bold, lists, links, inline code)"
    - "User sees syntax-highlighted code blocks with language badge and copy button"
    - "User sees tool invocations as collapsible cards showing tool name, status, input, and output"
    - "User sees AI reasoning/thinking content in a collapsed section"
    - "User sees image previews for file parts with image mime types"
    - "Messages without parts (legacy content string) still render correctly"
  artifacts:
    - path: "app/shared/engine-types.ts"
      provides: "Adds ToolState types, type guard helpers, and MessagePart alias to existing SDK re-exports"
      contains: "import type.*from '@opencode-ai/sdk'"
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Part-aware message renderer dispatching to sub-components"
      contains: "renderPart"
    - path: "app/components/chat/parts/CodeBlock.tsx"
      provides: "Syntax-highlighted code block with copy button"
      contains: "rehypeHighlight"
  key_links:
    - from: "app/components/chat/ChatMessage.tsx"
      to: "@opencode-ai/sdk"
      via: "SDK Part types imported through engine-types.ts"
      pattern: "Part|TextPart|ToolPart"
    - from: "app/components/chat/ChatMessage.tsx"
      to: "react-markdown"
      via: "ReactMarkdown component for text parts"
      pattern: "ReactMarkdown|react-markdown"
---

<objective>
Upgrade chat message rendering from raw text to rich markdown + AI message parts using SDK types.

Purpose: Transform the basic text-only chat UI into a professional AI assistant interface with proper markdown rendering, code blocks, tool call visualization, and reasoning display — matching Claude/ChatGPT quality. Uses the actual `@opencode-ai/sdk` Part types (not custom inventions).

Output: Updated ChatMessage component with SDK Part type dispatch, markdown rendering via react-markdown (already installed), syntax-highlighted code blocks, collapsible tool invocation cards, and reasoning sections.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-chat-terminal/07-RESEARCH.md

Key existing files:
@app/shared/engine-types.ts — Already imports and re-exports 14 SDK types (Part, TextPart, ToolPart, FilePart, ReasoningPart, StepStartPart, StepFinishPart, SnapshotPart, PatchPart, AgentPart, RetryPart, CompactionPart, Event, Session, SessionStatus, Message, UserMessage, AssistantMessage). Needs ToolState types + type guards added.
@app/components/chat/ChatMessage.tsx — Current: renders `content` string or concatenated `parts[].text`, no markdown
@app/components/chat/ChatMessages.tsx — Parent list component, auto-scroll
@app/hooks/useStreaming.ts — SSE hook that builds messages with parts array
@app/routes/chat.$sessionId.tsx — Chat session route consuming these components

SDK types reference (from node_modules/@opencode-ai/sdk/dist/gen/types.gen.d.ts):
- Part = TextPart | ToolPart | ReasoningPart | StepStartPart | StepFinishPart | FilePart | subtask | ...
- TextPart: { id, sessionID, messageID, type: 'text', text: string, synthetic?: boolean }
- ToolPart: { id, sessionID, messageID, type: 'tool', callID, tool: string, state: ToolState }
- ToolState = ToolStatePending | ToolStateRunning | ToolStateCompleted | ToolStateError
- ReasoningPart: { id, sessionID, messageID, type: 'reasoning', text: string, time: { start, end? } }
- StepStartPart: { type: 'step-start', snapshot? }
- StepFinishPart: { type: 'step-finish', reason: string, cost: number, tokens: {...} }
- FilePart: { type: 'file', mime: string, url: string, filename: string }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ToolState types, type guards, and MessagePart alias to engine-types.ts</name>
  <files>app/shared/engine-types.ts</files>
  <action>
  Update `engine-types.ts` to ADD new SDK types and type guards to the EXISTING import/export blocks. Do NOT replace the existing imports — the file already re-exports 14 SDK types from Phase 11 (Part, TextPart, ToolPart, FilePart, ReasoningPart, StepStartPart, StepFinishPart, SnapshotPart, PatchPart, AgentPart, RetryPart, CompactionPart, Event, Session, SessionStatus, Message, UserMessage, AssistantMessage).

  **Step 1: ADD to the existing SDK import block (do not replace it):**

  Add these types to the EXISTING `import type { ... } from '@opencode-ai/sdk'` block:
  ```typescript
  ToolState,
  ToolStatePending,
  ToolStateRunning,
  ToolStateCompleted,
  ToolStateError,
  ```

  And add them to the EXISTING `export type { ... }` block as well.

  **Step 2: Add a MessagePart alias after the export block:**
  ```typescript
  // Use SDK Part type as the canonical MessagePart
  export type MessagePart = Part
  ```

  **Step 3: Add type guard functions (below the exports, before the app-specific types section):**
  ```typescript
  // Type guards for Part discrimination
  export function isTextPart(part: MessagePart): part is TextPart {
    return part.type === 'text'
  }
  export function isToolPart(part: MessagePart): part is ToolPart {
    return part.type === 'tool'
  }
  export function isReasoningPart(part: MessagePart): part is ReasoningPart {
    return part.type === 'reasoning'
  }
  export function isStepStart(part: MessagePart): part is StepStartPart {
    return part.type === 'step-start'
  }
  export function isStepFinish(part: MessagePart): part is StepFinishPart {
    return part.type === 'step-finish'
  }
  export function isFilePart(part: MessagePart): part is FilePart {
    return part.type === 'file'
  }
  ```

  **Step 4: Check if SDK ToolState types import cleanly.** The SDK is `@opencode-ai/sdk` which is already in dependencies. The types are exported from `@opencode-ai/sdk` (check: `import type { ToolState } from '@opencode-ai/sdk'` should resolve).
  If the import fails, use path `@opencode-ai/sdk/dist/gen/types.gen.js` instead.

  **IMPORTANT:** Preserve ALL existing imports and exports. Only ADD the new types listed above.
  </action>
  <verify>Run `npm run typecheck` — no new type errors. Verify all 19+ SDK types are in the import and export blocks.</verify>
  <done>engine-types.ts adds ToolState types, type guards, and MessagePart alias to the existing SDK re-exports. All 14 previously-exported types are preserved. No custom Part definitions remain.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade ChatMessage to render markdown + parts with SDK types</name>
  <files>
    app/components/chat/ChatMessage.tsx
    app/components/chat/parts/TextPart.tsx
    app/components/chat/parts/ToolCallPart.tsx
    app/components/chat/parts/ReasoningPart.tsx
    app/components/chat/parts/CodeBlock.tsx
    app/styles/app.css
  </files>
  <action>
  Create 4 new part renderer components in `app/components/chat/parts/`:

  **CodeBlock.tsx** (~60 LOC):
  - Custom `code` component for react-markdown
  - If `className` contains `language-*`, render as a block with:
    - Language badge (top-right, extracted from className)
    - Copy button (copies code to clipboard via navigator.clipboard.writeText)
    - `<pre><code>` wrapper with highlight.js classes applied by rehype-highlight
  - If inline code (no className), render as `<code>` with subtle bg

  **TextPart.tsx** (~40 LOC):
  - Accepts `{ part: TextPart }` prop (SDK TextPart type has `text: string`)
  - Renders via `<ReactMarkdown>` with plugins:
    - `remarkGfm` — tables, strikethrough, task lists
    - `rehypeHighlight` — syntax highlighting
    - `rehypeRaw` — embedded HTML support
  - Custom components: `{ code: CodeBlock }` (for the code block rendering above)
  - Wrap in `<div className="prose prose-sm prose-invert max-w-none">` for typography

  **ToolCallPart.tsx** (~100 LOC):
  - Accepts `{ part: ToolPart }` prop (SDK ToolPart type)
  - **Key SDK shapes to handle:**
    - `part.tool` — tool name (string)
    - `part.state.status` — `'pending' | 'running' | 'completed' | 'error'`
    - `part.state.input` — tool input args (Record<string, unknown>)
    - `(part.state as ToolStateCompleted).output` — tool result (only when completed)
    - `(part.state as ToolStateCompleted).title` — display title (only when completed)
    - `(part.state as ToolStateError).error` — error message (only when error)
    - `(part.state as ToolStateRunning).title?` — optional running title
  - Renders as a collapsible card:
    - Header: tool icon (lucide Wrench icon) + `part.tool` name + status badge
    - Status badges:
      - `pending`: gray "Pending"
      - `running`: animated spinner + "Running..." + optional `state.title`
      - `completed`: green checkmark + `state.title` or "Done"
      - `error`: red X + "Error"
    - Collapsed by default (auto-expanded if `status === 'running'`), click to expand
    - Expanded shows: JSON.stringify(state.input, null, 2) in a `<pre>` block
    - If `completed`: show `state.output` below input
    - If `error`: show `state.error` in red below input
  - Use `<details>/<summary>` for native collapse

  **ReasoningPart.tsx** (~50 LOC):
  - Accepts `{ part: ReasoningPart }` prop (SDK ReasoningPart has `text: string`, NOT `reasoning: string`)
  - Renders as a collapsed `<details>` element:
    - `<summary>`: "Thinking..." in muted text
    - Body: `part.text` in a smaller, italicized, muted-foreground style
  - Always collapsed by default (user can open if curious)

  **Update ChatMessage.tsx**:
  - Import `isTextPart`, `isToolPart`, `isReasoningPart`, `isStepStart`, `isStepFinish`, `isFilePart`, `MessagePart` from `@/shared/engine-types`
  - Import part renderers from `./parts/`
  - Add `renderPart(part: MessagePart, index: number)` function that switches on part.type:
    - `'text'` -> `<TextPartRenderer part={part} />`
    - `'tool'` -> `<ToolCallPartRenderer part={part} />`
    - `'reasoning'` -> `<ReasoningPartRenderer part={part} />`
    - `'step-start'` / `'step-finish'` -> render nothing (handled by Plan 04 step clustering)
    - `'file'` -> **image-aware rendering:**
      - If `part.mime` starts with `'image/'`, render an image preview:
        ```tsx
        <div className="my-2">
          <img
            src={part.url}
            alt={part.filename || 'Image'}
            className="max-w-md rounded border border-border"
          />
          {part.filename && (
            <span className="block mt-1 text-xs text-muted-foreground">{part.filename}</span>
          )}
        </div>
        ```
      - Otherwise, render as a download link with mime type badge:
        ```tsx
        <div className="my-1 flex items-center gap-2">
          <a href={part.url} target="_blank" rel="noopener noreferrer"
             className="text-sm text-primary underline hover:text-primary/80">
            {part.filename || 'Download file'}
          </a>
          <span className="text-xs bg-muted px-1.5 py-0.5 rounded">{part.mime}</span>
        </div>
        ```
    - Unknown types -> render nothing (graceful degradation)
  - Keep the existing `content` string fallback: if message has `content` but no `parts`, wrap content in a TextPart-like render using ReactMarkdown directly
  - Remove the existing raw text rendering that concatenates `parts.map(p => p.text).join('')`

  **Update app/styles/app.css**:
  - Import highlight.js theme: `@import 'highlight.js/styles/github-dark.css';`
  - Add prose overrides for dark theme:
    ```css
    .prose pre { @apply bg-muted rounded-lg p-4 overflow-x-auto; }
    .prose code:not(pre code) { @apply bg-muted px-1.5 py-0.5 rounded text-sm; }
    ```
  </action>
  <verify>
  1. Run `npm run typecheck` — no errors
  2. Run the dev server and navigate to `/chat/{sessionId}`
  3. Send a message and verify: markdown headings render as h1/h2, code blocks have syntax highlighting, inline code has background
  4. If a FilePart with image mime type is present, verify image renders inline
  </verify>
  <done>ChatMessage dispatches to part renderers using SDK types. TextPart renders markdown via react-markdown. ToolPart shows collapsible cards with status/input/output. ReasoningPart shows collapsed thinking sections. FilePart renders images inline for image mime types, download links otherwise. Legacy content-only messages still work. Code blocks have copy buttons and language badges.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with zero new errors
- Chat messages at `/chat/$sessionId` render markdown (headings, bold, code)
- Code blocks show syntax highlighting with language badge
- Tool invocations display as expandable cards with correct status from SDK ToolState
- File parts with image mime types render as inline image previews
- File parts with non-image mime types render as download links with mime badge
- Messages with only `content` (no parts) still render correctly
</verification>

<success_criteria>
- SDK Part types used throughout (not custom definitions)
- Existing 14 SDK type re-exports preserved; ToolState types, type guards, and MessagePart alias added
- Markdown text renders with proper typography (headings, bold, lists, links, inline code)
- Code blocks have syntax highlighting, language badge, and copy-to-clipboard
- Tool parts render as collapsible cards with ToolState status: pending/running/completed/error
- Reasoning parts render as collapsed "Thinking..." sections with `.text` field
- File parts render images inline when mime starts with `image/`, download links otherwise
- No regression in existing chat flow (send message, see response)
</success_criteria>

<output>
After completion, create `.planning/phases/07-chat-terminal/07-01-SUMMARY.md`
</output>
