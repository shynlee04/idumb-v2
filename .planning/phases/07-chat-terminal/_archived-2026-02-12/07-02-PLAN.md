---
phase: 07-chat-terminal
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - app/server/terminal.ts
  - app/server/validators.ts
  - app/shared/engine-types.ts
  - app/components/ide/TerminalPanel.tsx
  - app/components/ide/TerminalInstance.tsx
  - app/stores/terminal-store.ts
  - app/components/ide/IDEShell.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "User sees a real terminal in the bottom panel of the IDE shell"
    - "User can type commands and see output with ANSI colors rendered"
    - "Terminal auto-resizes when the user drags the panel separator"
    - "User can open multiple terminal tabs via a + button"
    - "User can switch between terminal tabs and each preserves its scroll history"
    - "Closing a terminal tab kills the underlying PTY process"
    - "Navigating away from the page cleans up all PTY processes"
  artifacts:
    - path: "app/server/terminal.ts"
      provides: "Server functions wrapping SDK PTY lifecycle (create, resize, remove, list)"
      contains: "client.pty.create"
      exports: ["createPtyFn", "resizePtyFn", "removePtyFn", "listPtysFn"]
    - path: "app/components/ide/TerminalPanel.tsx"
      provides: "Multi-tab terminal panel with tab bar and + button"
      contains: "TerminalInstance"
    - path: "app/components/ide/TerminalInstance.tsx"
      provides: "Single xterm.js terminal connected to SDK PTY WebSocket"
      contains: "new Terminal"
    - path: "app/stores/terminal-store.ts"
      provides: "Zustand store managing terminal tab state"
      contains: "create<TerminalState>"
    - path: "app/components/ide/IDEShell.tsx"
      provides: "IDEShell with real TerminalPanel (not placeholder)"
      contains: "TerminalPanel"
  key_links:
    - from: "app/server/terminal.ts"
      to: "app/server/sdk-client.server.ts"
      via: "SDK client PTY API for create/resize/remove"
      pattern: "getClient.*pty"
    - from: "app/components/ide/TerminalInstance.tsx"
      to: "app/server/terminal.ts"
      via: "createPtyFn returns wsUrl for WebSocket connection"
      pattern: "createPtyFn|wsUrl"
    - from: "app/components/ide/TerminalPanel.tsx"
      to: "app/stores/terminal-store.ts"
      via: "Tab state management (add/remove/switch tabs)"
      pattern: "useTerminalStore"
    - from: "app/components/ide/IDEShell.tsx"
      to: "app/components/ide/TerminalPanel.tsx"
      via: "Import and render TerminalPanel replacing placeholder"
      pattern: "import.*TerminalPanel"
---

<objective>
Add a working integrated terminal to the IDE shell's bottom panel using the OpenCode SDK's built-in PTY API and xterm.js.

Purpose: Replace the TerminalPlaceholder with a real multi-tab terminal. The SDK handles all PTY process management (spawn, resize, kill) — no node-pty or custom WebSocket server needed. The frontend connects xterm.js directly to the SDK's PTY WebSocket endpoint.

Output: Server functions for PTY lifecycle, xterm.js TerminalInstance component, multi-tab TerminalPanel with Zustand store, integrated into IDEShell.

NOTE: This plan depends on 07-01 because both modify `app/shared/engine-types.ts`. Plan 07-01 adds ToolState types and type guards; this plan adds the Pty type to the same import/export blocks.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-chat-terminal/07-RESEARCH.md
@.planning/phases/07-chat-terminal/07-01-SUMMARY.md

Key existing files:
@app/server/sdk-client.server.ts — SDK client singleton; exports getClient(), getEngineStatus(), unwrapSdkResult(), sdkQuery()
@app/server/sessions.ts — Reference pattern for createServerFn + SDK client usage
@app/server/validators.ts — Zod schemas for server function inputs
@app/shared/engine-types.ts — SDK type re-exports (07-01 will have already added ToolState types + type guards; this plan adds Pty type)
@app/components/ide/IDEShell.tsx — Contains TerminalPlaceholder (line 53-66) used at line 296
@app/stores/layout-store.ts — Reference pattern for Zustand + persist + immer store

CRITICAL architecture notes from research:
- SDK provides `client.pty.create/connect/update/remove/list/get` — do NOT use node-pty
- SDK PTY WebSocket URL: `ws://localhost:{enginePort}/pty/{id}/connect`
- The engine port comes from `getEngineStatus().url` (replace http:// with ws://)
- `client.pty.create()` returns a Pty object: `{ id, title, command, args, cwd, status, pid }`
- Frontend connects xterm.js to WebSocket directly; resize/cleanup go through server functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install xterm packages + create PTY server functions + add Pty type export</name>
  <files>
    package.json
    app/server/terminal.ts
    app/server/validators.ts
    app/shared/engine-types.ts
  </files>
  <action>
  **Step 1: Install xterm.js packages**
  ```bash
  npm install @xterm/xterm @xterm/addon-fit @xterm/addon-attach
  ```
  These are ALL the terminal dependencies needed. Do NOT install node-pty or ws — the SDK handles PTY processes and WebSocket.

  **Step 2: Add Pty type to `app/shared/engine-types.ts`**

  ADD `Pty` to the existing SDK type import and export blocks (which by this point already contain the ToolState types added by 07-01). Do NOT replace the existing imports — only append `Pty` to both the import and export blocks:
  ```typescript
  // In the existing import block, add Pty:
  import type {
    // ...existing imports (Part, TextPart, ToolPart, ToolState, etc.)...
    Pty,
  } from '@opencode-ai/sdk'

  // In the existing export block, add Pty:
  export type {
    // ...existing exports...
    Pty,
  }
  ```

  If the SDK does not export a `Pty` type directly, define a local one matching the SDK shape:
  ```typescript
  /** PTY session info from SDK pty.create/get/list */
  export interface PtyInfo {
    id: string
    title: string
    command: string
    args: string[]
    cwd: string
    status: 'running' | 'exited'
    pid: number
  }
  ```

  **Step 3: Add PTY validators to `app/server/validators.ts`**

  Append these schemas to the existing validators file:
  ```typescript
  // -- PTY Server Function Validators --

  /** Validate PTY creation input. */
  export const CreatePtySchema = z.object({
    title: z.string().optional(),
    cwd: z.string().optional(),
  })

  /** Validate PTY ID input (for resize/remove/get). */
  export const PtyIdSchema = z.object({
    id: z.string().min(1, "PTY ID is required"),
  })

  /** Validate PTY resize input. */
  export const ResizePtySchema = z.object({
    id: z.string().min(1, "PTY ID is required"),
    rows: z.number().int().positive(),
    cols: z.number().int().positive(),
  })
  ```

  **Step 4: Create `app/server/terminal.ts`** (~100 LOC)

  Server functions wrapping the SDK PTY API. Follow the exact pattern from `app/server/sessions.ts`:

  ```typescript
  /**
   * Terminal PTY server functions.
   *
   * Wraps SDK client.pty.* API:
   * - POST /pty/create   -> createPtyFn
   * - POST /pty/resize   -> resizePtyFn
   * - POST /pty/remove   -> removePtyFn
   * - GET  /pty/list     -> listPtysFn
   */

  import { createServerFn } from "@tanstack/react-start"
  import { getClient, getEngineStatus, unwrapSdkResult } from "./sdk-client.server"
  import { CreatePtySchema, PtyIdSchema, ResizePtySchema } from "./validators"
  ```

  **Helper — construct WebSocket URL from engine HTTP URL:**
  ```typescript
  function getEngineWsBaseUrl(): string {
    const status = getEngineStatus()
    if (!status.url) {
      throw new Error("Engine not running — cannot create PTY WebSocket URL")
    }
    // Replace http:// or https:// with ws:// or wss://
    return status.url.replace(/^http/, 'ws')
  }
  ```

  **createPtyFn** — creates a PTY session, returns PTY info + WebSocket URL:
  ```typescript
  export const createPtyFn = createServerFn({ method: "POST" })
    .inputValidator(CreatePtySchema)
    .handler(async ({ data }) => {
      try {
        const result = await getClient().pty.create({
          body: {
            title: data.title || 'Terminal',
            ...(data.cwd ? { cwd: data.cwd } : {}),
          },
        })
        const pty = unwrapSdkResult(result)
        const wsBaseUrl = getEngineWsBaseUrl()
        const wsUrl = `${wsBaseUrl}/pty/${pty.id}/connect`
        return {
          id: pty.id,
          title: pty.title,
          status: pty.status,
          wsUrl,
        }
      } catch (err) {
        throw new Error(`Failed to create PTY: ${err instanceof Error ? err.message : String(err)}`)
      }
    })
  ```

  **resizePtyFn** — resizes the PTY terminal:
  ```typescript
  export const resizePtyFn = createServerFn({ method: "POST" })
    .inputValidator(ResizePtySchema)
    .handler(async ({ data }) => {
      try {
        await getClient().pty.update({
          path: { id: data.id },
          body: { size: { rows: data.rows, cols: data.cols } },
        })
        return { success: true as const }
      } catch (err) {
        throw new Error(`Failed to resize PTY: ${err instanceof Error ? err.message : String(err)}`)
      }
    })
  ```

  **removePtyFn** — kills the PTY process and cleans up:
  ```typescript
  export const removePtyFn = createServerFn({ method: "POST" })
    .inputValidator(PtyIdSchema)
    .handler(async ({ data }) => {
      try {
        await getClient().pty.remove({ path: { id: data.id } })
        return { success: true as const }
      } catch (err) {
        // Gracefully handle already-removed PTYs (e.g., process exited naturally)
        throw new Error(`Failed to remove PTY: ${err instanceof Error ? err.message : String(err)}`)
      }
    })
  ```

  **listPtysFn** — lists active PTY sessions (for multi-tab):
  ```typescript
  export const listPtysFn = createServerFn({ method: "GET" })
    .handler(async () => {
      try {
        const result = await getClient().pty.list()
        const ptys = unwrapSdkResult(result)
        return JSON.parse(JSON.stringify(ptys))
      } catch (err) {
        throw new Error(`Failed to list PTYs: ${err instanceof Error ? err.message : String(err)}`)
      }
    })
  ```
  </action>
  <verify>
  1. `npm run typecheck` passes with zero new errors
  2. Verify xterm packages installed: `ls node_modules/@xterm/xterm node_modules/@xterm/addon-fit node_modules/@xterm/addon-attach`
  3. Verify server functions compile: `npx tsc --noEmit app/server/terminal.ts` (or full typecheck)
  </verify>
  <done>PTY server functions created at app/server/terminal.ts wrapping SDK client.pty API. Validators added. Pty type re-exported from engine-types.ts. xterm.js packages installed. No node-pty, no custom WebSocket server.</done>
</task>

<task type="auto">
  <name>Task 2: Create TerminalInstance, multi-tab TerminalPanel, terminal store, and replace IDEShell placeholder</name>
  <files>
    app/components/ide/TerminalInstance.tsx
    app/components/ide/TerminalPanel.tsx
    app/stores/terminal-store.ts
    app/components/ide/IDEShell.tsx
  </files>
  <action>
  **Step 1: Create `app/stores/terminal-store.ts`** (~80 LOC)

  Zustand store for multi-tab terminal state. Follow the pattern from `app/stores/layout-store.ts` (Zustand + immer, no persist — tabs are ephemeral):

  ```typescript
  import { create } from 'zustand'
  import { immer } from 'zustand/middleware/immer'

  export interface TerminalTab {
    id: string      // PTY session ID from SDK
    title: string   // Display title (e.g., "Terminal 1")
    wsUrl: string   // WebSocket URL for xterm.js connection
    status: 'running' | 'exited' | 'connecting'
  }

  interface TerminalState {
    tabs: TerminalTab[]
    activeTabId: string | null

    // Actions
    addTab: (tab: TerminalTab) => void
    removeTab: (id: string) => void
    setActiveTab: (id: string) => void
    updateTabStatus: (id: string, status: TerminalTab['status']) => void
    updateTabTitle: (id: string, title: string) => void
  }
  ```

  Implement with immer:
  - `addTab`: push to `tabs` array, set as `activeTabId`
  - `removeTab`: splice from `tabs`, if removed tab was active, switch to the last remaining tab (or null if none)
  - `setActiveTab`: set `activeTabId`
  - `updateTabStatus`: find tab by id, update its status
  - `updateTabTitle`: find tab by id, update its title

  Export the store hook as `useTerminalStore`.

  **Step 2: Create `app/components/ide/TerminalInstance.tsx`** (~120 LOC)

  A single xterm.js terminal instance connected to an SDK PTY WebSocket. This component manages one terminal's lifecycle.

  ```typescript
  import { useEffect, useRef, useCallback } from 'react'
  import { Terminal } from '@xterm/xterm'
  import { FitAddon } from '@xterm/addon-fit'
  import { AttachAddon } from '@xterm/addon-attach'
  import '@xterm/xterm/css/xterm.css'
  import { resizePtyFn } from '@/server/terminal'
  ```

  Props:
  ```typescript
  interface TerminalInstanceProps {
    ptyId: string       // PTY session ID
    wsUrl: string       // WebSocket URL to connect to
    visible: boolean    // Whether this tab is currently active/visible
    onStatusChange?: (status: 'running' | 'exited') => void
  }
  ```

  Component structure:
  - `containerRef = useRef<HTMLDivElement>(null)` — xterm.js mount point
  - `terminalRef = useRef<Terminal | null>(null)` — Terminal instance
  - `fitAddonRef = useRef<FitAddon | null>(null)` — FitAddon instance
  - `wsRef = useRef<WebSocket | null>(null)` — WebSocket connection
  - `resizeTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)` — debounce timer

  **useEffect (mount — create terminal + connect WebSocket):**
  1. Create Terminal instance with IDE-matching dark theme:
     ```typescript
     const terminal = new Terminal({
       fontFamily: 'JetBrains Mono, Menlo, Monaco, Courier New, monospace',
       fontSize: 13,
       lineHeight: 1.4,
       theme: {
         background: 'hsl(240, 10%, 3.9%)',  // matches --background
         foreground: 'hsl(0, 0%, 98%)',       // matches --foreground
         cursor: 'hsl(0, 0%, 98%)',
         cursorAccent: 'hsl(240, 10%, 3.9%)',
         selectionBackground: 'rgba(255, 255, 255, 0.15)',
         // Standard ANSI colors for proper color rendering:
         black: '#1e1e2e', red: '#f38ba8', green: '#a6e3a1', yellow: '#f9e2af',
         blue: '#89b4fa', magenta: '#cba6f7', cyan: '#94e2d5', white: '#cdd6f4',
         brightBlack: '#585b70', brightRed: '#f38ba8', brightGreen: '#a6e3a1',
         brightYellow: '#f9e2af', brightBlue: '#89b4fa', brightMagenta: '#cba6f7',
         brightCyan: '#94e2d5', brightWhite: '#a6adc8',
       },
       cursorBlink: true,
       scrollback: 5000,
       convertEol: true,
     })
     ```
  2. Create FitAddon: `const fitAddon = new FitAddon()`
  3. Load addon: `terminal.loadAddon(fitAddon)`
  4. Open terminal: `terminal.open(containerRef.current!)`
  5. Fit to container: `fitAddon.fit()`
  6. Connect WebSocket: `const ws = new WebSocket(wsUrl)`
  7. On WebSocket open: `terminal.loadAddon(new AttachAddon(ws))`, call `onStatusChange?.('running')`
  8. On WebSocket close: write "Process exited" message to terminal, call `onStatusChange?.('exited')`
  9. On WebSocket error: write connection error message to terminal
  10. Store all refs for cleanup

  **useEffect (cleanup — runs on unmount):**
  - Clear resize timeout
  - `wsRef.current?.close()`
  - `terminalRef.current?.dispose()`
  - Clear all refs

  **useEffect (visibility — refit when tab becomes visible):**
  - When `visible` changes to `true` AND terminal exists: call `fitAddonRef.current?.fit()` on next frame via `requestAnimationFrame`
  - xterm.js requires the container to be visible to calculate dimensions correctly

  **ResizeObserver (auto-resize on panel drag):**
  - In the mount useEffect, create a `ResizeObserver` on `containerRef.current`
  - On resize callback:
    1. Call `fitAddonRef.current?.fit()` to refit terminal to new container size
    2. Debounce the SDK resize call (150ms) to avoid flooding during drag:
       ```typescript
       if (resizeTimeoutRef.current) clearTimeout(resizeTimeoutRef.current)
       resizeTimeoutRef.current = setTimeout(async () => {
         const term = terminalRef.current
         if (!term) return
         try {
           await resizePtyFn({ data: { id: ptyId, rows: term.rows, cols: term.cols } })
         } catch {
           // Resize failure is non-fatal — PTY continues working
         }
       }, 150)
       ```
  - Disconnect ResizeObserver in cleanup

  **Render:**
  ```tsx
  <div
    ref={containerRef}
    className="h-full w-full overflow-hidden"
    style={{ display: visible ? 'block' : 'none' }}
  />
  ```
  The `display: none` approach keeps the terminal instance alive but hidden when another tab is active, preserving scroll history.

  **Step 3: Create `app/components/ide/TerminalPanel.tsx`** (~130 LOC)

  Multi-tab terminal panel with tab bar and terminal instances.

  ```typescript
  import { useCallback, useEffect } from 'react'
  import { useTerminalStore, type TerminalTab } from '@/stores/terminal-store'
  import { TerminalInstance } from './TerminalInstance'
  import { createPtyFn, removePtyFn } from '@/server/terminal'
  ```

  **Auto-create first tab on mount:**
  ```typescript
  useEffect(() => {
    const { tabs } = useTerminalStore.getState()
    if (tabs.length === 0) {
      handleAddTab()
    }
  }, [])
  ```

  **handleAddTab callback:**
  ```typescript
  const handleAddTab = useCallback(async () => {
    try {
      const result = await createPtyFn({ data: { title: `Terminal ${tabs.length + 1}` } })
      addTab({
        id: result.id,
        title: result.title || `Terminal ${tabs.length + 1}`,
        wsUrl: result.wsUrl,
        status: 'connecting',
      })
    } catch (err) {
      // Show error in some way — could write to a fallback terminal or show toast
    }
  }, [tabs.length, addTab])
  ```

  **handleCloseTab callback:**
  ```typescript
  const handleCloseTab = useCallback(async (tabId: string) => {
    removeTab(tabId)
    try {
      await removePtyFn({ data: { id: tabId } })
    } catch {
      // PTY may already be gone — non-fatal
    }
  }, [removeTab])
  ```

  **Cleanup all PTYs on unmount (beforeunload + useEffect cleanup):**
  ```typescript
  useEffect(() => {
    const cleanup = () => {
      const { tabs } = useTerminalStore.getState()
      tabs.forEach(tab => {
        removePtyFn({ data: { id: tab.id } }).catch(() => {})
      })
    }
    window.addEventListener('beforeunload', cleanup)
    return () => {
      window.removeEventListener('beforeunload', cleanup)
      cleanup()
    }
  }, [])
  ```

  **Render:**
  ```tsx
  <div className="flex h-full flex-col bg-sidebar text-sidebar-foreground">
    {/* Tab bar */}
    <div className="flex h-8 items-center border-t border-border px-1 gap-0.5">
      {tabs.map((tab) => (
        <button
          key={tab.id}
          onClick={() => setActiveTab(tab.id)}
          className={`
            group flex items-center gap-1.5 px-2 py-1 text-xs rounded-t
            ${tab.id === activeTabId
              ? 'bg-background text-foreground'
              : 'text-muted-foreground hover:text-foreground hover:bg-muted/50'}
          `}
        >
          {/* Terminal icon (inline SVG or lucide Terminal icon) */}
          <span className="truncate max-w-[100px]">{tab.title}</span>
          {/* Status dot: green for running, gray for exited */}
          <span className={`h-1.5 w-1.5 rounded-full ${
            tab.status === 'running' ? 'bg-green-500' : 'bg-muted-foreground/50'
          }`} />
          {/* Close button — visible on hover */}
          <span
            onClick={(e) => { e.stopPropagation(); handleCloseTab(tab.id) }}
            className="opacity-0 group-hover:opacity-100 hover:text-destructive ml-0.5 cursor-pointer"
          >
            x
          </span>
        </button>
      ))}
      {/* Add tab button */}
      <button
        onClick={handleAddTab}
        className="flex h-6 w-6 items-center justify-center text-muted-foreground hover:text-foreground rounded hover:bg-muted/50 ml-0.5"
        title="New Terminal"
      >
        +
      </button>
    </div>

    {/* Terminal instances — all mounted, only active visible */}
    <div className="flex-1 overflow-hidden">
      {tabs.map((tab) => (
        <TerminalInstance
          key={tab.id}
          ptyId={tab.id}
          wsUrl={tab.wsUrl}
          visible={tab.id === activeTabId}
          onStatusChange={(status) => updateTabStatus(tab.id, status)}
        />
      ))}
      {/* Empty state when no tabs */}
      {tabs.length === 0 && (
        <div className="flex h-full items-center justify-center text-xs text-muted-foreground">
          No terminal open.{' '}
          <button onClick={handleAddTab} className="underline ml-1 hover:text-foreground">
            Create one
          </button>
        </div>
      )}
    </div>
  </div>
  ```

  **Step 4: Update `app/components/ide/IDEShell.tsx`**

  1. Add import at top: `import { TerminalPanel } from './TerminalPanel'`
  2. Delete the entire `TerminalPlaceholder` function (lines 53-66)
  3. Replace `<TerminalPlaceholder />` at line 296 with `<TerminalPanel />`
  4. Update the file header comment to note Terminal is now real (not placeholder)
  </action>
  <verify>
  1. `npm run typecheck` passes with zero new errors
  2. Start the dashboard dev server, navigate to `/ide`
  3. Bottom panel shows a real terminal with shell prompt (first tab auto-created)
  4. Type `ls` — see file listing with colors
  5. Type `echo -e "\033[31mRed\033[0m"` — verify ANSI color rendering
  6. Resize the terminal panel by dragging the separator — terminal re-fits to new size
  7. Click the `+` button — a second terminal tab appears
  8. Switch between tabs — each preserves its own shell state and scroll history
  9. Close a tab with the `x` button — tab disappears, underlying PTY is killed
  10. Close the browser tab — no orphan PTY processes remain (check `ps aux | grep pty`)
  </verify>
  <done>Multi-tab TerminalPanel renders xterm.js terminals connected to SDK PTY WebSocket. Tab management via Zustand store. Auto-resize on panel drag (debounced SDK resize calls). Automatic PTY cleanup on tab close and page unload. IDEShell uses real TerminalPanel instead of placeholder. ANSI colors rendered via xterm.js theme. All PTY lifecycle managed by SDK — no node-pty, no custom WebSocket server.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with zero new errors
- No `node-pty` in package.json dependencies — SDK handles PTY lifecycle
- No custom WebSocket server file exists — SDK provides PTY WebSocket endpoint
- `/ide` route shows working terminal in bottom panel with shell prompt
- Commands execute and produce colored output (ANSI rendering)
- Terminal resizes correctly when panel separator is dragged
- Multiple terminal tabs can be opened, switched, and closed
- Closing all tabs shows empty state with "Create one" link
- PTY processes are cleaned up on tab close and page unload
- `src/cli/dashboard.ts` is untouched — no PTY server to start
</verification>

<success_criteria>
- Bottom panel of IDE shell contains a working multi-tab terminal (not a placeholder)
- User can type shell commands and see output with ANSI colors
- Terminal uses the IDE's dark theme colors (background, foreground, ANSI palette)
- Panel resize causes terminal to re-fit via FitAddon + debounced SDK pty.update()
- Multiple tabs supported: add via +, switch by clicking, close via x
- Each tab has its own PTY session connected via SDK WebSocket
- Tab scroll history preserved when switching (display:none, not unmount)
- Clean shutdown: page unload kills all PTY processes via removePtyFn
- Status indicators: green dot for running, gray for exited
</success_criteria>

<output>
After completion, create `.planning/phases/07-chat-terminal/07-02-SUMMARY.md`
</output>
