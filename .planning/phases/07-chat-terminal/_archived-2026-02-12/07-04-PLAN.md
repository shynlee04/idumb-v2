---
phase: 07-chat-terminal
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - app/components/chat/StepCluster.tsx
  - app/components/chat/ChatMessage.tsx
autonomous: true

must_haves:
  truths:
    - "User sees multi-step AI operations grouped into collapsible step clusters"
    - "Each step cluster shows a count badge indicating how many parts are inside"
    - "Step clusters show status: spinning indicator while running, checkmark when complete, X when failed"
    - "User can expand a step cluster to see the individual parts (tool calls, text) within"
  artifacts:
    - path: "app/components/chat/StepCluster.tsx"
      provides: "Collapsible step cluster grouping parts between step-start and step-finish"
      contains: "step-start"
    - path: "app/components/chat/ChatMessage.tsx"
      provides: "Updated renderParts logic that detects step boundaries and renders StepCluster"
      contains: "StepCluster"
  key_links:
    - from: "app/components/chat/ChatMessage.tsx"
      to: "app/components/chat/StepCluster.tsx"
      via: "import StepCluster, group parts between step boundaries"
      pattern: "import.*StepCluster"
    - from: "app/components/chat/StepCluster.tsx"
      to: "app/components/chat/parts/TextPart.tsx"
      via: "renders child parts using the same part renderers from Plan 01"
      pattern: "renderPart|TextPart|ToolCallPart"
---

<objective>
Add step clustering to chat messages — group multi-step AI operations into collapsible containers.

Purpose: When the AI performs multi-step operations (e.g., read file -> think -> write file -> test), the individual parts are grouped between `step-start` and `step-finish` boundaries. This plan adds a collapsible StepCluster component that groups these parts visually, showing status (running/complete/failed) and part count badges.

Output: StepCluster component + updated ChatMessage rendering logic that detects step boundaries and renders clusters.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-chat-terminal/07-RESEARCH.md
@.planning/phases/07-chat-terminal/07-01-SUMMARY.md

Key files from Plan 01 (must exist before this plan):
@app/shared/engine-types.ts — MessagePart union with StepStartPart, StepFinishPart, type guards
@app/components/chat/ChatMessage.tsx — renderPart function dispatching to part renderers
@app/components/chat/parts/TextPart.tsx — Text part renderer with markdown
@app/components/chat/parts/ToolCallPart.tsx — Tool call card renderer
@app/components/chat/parts/ReasoningPart.tsx — Reasoning section renderer

SDK field reference:
- StepFinishPart uses `.reason` (NOT `.finishReason`) — e.g., `part.reason === 'stop'`
- StepFinishPart also has `.cost` and `.tokens` fields
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StepCluster component</name>
  <files>app/components/chat/StepCluster.tsx</files>
  <action>
  Create `app/components/chat/StepCluster.tsx` (~80 LOC):

  **Props:**
  ```typescript
  interface StepClusterProps {
    parts: MessagePart[]       // The parts BETWEEN step-start and step-finish
    stepIndex: number          // For display: "Step 1", "Step 2"
    status: 'running' | 'complete' | 'failed' | 'unknown'
    renderPart: (part: MessagePart, index: number) => React.ReactNode
  }
  ```

  **Rendering:**
  - Use `<details>` / `<summary>` for native collapse behavior
  - Summary line layout:
    ```
    [>] Step {N}  *  {partCount} actions  [status badge]
    ```
  - Status badge:
    - `running`: animated spinner (CSS animation, `animate-spin` on a circular SVG or Tailwind spinner) + "Running..." text
    - `complete`: green checkmark icon + "Complete" text
    - `failed`: red X icon + "Failed" text
    - `unknown`: gray question mark
  - Part count badge: `{parts.length} action(s)` in muted text
  - Expanded content: map `parts` through `renderPart()` prop (reuses the same renderers from ChatMessage)
  - Collapsed by default; last step is open if `status === 'running'`
  - Styling: left border accent (`border-l-2 border-primary/30`), slight indent, subtle background

  **Status derivation:**
  Status is passed in by ChatMessage (computed from the StepFinishPart).
  The SDK StepFinishPart uses the field `.reason` (NOT `.finishReason`):
  - If no `step-finish` part follows -> `'running'`
  - If `stepFinishPart.reason === 'stop'` -> `'complete'`
  - If `stepFinishPart.reason === 'error'` -> `'failed'`
  - Otherwise -> `'unknown'`
  </action>
  <verify>`npm run typecheck` passes. Component renders without errors in isolation.</verify>
  <done>StepCluster component renders a collapsible step container with status badge, part count, and child parts rendered via renderPart prop.</done>
</task>

<task type="auto">
  <name>Task 2: Update ChatMessage to detect step boundaries and render clusters</name>
  <files>app/components/chat/ChatMessage.tsx</files>
  <action>
  Update the `ChatMessage` component's part rendering logic to detect step boundaries:

  **Step detection algorithm:**
  Instead of rendering `parts.map((part, i) => renderPart(part, i))`, implement `groupPartsIntoSteps(parts: MessagePart[])`:

  ```typescript
  type PartGroup =
    | { type: 'standalone'; part: MessagePart }
    | { type: 'step'; parts: MessagePart[]; status: StepStatus; stepIndex: number }

  type StepStatus = 'running' | 'complete' | 'failed' | 'unknown'

  function groupPartsIntoSteps(parts: MessagePart[]): PartGroup[] {
    const groups: PartGroup[] = []
    let currentStep: MessagePart[] | null = null
    let stepIndex = 0

    for (const part of parts) {
      if (part.type === 'step-start') {
        // Begin new step group
        currentStep = []
        continue
      }
      if (part.type === 'step-finish') {
        // Close current step group
        if (currentStep) {
          const status = deriveStatus(part as StepFinishPart)
          groups.push({ type: 'step', parts: currentStep, status, stepIndex: ++stepIndex })
          currentStep = null
        }
        continue
      }
      if (currentStep !== null) {
        currentStep.push(part) // Part inside a step
      } else {
        groups.push({ type: 'standalone', part }) // Part outside any step
      }
    }

    // If step was started but not finished (still running)
    if (currentStep !== null) {
      groups.push({ type: 'step', parts: currentStep, status: 'running', stepIndex: ++stepIndex })
    }

    return groups
  }
  ```

  **deriveStatus helper — uses `.reason` field (NOT `.finishReason`):**
  ```typescript
  function deriveStatus(stepFinish: StepFinishPart): StepStatus {
    // SDK StepFinishPart uses `.reason`, not `.finishReason`
    if (stepFinish.reason === 'stop') return 'complete'
    if (stepFinish.reason === 'error') return 'failed'
    return 'unknown'
  }
  ```

  **Rendering update:**
  Replace the flat `parts.map(renderPart)` with:
  ```tsx
  const groups = groupPartsIntoSteps(message.parts)
  return groups.map((group, i) => {
    if (group.type === 'standalone') {
      return renderPart(group.part, i)
    }
    return (
      <StepCluster
        key={`step-${i}`}
        parts={group.parts}
        stepIndex={group.stepIndex}
        status={group.status}
        renderPart={renderPart}
      />
    )
  })
  ```

  **Graceful degradation:**
  - If no step-start/step-finish parts exist in a message -> all parts render as standalone (no visual change)
  - Messages with only `content` string (no parts) -> unchanged behavior
  - Single-step messages (one step-start/step-finish pair) -> one StepCluster
  - Multi-step messages -> multiple StepClusters

  Import `StepCluster` from `./StepCluster`.
  </action>
  <verify>
  1. `npm run typecheck` passes
  2. Send a message that triggers tool calls — verify parts are grouped into step clusters
  3. Simple text responses (no steps) render normally without clusters
  4. Step clusters show status badges and part counts
  </verify>
  <done>ChatMessage groups parts between step-start/step-finish into StepCluster components. Standalone parts outside steps render normally. Running steps show spinner. Completed steps show checkmark (derived from `.reason === 'stop'`). Failed steps show X (derived from `.reason === 'error'`). Uses SDK `.reason` field throughout.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with zero new errors
- Multi-step AI responses show as collapsible step clusters
- Each cluster has status badge and part count
- Single-step messages show one cluster
- Messages without steps render normally (no regression)
- Expanding a cluster shows the individual parts inside
- Status derived from `StepFinishPart.reason` (not `.finishReason`)
</verification>

<success_criteria>
- Step boundaries (step-start/step-finish) are detected and parts are grouped
- StepCluster is collapsible with status (running/complete/failed)
- Status derived from `StepFinishPart.reason` field: 'stop' -> complete, 'error' -> failed
- Part count badge shows how many actions are in each step
- Last running step is expanded by default
- No regression in non-step messages
</success_criteria>

<output>
After completion, create `.planning/phases/07-chat-terminal/07-04-SUMMARY.md`
</output>
