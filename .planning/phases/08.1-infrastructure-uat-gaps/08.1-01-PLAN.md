---
phase: 08.1-infrastructure-uat-gaps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/server/sdk-client.server.ts
  - app/db/index.server.ts
  - app/server/settings.ts
  - app/hooks/useSettings.ts
  - app/hooks/useSession.ts
  - app/components/chat/ChatMessages.tsx
  - app/components/layout/SessionSidebar.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "getProjectDir() returns git repository root, not app/ subdirectory — session.diff() returns actual file changes"
    - "DB migration runs reliably — settings table exists after startup"
    - "All settings.ts server functions return null/empty on DB failure, never throw unhandled"
    - "useSetting('default-model') in chat page does not crash when DB is unavailable"
    - "Revert/unrevert mutations have onError handlers — stale state is cleaned up on failure"
    - "Revert button is disabled during active streaming — no SDK 400 session-busy errors"
    - "Session search shows result count, clear/X button, and match highlighting in titles"
  artifacts:
    - path: "app/server/sdk-client.server.ts"
      provides: "Git-root-aware getProjectDir + ensureEngine"
      contains: "findGitRoot"
    - path: "app/db/index.server.ts"
      provides: "Robust DB migration with raw SQL fallback"
      contains: "CREATE TABLE IF NOT EXISTS"
    - path: "app/server/settings.ts"
      provides: "Defensive try/catch on all 4 server functions"
      contains: "catch"
    - path: "app/hooks/useSettings.ts"
      provides: "Resilient query config for settings reads"
      contains: "retry"
    - path: "app/hooks/useSession.ts"
      provides: "onError handlers for revert/unrevert mutations"
      contains: "onError"
    - path: "app/components/chat/ChatMessages.tsx"
      provides: "Streaming guard on revert button"
      contains: "disabled"
    - path: "app/components/layout/SessionSidebar.tsx"
      provides: "Search UX: result count, clear button, match highlighting"
      contains: "filteredSessions.length"
  key_links:
    - from: "app/server/sdk-client.server.ts"
      to: "session.diff()"
      via: "getProjectDir → ensureEngine → SDK directory parameter"
      pattern: "findGitRoot"
    - from: "app/db/index.server.ts"
      to: "app/server/settings.ts"
      via: "migrate creates settings table, settings.ts queries it"
      pattern: "CREATE TABLE IF NOT EXISTS.*settings"
    - from: "app/server/settings.ts"
      to: "app/hooks/useSettings.ts"
      via: "server function returns null on failure, hook receives null gracefully"
      pattern: "catch.*return null"
---

<objective>
Fix 7 cross-phase infrastructure defects diagnosed in Phase 8 UAT — project directory mismatch (diffs empty), DB migration failure (settings crash cascade), missing error handling (revert crashes silently), and session search UX gaps.

Purpose: Close UAT failures inherited from Phases 5/7 that block Phase 8 acceptance. All 7 fixes are independent, well-diagnosed, and touch separate files.
Output: 7 files patched, Phase 8 UAT Tests 1/4/7 closable.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files being patched
@app/server/sdk-client.server.ts
@app/db/index.server.ts
@app/server/settings.ts
@app/hooks/useSettings.ts
@app/hooks/useSession.ts
@app/components/chat/ChatMessages.tsx
@app/components/layout/SessionSidebar.tsx

# Consumer context
@app/routes/chat.$sessionId.tsx
@app/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix getProjectDir to resolve git repository root</name>
  <files>app/server/sdk-client.server.ts</files>
  <action>
Add a `findGitRoot(startDir: string): string` helper function that walks up from `startDir` to find the nearest directory containing `.git`. Import `existsSync` from `fs` and `dirname`, `resolve` from `path` (path is already imported via the logging import chain, but add explicit imports if needed).

Implementation:
```typescript
import { existsSync } from 'fs'
import { resolve, dirname } from 'path'

function findGitRoot(startDir: string): string {
  let dir = resolve(startDir)
  while (true) {
    if (existsSync(resolve(dir, '.git'))) return dir
    const parent = dirname(dir)
    if (parent === dir) return startDir // filesystem root reached, fallback to original
    dir = parent
  }
}
```

Modify `getProjectDir()` (line 177-179) to use `findGitRoot`:
```typescript
export function getProjectDir(): string {
  return engineProjectDir ?? findGitRoot(process.cwd())
}
```

Modify `ensureEngine()` (line 249) to use `findGitRoot` instead of raw `process.cwd()`:
```typescript
const dir = projectDir ?? findGitRoot(process.cwd())
```

Why: Vite sets `root: resolve(__dirname)` in vite.config.ts (which resolves to `app/`), so `process.cwd()` during SSR returns the `app/` subdirectory. The OpenCode SDK's `session.diff()` uses git snapshots internally — when the directory is not a git root, all snapshots are identical and diffs return empty.
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `findGitRoot` in sdk-client.server.ts to confirm it exists. Verify `getProjectDir` and `ensureEngine` both use `findGitRoot` instead of raw `process.cwd()`.
  </verify>
  <done>
`getProjectDir()` returns the git repository root (directory containing `.git`) regardless of Vite's CWD. `ensureEngine()` uses the same resolution. SDK calls now scope to the correct project directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make DB migration robust with raw SQL fallback</name>
  <files>app/db/index.server.ts</files>
  <action>
The current migration at lines 25-31 silently fails via try/catch, leaving the `settings` table missing. Add a raw SQL fallback that creates the `settings` table directly if migration fails.

After the existing try/catch block for `migrate()`, add a verification step:
```typescript
// Verify settings table exists — if not, create it directly as fallback
try {
  sqlite.exec(`
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY NOT NULL,
      value TEXT NOT NULL,
      updated_at INTEGER
    )
  `)
} catch (e) {
  process.stderr.write(`[idumb] Settings table creation fallback failed: ${e instanceof Error ? e.message : String(e)}\n`)
}
```

Also improve the migration error message to note the fallback:
```typescript
try {
  migrate(db, { migrationsFolder: resolve(import.meta.dirname, '../../drizzle') })
} catch (e) {
  process.stderr.write(`[idumb] Drizzle migration warning (will attempt fallback): ${e instanceof Error ? e.message : String(e)}\n`)
}
```

Why: The `drizzle/` migrations folder path resolves correctly, but migration can fail for various reasons (lock contention, first-run timing). The raw SQL fallback ensures the `settings` table always exists, preventing the crash cascade in settings.ts server functions.
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Read the file to confirm both the migrate() call and the CREATE TABLE IF NOT EXISTS fallback are present.
  </verify>
  <done>
DB initialization creates the `settings` table reliably — either via Drizzle migration or via raw SQL fallback. Settings server functions no longer encounter "no such table" errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add try/catch to all settings.ts server functions</name>
  <files>app/server/settings.ts</files>
  <action>
Wrap the body of each of the 4 server function handlers in try/catch blocks that return safe defaults on failure. This is the defensive layer — even if Task 2's migration fallback fails, settings functions degrade gracefully instead of crashing consumers.

**getSettingFn** (line 37-46): Wrap in try/catch, return `null` on error.
```typescript
.handler(async ({ data }): Promise<SettingsEntry | null> => {
  try {
    const row = db.select().from(settings).where(eq(settings.key, data.key)).get()
    if (!row) return null
    return { key: row.key, value: row.value, updatedAt: row.updatedAt ?? null }
  } catch {
    return null
  }
})
```

**setSettingFn** (line 51-62): Wrap in try/catch, return input values with null updatedAt on error.
```typescript
.handler(async ({ data }): Promise<SettingsEntry> => {
  try {
    const now = new Date()
    db.insert(settings).values({ key: data.key, value: data.value, updatedAt: now })
      .onConflictDoUpdate({ target: settings.key, set: { value: data.value, updatedAt: now } })
      .run()
    return { key: data.key, value: data.value, updatedAt: now ?? null }
  } catch {
    return { key: data.key, value: data.value, updatedAt: null }
  }
})
```

**getAllSettingsFn** (line 66-69): Wrap in try/catch, return `[]` on error.
```typescript
.handler(async (): Promise<SettingsEntry[]> => {
  try {
    const rows = db.select().from(settings).all()
    return rows.map((r) => ({ key: r.key, value: r.value, updatedAt: r.updatedAt ?? null }))
  } catch {
    return []
  }
})
```

**deleteSettingFn** (line 74-77): Wrap in try/catch, return `{ success: false }` on error.
```typescript
.handler(async ({ data }): Promise<{ success: boolean }> => {
  try {
    db.delete(settings).where(eq(settings.key, data.key)).run()
    return { success: true }
  } catch {
    return { success: false }
  }
})
```

Why: Consumer components (especially `useSetting("default-model")` in chat.$sessionId.tsx) call these functions during render. If they throw, the entire page crashes. Graceful degradation keeps the app functional even when the DB is unavailable.
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `catch` in settings.ts to confirm all 4 handlers have try/catch blocks.
  </verify>
  <done>
All 4 settings server functions return safe defaults on DB failure. No unhandled exceptions propagate to consumer hooks or components.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add retry resilience to useSetting hook</name>
  <files>app/hooks/useSettings.ts</files>
  <action>
Update the `useSetting()` hook (lines 27-33) to add `retry: 1` (one retry instead of React Query's default 3) and `retryDelay: 1000`. This prevents hammering a broken DB with repeated retries when the settings table is unavailable.

```typescript
export function useSetting(key: string) {
  return useQuery({
    queryKey: settingsKeys.single(key),
    queryFn: () => getSettingFn({ data: { key } }),
    staleTime: 5_000,
    retry: 1,
    retryDelay: 1000,
  })
}
```

Also update `useSettings()` (lines 36-42) with the same resilience:
```typescript
export function useSettings() {
  return useQuery({
    queryKey: settingsKeys.all,
    queryFn: () => getAllSettingsFn(),
    staleTime: 5_000,
    retry: 1,
    retryDelay: 1000,
  })
}
```

Why: Combined with Task 3's try/catch in settings.ts, this provides a second layer of protection. If the server function somehow still throws (edge cases), React Query won't hammer it 3 times — it retries once, then surfaces the error gracefully. The chat page continues to function because `data` is undefined/null (handled by the `defaultModel` memo's `if (!defaultModelSetting?.value) return null` guard).
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `retry: 1` in useSettings.ts.
  </verify>
  <done>
Settings hooks retry at most once on failure, preventing retry storms against a broken DB. Chat page remains stable when default-model setting is unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add onError handlers to revert/unrevert mutations</name>
  <files>app/hooks/useSession.ts</files>
  <action>
Add `onError` callbacks to both `useRevertSession()` (lines 133-143) and `useUnrevertSession()` (lines 145-154) that invalidate queries to reset stale state when the mutation fails.

**useRevertSession** — add `onError` that invalidates session detail and messages (same keys as onSuccess) to prevent the UI from showing stale revert state:
```typescript
export function useRevertSession() {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: (params: { id: string; messageID: string; partID?: string }) =>
      revertSessionFn({ data: params }),
    onSuccess: (_data, params) => {
      queryClient.invalidateQueries({ queryKey: sessionKeys.detail(params.id) })
      queryClient.invalidateQueries({ queryKey: sessionKeys.messages(params.id) })
    },
    onError: (_error, params) => {
      queryClient.invalidateQueries({ queryKey: sessionKeys.detail(params.id) })
      queryClient.invalidateQueries({ queryKey: sessionKeys.messages(params.id) })
    },
  })
}
```

**useUnrevertSession** — add `onError` similarly:
```typescript
export function useUnrevertSession() {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: (id: string) => unrevertSessionFn({ data: { id } }),
    onSuccess: (_data, id) => {
      queryClient.invalidateQueries({ queryKey: sessionKeys.detail(id) })
      queryClient.invalidateQueries({ queryKey: sessionKeys.messages(id) })
    },
    onError: (_error, id) => {
      queryClient.invalidateQueries({ queryKey: sessionKeys.detail(id) })
      queryClient.invalidateQueries({ queryKey: sessionKeys.messages(id) })
    },
  })
}
```

Why: Without onError, failed revert/unrevert mutations silently leave the UI in a stale state — the user thinks the revert happened but it didn't. Invalidating queries forces a refetch, syncing the UI to the actual session state. The `isError`/`error` properties on the mutation object are also populated by React Query, enabling the consumer (chat.$sessionId.tsx) to access error state if needed (Phase 8.5 can add toast/inline error display).
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `onError` in useSession.ts to confirm both mutations have error handlers.
  </verify>
  <done>
Revert/unrevert failures invalidate stale queries and populate mutation error state. UI syncs to actual session state on failure. Error is no longer silently swallowed.
  </done>
</task>

<task type="auto">
  <name>Task 6: Disable revert button during active streaming</name>
  <files>app/components/chat/ChatMessages.tsx</files>
  <action>
The revert button (lines 60-74) is always clickable, even during active streaming. Clicking revert while the SDK is processing a prompt causes a 400 "session busy" error. The `streaming` prop is already available on `ChatMessagesProps` but not used for the revert button.

Add `disabled` and visual styling to the revert button when `streaming` is true:

In the revert button JSX (lines 60-74), add:
- `disabled={streaming}` attribute to the button element
- Add `disabled:opacity-30 disabled:cursor-not-allowed` to the className
- Conditionally set `title` to explain why it's disabled

Updated button:
```tsx
{msg.role === "user" && msg.messageId && onRevert && (
  <button
    type="button"
    onClick={() => onRevert(msg.messageId!)}
    disabled={streaming}
    className={cn(
      "absolute top-3 right-0 flex items-center gap-1 px-1.5 py-0.5 rounded text-xs",
      "text-muted-foreground hover:text-amber-500 transition-colors",
      "opacity-0 group-hover/msg:opacity-100",
      "disabled:opacity-30 disabled:cursor-not-allowed disabled:hover:text-muted-foreground"
    )}
    title={streaming ? "Cannot revert during active streaming" : "Revert to this message"}
  >
    <RotateCcw className="w-3 h-3" />
    <span>Revert</span>
  </button>
)}
```

Why: The OpenCode SDK returns HTTP 400 when you call session.revert() on a session that is actively processing a prompt. The existing `streaming` prop is available but unused for this guard.
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `disabled.*streaming` in ChatMessages.tsx to confirm the guard exists.
  </verify>
  <done>
Revert button is visually disabled and non-clickable during active streaming. Prevents SDK 400 "session busy" errors. Button re-enables when streaming completes.
  </done>
</task>

<task type="auto">
  <name>Task 7: Add session search UX — result count, clear button, match highlighting</name>
  <files>app/components/layout/SessionSidebar.tsx</files>
  <action>
Three search UX improvements to fix UAT Test 1 (users perceive filtering as deletion because there's no visual context).

**1. Result count indicator** — Add between the search input (line 138) and the IDE Shell link (line 142). Show "N of M sessions" when a search query is active:
```tsx
{/* Result count — visible when filtering */}
{searchQuery.trim() && sessions && (
  <div className="px-3 pt-1">
    <span className="text-[10px] text-muted-foreground">
      {filteredSessions?.length ?? 0} of {sessions.length} sessions
    </span>
  </div>
)}
```

**2. Clear/X button on search input** — Add an X button inside the search input container (lines 123-138) that appears when `searchQuery` is non-empty. Import `X` from lucide-react (add to existing import on line 23):
```tsx
import { ..., X } from "lucide-react"
```

Update the search input container to include the clear button:
```tsx
<div className="px-2 pt-2">
  <div className="relative">
    <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-muted-foreground" />
    <input
      type="text"
      value={searchQuery}
      onChange={(e) => setSearchQuery(e.target.value)}
      placeholder="Search sessions..."
      className={cn(
        "w-full pl-7 pr-7 py-1.5 text-xs rounded-md",
        "bg-muted/50 border border-border",
        "text-foreground placeholder:text-muted-foreground",
        "focus:outline-none focus:ring-1 focus:ring-primary/50"
      )}
    />
    {searchQuery && (
      <button
        type="button"
        onClick={() => setSearchQuery("")}
        className="absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground transition-colors"
        title="Clear search"
      >
        <X className="w-3.5 h-3.5" />
      </button>
    )}
  </div>
</div>
```
Note: changed `pr-2` to `pr-7` on the input to make room for the X button.

**3. Match highlighting in session titles** — Create a `HighlightMatch` helper component and use it for the session title text (line 216). The component wraps matched substrings in a `<mark>` tag:
```tsx
function HighlightMatch({ text, query }: { text: string; query: string }) {
  if (!query.trim()) return <>{text}</>
  const lowerText = text.toLowerCase()
  const lowerQuery = query.toLowerCase()
  const index = lowerText.indexOf(lowerQuery)
  if (index === -1) return <>{text}</>
  return (
    <>
      {text.slice(0, index)}
      <mark className="bg-primary/20 text-inherit rounded-sm px-0.5">{text.slice(index, index + query.length)}</mark>
      {text.slice(index + query.length)}
    </>
  )
}
```

Replace the session title display (line 216) from:
```tsx
{session.title || `Session ${session.id.slice(0, 8)}`}
```
To:
```tsx
<HighlightMatch
  text={session.title || `Session ${session.id.slice(0, 8)}`}
  query={searchQuery}
/>
```

Why: UAT Test 1 reported users perceive filtering as deletion because items vanish without context. These three additions provide visual anchoring: the count confirms filtering is active, the X button offers easy reset, and highlighting shows WHY each result matched.
  </action>
  <verify>
Run `npm run typecheck:app` — zero errors. Grep for `HighlightMatch` and `filteredSessions?.length` in SessionSidebar.tsx to confirm all three features exist.
  </verify>
  <done>
Session search shows "N of M sessions" count, has a clear/X button on the input, and highlights matching text in session titles. Users clearly see filtering is active, not deletion.
  </done>
</task>

</tasks>

<verification>
After all 7 tasks complete:

1. **Typecheck**: `npm run typecheck:app` passes with zero errors
2. **Build**: `npm run build:app` succeeds (client + SSR)
3. **getProjectDir**: Grep `findGitRoot` in sdk-client.server.ts — function exists and is used by both getProjectDir and ensureEngine
4. **DB migration**: Grep `CREATE TABLE IF NOT EXISTS` in index.server.ts — fallback exists
5. **Settings safety**: Grep `catch` count in settings.ts — 4 catch blocks (one per handler)
6. **Settings retry**: Grep `retry: 1` in useSettings.ts — present in both hooks
7. **Revert error**: Grep `onError` in useSession.ts — present in both revert mutations
8. **Streaming guard**: Grep `disabled.*streaming` in ChatMessages.tsx — revert button has guard
9. **Search UX**: Grep `HighlightMatch` in SessionSidebar.tsx — component exists and is used
</verification>

<success_criteria>
- `npm run typecheck:app` passes with zero errors
- `npm run build:app` succeeds
- All 7 success criteria from the ROADMAP phase definition are addressed:
  1. getProjectDir resolves to git root (not app/)
  2. DB migration creates settings table reliably
  3. Settings server functions never throw unhandled
  4. useSetting("default-model") degrades gracefully
  5. Revert/unrevert mutations have error handling
  6. Revert button disabled during streaming
  7. Session search has count, clear, and highlighting
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-infrastructure-uat-gaps/08.1-01-SUMMARY.md`
</output>
