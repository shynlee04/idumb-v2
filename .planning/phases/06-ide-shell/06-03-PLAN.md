---
phase: 06-ide-shell
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - app/lib/monaco-workers.ts
  - app/components/editor/MonacoEditor.tsx
  - app/components/editor/MonacoEditor.lazy.tsx
  - app/components/editor/TabBar.tsx
  - app/components/editor/EditorArea.tsx
  - app/components/layout/IDELayout.tsx
  - app/routes/__root.tsx
autonomous: true

must_haves:
  truths:
    - "User sees an empty state message when no files are open"
    - "User sees a tab bar showing all open files with file names"
    - "User can click tabs to switch between open files"
    - "User sees syntax highlighting appropriate for the file type"
    - "User can edit code and see a dirty indicator (dot) on the tab"
    - "User can save with Cmd/Ctrl+S and the dirty indicator clears"
    - "User can close tabs with the X button"
    - "Cursor position and scroll are preserved when switching tabs"
    - "Monaco editor does not crash during SSR/build"
  artifacts:
    - path: "app/lib/monaco-workers.ts"
      provides: "Monaco Web Worker configuration for Vite"
      min_lines: 10
    - path: "app/components/editor/MonacoEditor.tsx"
      provides: "Single Monaco instance with model-swapping, view state save/restore, dirty tracking, save handler"
      min_lines: 80
    - path: "app/components/editor/MonacoEditor.lazy.tsx"
      provides: "React.lazy wrapper preventing SSR crash (pitfall P1)"
      min_lines: 8
    - path: "app/components/editor/TabBar.tsx"
      provides: "Tab bar with active highlight, dirty indicator, close button"
      min_lines: 30
    - path: "app/components/editor/EditorArea.tsx"
      provides: "Vertical layout: TabBar + Monaco + empty state"
      min_lines: 20
  key_links:
    - from: "app/components/editor/MonacoEditor.tsx"
      to: "app/stores/ide-store.ts"
      via: "reads activeTabId, calls markDirty/markClean/saveViewState"
      pattern: "useIDEStore"
    - from: "app/components/editor/MonacoEditor.tsx"
      to: "app/server/files.ts"
      via: "readFile for model content, writeFile for save"
      pattern: "import.*(readFile|writeFile)"
    - from: "app/components/editor/MonacoEditor.lazy.tsx"
      to: "app/components/editor/MonacoEditor.tsx"
      via: "React.lazy(() => import('./MonacoEditor'))"
      pattern: "lazy.*import.*MonacoEditor"
    - from: "app/components/editor/EditorArea.tsx"
      to: "app/components/editor/TabBar.tsx"
      via: "renders TabBar above LazyMonacoEditor"
      pattern: "import.*TabBar"
    - from: "app/components/layout/IDELayout.tsx"
      to: "app/components/editor/EditorArea.tsx"
      via: "renders EditorArea in editor panel"
      pattern: "import.*EditorArea"
    - from: "app/routes/__root.tsx"
      to: "app/lib/monaco-workers.ts"
      via: "dynamic import behind typeof window check"
      pattern: "import.*monaco-workers"
---

<objective>
Integrate Monaco editor with multi-tab management, model-swapping, save with dirty indicators, and wire into the IDE editor panel.

Purpose: Enable users to edit code files with syntax highlighting, multi-tab switching, and persistent cursor positions — the core IDE editing experience.
Output: Working code editor in the center panel with tab bar, syntax highlighting, save (Cmd/Ctrl+S), dirty indicators, and proper SSR-safe loading.
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ide-shell/06-RESEARCH.md
@.planning/phases/06-ide-shell/06-01-PLAN.md
@.planning/phases/06-ide-shell/06-02-SUMMARY.md

These files from 06-01 and 06-02 MUST exist:
- app/stores/ide-store.ts (Zustand store with openTabs, activeTabId, markDirty, markClean, saveViewState, closeTab, setActiveTab)
- app/server/files.ts (readFile, writeFile server functions)
- app/shared/file-types.ts (Tab type — path, name, isDirty)
- app/components/layout/IDELayout.tsx (three-panel layout, sidebar already has FileTree from 06-02)
- app/hooks/useFiles.ts (useFileContent hook for fetching file content)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Monaco worker config, editor component with model-swapping, and lazy SSR wrapper</name>
  <files>app/lib/monaco-workers.ts, app/components/editor/MonacoEditor.tsx, app/components/editor/MonacoEditor.lazy.tsx, app/routes/__root.tsx</files>
  <action>
  1. Create `app/lib/monaco-workers.ts` — Monaco Web Worker configuration (research Example 7):

     ```typescript
     import editorWorker from 'monaco-editor/esm/vs/editor/editor.worker?worker';
     import jsonWorker from 'monaco-editor/esm/vs/language/json/json.worker?worker';
     import cssWorker from 'monaco-editor/esm/vs/language/css/css.worker?worker';
     import htmlWorker from 'monaco-editor/esm/vs/language/html/html.worker?worker';
     import tsWorker from 'monaco-editor/esm/vs/language/typescript/ts.worker?worker';

     self.MonacoEnvironment = {
       getWorker(_: string, label: string) {
         if (label === 'json') return new jsonWorker();
         if (label === 'css' || label === 'scss' || label === 'less') return new cssWorker();
         if (label === 'html' || label === 'handlebars' || label === 'razor') return new htmlWorker();
         if (label === 'typescript' || label === 'javascript') return new tsWorker();
         return new editorWorker();
       },
     };
     ```

     This MUST be imported before any Monaco usage. Import it dynamically behind a `typeof window` check in `__root.tsx`:
     ```typescript
     // In __root.tsx, inside the RootComponent function or at module top:
     if (typeof window !== 'undefined') {
       import('../lib/monaco-workers');
     }
     ```

  2. Create `app/components/editor/MonacoEditor.tsx` — single editor instance with model-swapping:

     - Import `Editor, useMonaco` from `@monaco-editor/react`
     - Import `useRef, useEffect, useCallback` from `react`
     - Import `type { editor } from 'monaco-editor'`
     - Import `useIDEStore` from `../../stores/ide-store`
     - Import `readFile, writeFile` from `../../server/files`

     Language detection map (at module level):
     ```typescript
     const EXT_TO_LANG: Record<string, string> = {
       ts: 'typescript', tsx: 'typescriptreact', js: 'javascript', jsx: 'javascriptreact',
       json: 'json', css: 'css', scss: 'scss', html: 'html', md: 'markdown',
       py: 'python', rs: 'rust', go: 'go', yaml: 'yaml', yml: 'yaml',
       sh: 'shell', bash: 'shell', zsh: 'shell', toml: 'toml', sql: 'sql',
       xml: 'xml', svg: 'xml', graphql: 'graphql', gql: 'graphql',
     };
     function detectLanguage(filePath: string): string {
       const ext = filePath.split('.').pop()?.toLowerCase() ?? '';
       return EXT_TO_LANG[ext] ?? 'plaintext';
     }
     ```

     Component architecture (following research Example 2 pattern, adapted for NO content in Tab):
     ```typescript
     export function MonacoEditor() {
       const editorRef = useRef<editor.IStandaloneCodeEditor | null>(null);
       const modelsRef = useRef<Map<string, boolean>>(new Map()); // tracks which URIs have models
       const monaco = useMonaco();
       const activeTabId = useIDEStore(s => s.activeTabId);
       const markDirty = useIDEStore(s => s.markDirty);
       const saveViewState = useIDEStore(s => s.saveViewState);
     ```

     **Model-swapping effect** (runs when `activeTabId` changes):
     1. If no editor, no monaco, or no activeTabId → return
     2. Save current view state of the currently displayed model
     3. Construct URI: `monaco.Uri.parse('file://' + activeTabId)`
     4. Check if model exists: `monaco.editor.getModel(uri)`
     5. If model does NOT exist → fetch content via `readFile({ data: { filePath: activeTabId } })`, then `monaco.editor.createModel(content, detectLanguage(activeTabId), uri)`, then register in `modelsRef`
     6. Call `editorRef.current.setModel(model)`
     7. Restore view state if previously saved: `useIDEStore.getState().viewStates.get(uri.toString())`
     8. Focus editor

     **Content change listener** (in `onMount` callback):
     - `editor.onDidChangeModelContent(() => { const m = editor.getModel(); if (m) markDirty(m.uri.toString()); })`

     **Save handler** (Cmd/Ctrl+S):
     - In `onMount`, register keybinding: `editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, async () => { ... })`
     - Handler: get current model content via `editor.getModel()?.getValue()`, call `writeFile({ data: { filePath: activeTabId, content } })`, then `useIDEStore.getState().markClean('file://' + activeTabId)`

     **Cleanup effect** (pitfall P3 — memory leaks):
     - `useEffect(() => () => { editorRef.current?.dispose(); }, [])` — dispose editor on unmount
     - Do NOT dispose individual models here — they survive tab switches. Only dispose on tab close or LRU eviction.

     **LRU model cap** (20 models max):
     - After creating a new model, check `modelsRef.current.size`
     - If > 20, find the least recently used URI (not activeTabId, not in openTabs), dispose that model via `monaco.editor.getModel(uri)?.dispose()`, remove from `modelsRef`

     **Editor options** (vs-dark theme, no minimap):
     ```typescript
     <Editor
       theme="vs-dark"
       onMount={handleMount}
       options={{
         minimap: { enabled: false },
         fontSize: 14,
         lineNumbers: 'on',
         wordWrap: 'on',
         automaticLayout: true,
         scrollBeyondLastLine: false,
         padding: { top: 8 },
       }}
     />
     ```

  3. Create `app/components/editor/MonacoEditor.lazy.tsx` — SSR-safe lazy wrapper (pitfall P1 — CRITICAL):

     ```typescript
     import { lazy, Suspense } from 'react';

     const MonacoEditorInner = lazy(() => import('./MonacoEditor').then(m => ({ default: m.MonacoEditor })));

     export function LazyMonacoEditor() {
       if (typeof window === 'undefined') return null;
       return (
         <Suspense fallback={<div className="h-full bg-zinc-900 animate-pulse" />}>
           <MonacoEditorInner />
         </Suspense>
       );
     }
     ```

     This prevents Monaco from being evaluated during TanStack Start shell prerender (`_shell.html`). The `typeof window` guard is the first layer; `React.lazy` is the second layer ensuring the import only happens at runtime.

  4. Update `app/routes/__root.tsx` — add Monaco worker initialization:

     At the TOP of the file (after existing imports), add:
     ```typescript
     // Initialize Monaco workers (client-only)
     if (typeof window !== 'undefined') {
       import('../lib/monaco-workers');
     }
     ```

     This ensures workers are configured before any Monaco editor mounts. The dynamic import + typeof guard prevents SSR crash.
  </action>
  <verify>
  - `cat app/lib/monaco-workers.ts` — has 5 worker imports + MonacoEnvironment.getWorker
  - `cat app/components/editor/MonacoEditor.tsx` — has model-swapping effect, save handler (Cmd+S), dirty tracking, LRU cap, cleanup
  - `cat app/components/editor/MonacoEditor.lazy.tsx` — has React.lazy + typeof window guard + Suspense
  - `grep "monaco-workers" app/routes/__root.tsx` — dynamic import present
  - `npm run build:app` — builds WITHOUT SSR crash (this is the P1 pitfall test — if Monaco is imported at top-level, build will fail with "window is not defined")
  </verify>
  <done>Monaco editor with model-swapping, Cmd/Ctrl+S save, dirty tracking via onDidChangeModelContent, view state save/restore, 20-model LRU cap, and explicit disposal on unmount. SSR-safe via React.lazy + typeof window guard. Workers configured for TypeScript, JSON, CSS, HTML syntax support.</done>
</task>

<task type="auto">
  <name>Task 2: TabBar and EditorArea components, wire into IDELayout editor panel</name>
  <files>app/components/editor/TabBar.tsx, app/components/editor/EditorArea.tsx, app/components/layout/IDELayout.tsx</files>
  <action>
  1. Create `app/components/editor/TabBar.tsx` — tab bar with active highlight, dirty indicator, close:

     - Import `useIDEStore` from `../../stores/ide-store`
     - Import `X` from `lucide-react`
     - Import `Tab` from `../../shared/file-types`

     Component:
     ```typescript
     export function TabBar() {
       const openTabs = useIDEStore(s => s.openTabs);
       const activeTabId = useIDEStore(s => s.activeTabId);
       const setActiveTab = useIDEStore(s => s.setActiveTab);
       const closeTab = useIDEStore(s => s.closeTab);

       if (openTabs.length === 0) return null;

       return (
         <div className="flex items-center bg-zinc-950 border-b border-zinc-800 overflow-x-auto scrollbar-hide">
           {openTabs.map(tab => (
             <button
               key={tab.path}
               className={`group flex items-center gap-1.5 px-3 py-1.5 text-sm border-r border-zinc-800 shrink-0 ${
                 tab.path === activeTabId
                   ? 'bg-zinc-900 text-zinc-100'
                   : 'bg-zinc-950 text-zinc-500 hover:text-zinc-300 hover:bg-zinc-900/50'
               }`}
               onClick={() => setActiveTab(tab.path)}
             >
               <span className="truncate max-w-32">{tab.name}</span>
               {tab.isDirty && (
                 <span className="w-2 h-2 rounded-full bg-blue-400 shrink-0" title="Unsaved changes" />
               )}
               <span
                 className="ml-1 p-0.5 rounded hover:bg-zinc-700 opacity-0 group-hover:opacity-100 transition-opacity"
                 onClick={(e) => {
                   e.stopPropagation();
                   closeTab(tab.path);
                 }}
               >
                 <X size={12} />
               </span>
             </button>
           ))}
         </div>
       );
     }
     ```

     Key details:
     - `overflow-x-auto scrollbar-hide` for tab overflow (pitfall P8 — basic scroll for MVP)
     - Blue dot dirty indicator (`w-2 h-2 rounded-full bg-blue-400`) shown when `tab.isDirty`
     - Close button (`X` icon) revealed on hover via `opacity-0 group-hover:opacity-100`
     - `e.stopPropagation()` on close to prevent tab activation
     - Active tab: lighter background (`bg-zinc-900`), white text
     - Inactive: darker background, muted text, hover brightens

  2. Create `app/components/editor/EditorArea.tsx` — vertical layout combining TabBar + MonacoEditor:

     - Import `TabBar` from `./TabBar`
     - Import `LazyMonacoEditor` from `./MonacoEditor.lazy`
     - Import `useIDEStore` from `../../stores/ide-store`

     Component:
     ```typescript
     export function EditorArea() {
       const activeTabId = useIDEStore(s => s.activeTabId);

       return (
         <div className="h-full flex flex-col bg-zinc-900">
           <TabBar />
           <div className="flex-1 min-h-0">
             {activeTabId ? (
               <LazyMonacoEditor />
             ) : (
               <div className="h-full flex items-center justify-center text-zinc-500 text-sm">
                 <div className="text-center">
                   <p className="text-lg mb-1">No file open</p>
                   <p className="text-xs text-zinc-600">Click a file in the explorer to start editing</p>
                 </div>
               </div>
             )}
           </div>
         </div>
       );
     }
     ```

     Key details:
     - `min-h-0` on the editor container is CRITICAL for flexbox — without it, the editor won't fill available space
     - Empty state shows when `activeTabId` is null (no tabs open)
     - TabBar renders above the editor (natural vertical flow via `flex-col`)

  3. Modify `app/components/layout/IDELayout.tsx` — replace editor placeholder with EditorArea:

     - Import `EditorArea` from `../editor/EditorArea`

     Replace the editor panel placeholder `<div>` (currently showing "Open a file to start editing" placeholder text) with:
     ```tsx
     <EditorArea />
     ```

     Keep the chat panel placeholder unchanged (Phase 7).
     The sidebar should already have FileTree from 06-02 — do NOT touch the sidebar panel content.
  </action>
  <verify>
  - `cat app/components/editor/TabBar.tsx` — has tab rendering with dirty indicator, close button, overflow scroll
  - `cat app/components/editor/EditorArea.tsx` — has TabBar + LazyMonacoEditor + empty state
  - `grep "EditorArea" app/components/layout/IDELayout.tsx` — imported and rendered in editor panel
  - `npm run dev:app` — starts without errors
  - Navigate to `/` — shows three-panel layout with file tree in sidebar
  - Click a file in tree → tab appears in tab bar, Monaco editor shows file content with syntax highlighting
  - Edit content → dirty indicator (blue dot) appears on tab
  - Press Cmd/Ctrl+S → dirty indicator clears (file saved)
  - Open second file → second tab appears, click between tabs → content and cursor position switch correctly
  - Close a tab via X button → tab removed, adjacent tab activates
  - `npm run build:app` — builds without SSR crash
  </verify>
  <done>Tab bar with active highlighting, dirty indicators, close buttons, and overflow scroll. EditorArea combines TabBar + LazyMonacoEditor with empty state. Editor panel in IDELayout replaced with EditorArea. Full end-to-end flow: click file → tab opens → edit → save → close.</done>
</task>

</tasks>

<verification>
- `npm run build:app` — builds WITHOUT "window is not defined" error (P1 SSR pitfall)
- `npm run dev:app` — starts without errors
- Navigate to `/`:
  1. Sidebar shows file tree (from 06-02)
  2. Editor area shows "No file open" empty state
  3. Click a file → tab appears, Monaco loads with syntax highlighting
  4. Type in editor → dirty indicator (blue dot) appears on tab
  5. Cmd/Ctrl+S → indicator clears, file saved to disk
  6. Open multiple files → switch between tabs, cursor positions preserved
  7. Close a tab → adjacent tab activates, or empty state if last tab
  8. Drag panel dividers → everything still works after resize
- No console errors about Web Workers (P2 pitfall)
- Existing routes (/chat, /settings, /tasks) still work
</verification>

<success_criteria>
1. Monaco editor renders in center panel with syntax highlighting for TS, JS, JSON, CSS, HTML, Python, Go, Rust, Markdown
2. Multi-tab management: open, switch, close tabs with dirty indicators and cursor preservation
3. Save with Cmd/Ctrl+S triggers writeFile server function and clears dirty state
4. SSR-safe: build succeeds, no "window is not defined" errors
5. Monaco workers configured: no "Could not create web worker(s)" warnings in console
6. 20-model LRU cap prevents memory accumulation
7. No regressions: panel resizing, file tree, existing routes all still work
</success_criteria>

<output>
After completion, create `.planning/phases/06-ide-shell/06-03-SUMMARY.md`
</output>
