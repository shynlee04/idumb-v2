[
  {
    "description": "Dynamic port proxy: backend writes actual port to .idumb/brain/dashboard-port.json (already done in server.ts), frontend/CLI reads it to configure Vite proxy dynamically instead of hardcoding port 3001",
    "steps": [
      "In cli/dashboard.ts, after startServer() resolves, read the actual backend port from .idumb/brain/dashboard-port.json",
      "Pass the actual backend port to the Vite dev server via --define or environment variable (VITE_BACKEND_PORT)",
      "In frontend/vite.config.ts, read the backend port from process.env.VITE_BACKEND_PORT instead of hardcoding 3001",
      "Add fallback: if env var is not set, default to 3001 (backward compatible)",
      "Test: start dashboard when port 3001 is occupied — verify frontend API calls reach the backend on the retried port",
      "Verify npm run typecheck passes with zero errors"
    ],
    "passes": false
  },
  {
    "description": "Production serve mode: Express backend serves built frontend assets via express.static when running from compiled dist/, falling back to Vite dev server when running from source",
    "steps": [
      "In server.ts, add express.static middleware pointing to the frontend dist/ directory (resolve relative to __dirname)",
      "In cli/dashboard.ts, detect whether running from source (tsx) vs compiled (dist/) by checking if src/dashboard/frontend/vite.config.ts exists",
      "If running from compiled dist/ AND frontend dist/index.html exists, skip spawning Vite dev server — let Express serve the static assets",
      "If running from source OR no built frontend exists, fall back to spawning Vite dev server (current behavior)",
      "Add a catch-all route in Express to serve index.html for client-side routing (SPA fallback)",
      "Test: build frontend, run dashboard from compiled CLI — verify frontend loads from Express without Vite",
      "Verify npm run typecheck passes with zero errors"
    ],
    "passes": false
  },
  {
    "description": "Remove mocked artifact metadata and fix WebSocket event mismatch: PlanningArtifactsPanel uses getMockMetadata() and frontend listens for 'state-update' event that server never sends",
    "steps": [
      "In PlanningArtifactsPanel.tsx, remove getMockMetadata() function — fetch real metadata from backend or derive from file stats",
      "Create a GET /api/artifacts/metadata endpoint in server.ts that returns file stats (size, modified date, created date) for a given artifact path",
      "In frontend/App.tsx, remove 'state-update' from the WebSocket event listener list (line ~45) — server only sends 'file-changed', 'artifact-saved', 'comment-added/updated/deleted'",
      "Alternatively, add 'state-update' broadcast to the server when state.json changes via the chokidar watcher",
      "Verify no dead event listeners remain in the frontend",
      "Verify npm run typecheck passes with zero errors"
    ],
    "passes": false
  },
  {
    "description": "Fix frontend directory resolution for compiled CLI: join(__dirname, '../dashboard/frontend') resolves wrong when running from dist/cli/dashboard.js vs src/cli/dashboard.ts",
    "steps": [
      "In cli/dashboard.ts, resolve the frontend directory using multiple strategies: (1) relative to source if running via tsx, (2) relative to package root if running from dist/",
      "Use import.meta.url or fileURLToPath to determine the actual running file location",
      "Check if the resolved frontend directory contains package.json or vite.config.ts as existence validation",
      "Fall back to the package root + 'src/dashboard/frontend' if relative resolution fails",
      "Add clear error message if no frontend directory can be found",
      "Test: run dashboard from compiled dist/ — verify frontend directory resolves correctly",
      "Verify npm run typecheck passes with zero errors"
    ],
    "passes": false
  }
]
