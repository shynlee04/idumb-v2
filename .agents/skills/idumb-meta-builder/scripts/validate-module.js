#!/usr/bin/env node

/**
 * iDumb Module Validator
 *
 * Validates workflow modules generated by idumb-meta-builder
 * Usage: node validate-module.js <module-file.md>
 */

import { readFileSync, existsSync } from 'fs';
import { resolve } from 'path';

// ANSI colors for output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(level, message) {
  const color = level === 'error' ? colors.red :
                level === 'warn' ? colors.yellow :
                level === 'info' ? colors.cyan :
                level === 'pass' ? colors.green : colors.reset;
  console.log(`${color}[${level.toUpperCase()}]${colors.reset} ${message}`);
}

// Extract YAML frontmatter from markdown
function extractFrontmatter(content) {
  const match = content.match(/^---\s*\n([\s\S]*?)\n---/);
  if (!match) return null;
  return parseYaml(match[1]);
}

// Simple YAML parser for frontmatter
function parseYaml(yaml) {
  const result = {};
  const lines = yaml.split('\n');
  let currentKey = null;
  let inArray = false;
  let currentArray = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;

    // Array item
    if (trimmed.startsWith('- ')) {
      const value = trimmed.slice(2).trim().replace(/^["']|["']$/g, '');
      currentArray.push(value);
      inArray = true;
      continue;
    }

    // End of array
    if (inArray && trimmed.includes(':')) {
      if (currentKey) result[currentKey] = currentArray;
      currentArray = [];
      inArray = false;
    }

    // Key-value pair
    const colonIndex = trimmed.indexOf(': ');
    if (colonIndex > 0) {
      if (inArray && currentKey) {
        result[currentKey] = currentArray;
        currentArray = [];
        inArray = false;
      }

      const key = trimmed.slice(0, colonIndex).trim();
      let value = trimmed.slice(colonIndex + 2).trim();

      // Remove quotes
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }

      // Parse booleans and numbers
      if (value === 'true') value = true;
      else if (value === 'false') value = false;
      else if (value === 'null' || value === '~') value = null;
      else if (!isNaN(Number(value)) && value !== '') {
        const num = Number(value);
        if (String(num) === value) value = num;
      }

      currentKey = key;
      result[key] = value;
    }
  }

  // Handle last array
  if (inArray && currentKey) {
    result[currentKey] = currentArray;
  }

  return result;
}

// Layer 1: Schema Validation
function validateSchema(frontmatter) {
  const issues = [];
  let score = 100;

  const required = ['type', 'name', 'version', 'workflow_type', 'complexity',
                    'created', 'created_by', 'validated_by', 'coverage_score', 'status'];

  for (const field of required) {
    if (!(field in frontmatter)) {
      issues.push({ level: 'error', field, message: `Missing required field: ${field}` });
      score -= 10;
    }
  }

  // Validate enums
  if (frontmatter.workflow_type) {
    const validTypes = ['planning', 'execution', 'validation', 'integration'];
    if (!validTypes.includes(frontmatter.workflow_type)) {
      issues.push({ level: 'error', field: 'workflow_type',
                    message: `Invalid value: ${frontmatter.workflow_type}. Must be one of: ${validTypes.join(', ')}` });
      score -= 10;
    }
  }

  if (frontmatter.complexity) {
    const validComplexity = ['simple', 'moderate', 'complex'];
    if (!validComplexity.includes(frontmatter.complexity)) {
      issues.push({ level: 'error', field: 'complexity',
                    message: `Invalid value: ${frontmatter.complexity}. Must be one of: ${validComplexity.join(', ')}` });
      score -= 10;
    }
  }

  if (frontmatter.status) {
    const validStatus = ['draft', 'validated', 'approved', 'deprecated'];
    if (!validStatus.includes(frontmatter.status)) {
      issues.push({ level: 'error', field: 'status',
                    message: `Invalid value: ${frontmatter.status}. Must be one of: ${validStatus.join(', ')}` });
      score -= 10;
    }
  }

  // Validate version format (semver)
  if (frontmatter.version) {
    const semverPattern = /^\d+\.\d+\.\d+(-[\w-]+)?$/;
    if (!semverPattern.test(frontmatter.version)) {
      issues.push({ level: 'error', field: 'version',
                    message: `Invalid version format: ${frontmatter.version}. Use semver: X.Y.Z` });
      score -= 5;
    }
  }

  // Validate timestamp (ISO-8601)
  if (frontmatter.created) {
    const isoPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
    if (!isoPattern.test(frontmatter.created)) {
      issues.push({ level: 'error', field: 'created',
                    message: `Invalid timestamp format: ${frontmatter.created}. Use ISO-8601` });
      score -= 5;
    }
  }

  // Validate module name (kebab-case)
  if (frontmatter.name) {
    const kebabPattern = /^[a-z0-9]+(-[a-z0-9]+)*$/;
    if (!kebabPattern.test(frontmatter.name)) {
      issues.push({ level: 'error', field: 'name',
                    message: `Invalid module name: ${frontmatter.name}. Use kebab-case` });
      score -= 5;
    }
  }

  // Validate coverage score range
  if (frontmatter.coverage_score !== undefined) {
    const score = Number(frontmatter.coverage_score);
    if (isNaN(score) || score < 0 || score > 100) {
      issues.push({ level: 'error', field: 'coverage_score',
                    message: `Coverage score must be 0-100, got: ${frontmatter.coverage_score}` });
      score -= 5;
    }
  }

  return { status: issues.some(i => i.level === 'error') ? 'fail' : 'pass', score, issues };
}

// Layer 2: Integration Validation (mock - checks structure only)
function validateIntegration(frontmatter, content) {
  const issues = [];
  let score = 100;

  // Check if Integration Points section exists
  if (!content.includes('## Integration Points')) {
    issues.push({ level: 'warn', section: 'Integration Points',
                  message: 'Integration Points section not found' });
    score -= 20;
  }

  // Check if workflow steps reference agents
  if (!content.includes('**Agent:**')) {
    issues.push({ level: 'warn', section: 'Workflow Steps',
                  message: 'No agent bindings found in workflow steps' });
    score -= 30;
  }

  // Check if checkpoints defined
  if (!content.includes('## Checkpoints')) {
    issues.push({ level: 'error', section: 'Checkpoints',
                  message: 'Checkpoints section is required' });
    score -= 20;
  }

  return { status: issues.some(i => i.level === 'error') ? 'fail' : issues.some(i => i.level === 'warn') ? 'warning' : 'pass', score, issues };
}

// Layer 3: Completeness Validation
function validateCompleteness(content) {
  const issues = [];
  let score = 100;

  // Required sections
  const requiredSections = [
    '## Overview',
    '## Workflow Steps',
    '## Checkpoints',
    '## Integration Points',
    '## Validation Criteria',
  ];

  for (const section of requiredSections) {
    if (!content.includes(section)) {
      issues.push({ level: 'error', section,
                    message: `Required section missing: ${section}` });
      score -= 15;
    }
  }

  // Check for exit conditions
  if (!content.includes('Post-Execution Checkpoint') && !content.includes('### Post-Execution')) {
    issues.push({ level: 'warn', section: 'Exit Conditions',
                  message: 'No post-execution checkpoint defined' });
    score -= 10;
  }

  // Check for error handling
  if (!content.includes('## Error Handling') && !content.includes('**On Failure:**')) {
    issues.push({ level: 'warn', section: 'Error Handling',
                  message: 'No error handling defined' });
    score -= 10;
  }

  // Check for step dependencies
  if (!content.includes('## Step Dependencies') && !content.includes('Step Dependencies')) {
    issues.push({ level: 'info', section: 'Dependencies',
                  message: 'Step dependencies not explicitly defined' });
    score -= 5;
  }

  return { status: issues.some(i => i.level === 'error') ? 'fail' : issues.some(i => i.level === 'warn') ? 'warning' : 'pass', score, issues };
}

// Layer 4: Governance Validation
function validateGovernance(frontmatter, content) {
  const issues = [];
  let score = 100;

  // Check state operations
  if (!content.includes('idump-state') && !content.includes('idumb-state')) {
    issues.push({ level: 'info', section: 'State Management',
                  message: 'No state operations found (idumb-state tool)' });
    score -= 10;
  }

  // Check for history recording
  if (!content.includes('history') && !content.includes('History')) {
    issues.push({ level: 'info', section: 'History',
                  message: 'No history recording found' });
    score -= 5;
  }

  // Check for anchor creation on critical decisions
  if (frontmatter.complexity === 'complex' && !content.includes('anchor')) {
    issues.push({ level: 'warn', section: 'Anchors',
                  message: 'Complex workflow should create anchors for critical decisions' });
    score -= 10;
  }

  return { status: issues.some(i => i.level === 'error') ? 'fail' : issues.some(i => i.level === 'warn') ? 'warning' : 'pass', score, issues };
}

// Main validation function
function validateModule(filePath) {
  const fullPath = resolve(filePath);

  if (!existsSync(fullPath)) {
    log('error', `Module file not found: ${fullPath}`);
    process.exit(1);
  }

  log('info', `Validating module: ${fullPath}`);

  const content = readFileSync(fullPath, 'utf8');
  const frontmatter = extractFrontmatter(content);

  if (!frontmatter) {
    log('error', 'No YAML frontmatter found');
    process.exit(1);
  }

  log('info', `Module: ${frontmatter.name || 'unnamed'} v${frontmatter.version || 'unknown'}`);
  log('info', `Type: ${frontmatter.workflow_type || 'unknown'} | Complexity: ${frontmatter.complexity || 'unknown'}`);
  console.log('');

  const startTime = Date.now();

  // Run all validation layers
  const layer1 = validateSchema(frontmatter);
  const layer2 = validateIntegration(frontmatter, content);
  const layer3 = validateCompleteness(content);
  const layer4 = validateGovernance(frontmatter, content);

  const duration = Date.now() - startTime;

  // Calculate overall score
  const overallScore = Math.round((layer1.score + layer2.score + layer3.score + layer4.score) / 4);
  const hasErrors = [layer1, layer2, layer3, layer4].some(l => l.status === 'fail');
  const hasWarnings = [layer1, layer2, layer3, layer4].some(l => l.status === 'warning');

  // Print results
  console.log('═══ Validation Results ═══');
  console.log('');

  console.log(`Layer 1: Schema Validation`);
  log(layer1.status === 'pass' ? 'pass' : 'error', `  Status: ${layer1.status.toUpperCase()} | Score: ${layer1.score}/100 | Duration: ${duration}ms`);
  if (layer1.issues.length > 0) {
    layer1.issues.forEach(issue => log(issue.level, `    - ${issue.message}`));
  }
  console.log('');

  console.log(`Layer 2: Integration Validation`);
  log(layer2.status === 'pass' ? 'pass' : (layer2.status === 'warning' ? 'warn' : 'error'), `  Status: ${layer2.status.toUpperCase()} | Score: ${layer2.score}/100`);
  if (layer2.issues.length > 0) {
    layer2.issues.forEach(issue => log(issue.level, `    - ${issue.message}`));
  }
  console.log('');

  console.log(`Layer 3: Completeness Validation`);
  log(layer3.status === 'pass' ? 'pass' : (layer3.status === 'warning' ? 'warn' : 'error'), `  Status: ${layer3.status.toUpperCase()} | Score: ${layer3.score}/100`);
  if (layer3.issues.length > 0) {
    layer3.issues.forEach(issue => log(issue.level, `    - ${issue.message}`));
  }
  console.log('');

  console.log(`Layer 4: Governance Validation`);
  log(layer4.status === 'pass' ? 'pass' : (layer4.status === 'warning' ? 'warn' : 'error'), `  Status: ${layer4.status.toUpperCase()} | Score: ${layer4.score}/100`);
  if (layer4.issues.length > 0) {
    layer4.issues.forEach(issue => log(issue.level, `    - ${issue.message}`));
  }
  console.log('');

  console.log('═══ Summary ═══');
  const overallStatus = hasErrors ? 'FAIL' : hasWarnings ? 'WARNING' : 'PASS';
  log(hasErrors ? 'error' : hasWarnings ? 'warn' : 'pass', `Overall: ${overallStatus} | Score: ${overallScore}/100`);

  const criticalIssues = [...layer1.issues, ...layer2.issues, ...layer3.issues, ...layer4.issues].filter(i => i.level === 'error');
  const warnings = [...layer1.issues, ...layer2.issues, ...layer3.issues, ...layer4.issues].filter(i => i.level === 'warn');

  if (criticalIssues.length > 0) {
    console.log('');
    log('error', `Critical Issues: ${criticalIssues.length}`);
    criticalIssues.forEach(issue => log('error', `  - ${issue.message}`));
  }

  if (warnings.length > 0) {
    console.log('');
    log('warn', `Warnings: ${warnings.length}`);
    warnings.forEach(issue => log('warn', `  - ${issue.message}`));
  }

  console.log('');

  // Update coverage_score in frontmatter if validation passed
  if (!hasErrors && frontmatter.coverage_score !== overallScore) {
    log('info', `Recommend updating coverage_score from ${frontmatter.coverage_score} to ${overallScore}`);
  }

  process.exit(hasErrors ? 1 : 0);
}

// CLI entry point
if (process.argv.length < 3) {
  console.log('Usage: node validate-module.js <module-file.md>');
  process.exit(1);
}

validateModule(process.argv[2]);
